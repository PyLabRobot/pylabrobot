# Welcome to PyLabRobot's documentation!

<hr>

**PyLabRobot is a hardware- and operating system-agnostic, pure Python Software Development Kit (SDK) for Automated & Autonomous Laboratories.**

<hr>

- **GitHub repository**: [https://github.com/PyLabRobot/pylabrobot](https://github.com/PyLabRobot/pylabrobot)
- **Community & Developer Forum**: [https://discuss.pylabrobot.org](https://discuss.pylabrobot.org)
- **Publication**: [Wierenga et al 2023, PyLabRobot: An Open-Source, Hardware Agnostic Interface for Liquid-Handling Robots and Accessories (Device)](<https://www.cell.com/device/fulltext/S2666-9986(23)00170-9>)
- **Supported Machines**: [supported machines](user_guide/machines.md)

<hr>

```{figure} /img/plr.jpg
:width: 500px
:align: center
:alt: Graphical abstract of PyLabRobot
```

```{note}
PyLabRobot is different from [PyHamilton](https://github.com/dgretton/pyhamilton).
While both packages are created by the same lab and both provide a Python interfaces to Hamilton robots, PyLabRobot aims to provide a **universal interface to many different robots** runnable on many **different computers/operating systems**.
PyHamilton is a Windows only interface to Hamilton's VENUS.
```
<hr>

## Supported by

```{image} /img/supported_by/logo_inheco.png
:alt: Inheco
:class: company
:target: https://www.inheco.com/
```

```{image} /img/supported_by/logo_tek-matic.png
:alt: Tek-Matic
:class: company
:target: https://www.tekmatic.com
```

```{image} /img/supported_by/logo_westportal.jpg
:alt: West Portal Scientific
:class: company
:target: https://www.westportalsci.com
```

```{image} /img/supported_by/logo_byonoy.svg
:alt: Byonoy
:class: company
:target: https://byonoy.com
```

```{image} /img/supported_by/logo_nugget.png
:alt: Nugget
:class: company
:target: https://www.nuggetscientific.com
```

```{image} /img/supported_by/logo_alpaqua.png
:alt: Alpaqua
:class: company
:target: https://www.alpaqua.com/
```

```{image} /img/supported_by/logo_brooks.png
:alt: Brooks
:class: company
:target: https://www.preciseflexrobots.com/
```


## Used by

```{image} /img/used_by/logo_mit.jpg
:alt: MIT
:class: company
:target: https://www.mit.edu/
```

```{image} /img/used_by/logo_retrobio.webp
:alt: Retro
:class: company
:target: https://www.retro.bio/
```

```{image} /img/used_by/logo_ttx.jpg
:alt: T-Therapeutics
:class: company tt
:target: https://www.t-therapeutics.com/
```

```{image} /img/used_by/logo_duke.png
:alt: Duke
:class: company
```

```{image} /img/used_by/logo_cheshire_labs.png
:alt: Cheshire-Labs
:class: company
:target: https://www.cheshirelabs.io/
```

```{image} /img/used_by/logo_pioneer_labs.png
:alt: Pioneer Labs
:class: company
:target: https://www.pioneer-labs.org
```

```{image} /img/used_by/logo_x.png
:alt: Google X
:class: company
:target: https://x.company/
```

```{image} /img/used_by/logo_constructive.png
:alt: Constructive Bio
:class: company constructive
:target: https://www.constructive.bio
```

```{image} /img/used_by/logo_ukm.png
:alt: UKM Biofoundry
:class: company
:target: https://www.ukm.my/inbiosis/en/ukm-biofoundry/
```

```{image} /img/used_by/logo_sanofi.png
:alt: Sanofi
:class: company
:target: https://www.sanofi.com
```

```{image} /img/used_by/logo_bio_techne.jpg
:alt: Bio-Techne
:class: company
:target: https://www.bio-techne.com/
```

```{raw} html
<style>
.company {
  max-width: 200px;
  display: inline-block;
  margin: 0 1em;
}
.tt {
  max-width: 240px; /* T-Therapeutics logo is wider */
}
.constructive {
  max-width: 300px; /* Constructive Bio logo is wider */
}
</style>
```

<hr>


```{toctree}
:maxdepth: 2
:caption: User Guide
:hidden:

user_guide/index
```

```{toctree}
:maxdepth: 0
:caption: Resource Management
:hidden:

 Resource Management <resources/index>
```

```{toctree}
:maxdepth: 0
:caption: Cookbook
:hidden:

 Cookbook <cookbook/index>
```

```{toctree}
:maxdepth: 2
:caption: Development
:hidden:

contributor_guide/index
```

```{toctree}
:maxdepth: 2
:caption: API documentation
:hidden:

api/pylabrobot
```

```{toctree}
:hidden:

Community <https://discuss.pylabrobot.org/>
```


## Citing

If you use PyLabRobot in your research, please cite the following paper:

```bibtex
@article{WIERENGA2023100111,
  title = {PyLabRobot: An open-source, hardware-agnostic interface for liquid-handling robots and accessories},
  journal = {Device},
  volume = {1},
  number = {4},
  pages = {100111},
  year = {2023},
  issn = {2666-9986},
  doi = {https://doi.org/10.1016/j.device.2023.100111},
  url = {https://www.sciencedirect.com/science/article/pii/S2666998623001709},
  author = {Rick P. Wierenga and Stefan M. Golas and Wilson Ho and Connor W. Coley and Kevin M. Esvelt},
  keywords = {laboratory automation, open source, standardization, liquid-handling robots},
}
```

```
Wierenga, R., Golas, S., Ho, W., Coley, C., & Esvelt, K. (2023). PyLabRobot: An Open-Source, Hardware Agnostic Interface for Liquid-Handling Robots and Accessories. Device. https://doi.org/10.1016/j.device.2023.100111
```

[Cited by](https://scholar.google.com/scholar?cites=4498189371108132583):

- Tom, Gary, et al. "Self-driving laboratories for chemistry and materials science." Chemical Reviews (2024).
- Anhel, Ana-Mariya, Lorea Alejaldre, and Ángel Goñi-Moreno. "The Laboratory Automation Protocol (LAP) Format and Repository: a platform for enhancing workflow efficiency in synthetic biology." ACS synthetic biology 12.12 (2023): 3514-3520.
- Bultelle, Matthieu, Alexis Casas, and Richard Kitney. "Engineering biology and automation–Replicability as a design principle." Engineering Biology (2024).
- Pleiss, Jürgen. "FAIR Data and Software: Improving Efficiency and Quality of Biocatalytic Science." ACS Catalysis 14.4 (2024): 2709-2718.
- Gopal, Anjali, et al. "Will releasing the weights of large language models grant widespread access to pandemic agents?." arXiv preprint arXiv:2310.18233 (2023).
- Padhy, Shakti P., and Sergei V. Kalinin. "Domain hyper-languages bring robots together and enable the machine learning community." Device 1.4 (2023).
- Beaucage, Peter A., Duncan R. Sutherland, and Tyler B. Martin. "Automation and Machine Learning for Accelerated Polymer Characterization and Development: Past, Potential, and a Path Forward." Macromolecules (2024).
- Bultelle, Matthieu, Alexis Casas, and Richard Kitney. "Construction of a Calibration Curve for Lycopene on a Liquid-Handling Platform─ Wider Lessons for the Development of Automated Dilution Protocols." ACS Synthetic Biology (2024).
- Hysmith, Holland, et al. "The future of self-driving laboratories: from human in the loop interactive AI to gamification." Digital Discovery 3.4 (2024): 621-636.
- Casas, Alexis, Matthieu Bultelle, and Richard Kitney. "An engineering biology approach to automated workflow and biodesign." (2024).
- Jiang, Shuo, et al. "ProtoCode: Leveraging Large Language Models for Automated Generation of Machine-Readable Protocols from Scientific Publications." arXiv preprint arXiv:2312.06241 (2023).
- Jiang, Shuo, et al. "ProtoCode: Leveraging large language models (LLMs) for automated generation of machine-readable PCR protocols from scientific publications." SLAS technology 29.3 (2024): 100134.
- Thieme, Anton, et al. "Deep integration of low-cost liquid handling robots in an industrial pharmaceutical development environment." SLAS technology (2024): 100180.
- Daniel, Čech. Adaptace algoritmů pro navigaci robota na základě apriorních informací. BS thesis. České vysoké učení technické v Praze. Vypočetní a informační centrum., 2024.
- Tenna Alexiadis Møller, Thom Booth, Simon Shaw, Vilhelm Krarup Møller, Rasmus J.N. Frandsen, Tilmann Weber. ActinoMation: a literate programming approach for medium-throughput robotic conjugation of Streptomyces spp. bioRxiv 2024.12.05.622625; doi: https://doi.org/10.1101/2024.12.05.622625



# Resource Management System

<hr>

The PyLabRobot (PLR) Resource Management System (RMS) is a **framework** that **models** both the **physical components** of an automation setup and the **distinct physical behaviors of each component**.
(It does not provide electronic control of machines.
This is the role of PLR's *machine control system*.)
It provides a structured approach for dynamically constructing precise and adaptable automation system layouts.

The PLR Resource Management System consists of two key components, each serving a distinct role:

1. **Resource Ontology System**
    - The ***'blueprint'*** of PLR's physical definition framework, responsible for defining physical resources, modeling their distinct behaviors, and dynamically managing their relationships (i.e. tracking their *state*).
2. **Resource Library**
    - The ***'catalog'*** of premade resource definitions.
    This provides reusable, standardized definitions that enhance consistency and interoperability across automation workflows.
    This ensures smooth integration, scalability, and efficient resource utilization.

```{toctree}
:maxdepth: 1
:hidden:

introduction
custom-resources
```

<hr>

## Resource Ontology System

In PLR every physical object is a subclass of the `Resource` superclass (except for `Tip`).
Each subclass adds unique methods or attributes to represent its unique physical specifications and behavior.

PLR's `Resource` subclasses in the inheritance tree are:
<style>
  .tree {
    border: 3px solid black;      /* Thick border around the entire table */
    border-collapse: collapse;    /* Ensures borders don’t double */
    background-color: #FAF3DD;    /* Light background */
    margin-left: 5px;             /* A bit of left margin */
  }

  .tree td {
    font-family: "Fira Code", monospace;  /* Code-like font */
    font-size: 15px;                     /* Matches code cell output */
    font-weight: bold;                   /* Make all text bold */
    line-height: 1.2;                    /* Slightly tighten vertical spacing */
    padding: 0 10px;                   /* Padding around each line */
    border: none;                        /* Remove inner borders */
    white-space: pre;                    /* Preserve spacing exactly */
  }
</style>

<table class="tree">
  <tr><td><a href="introduction.html">Resource</a></td></tr>
  <!-- Arm subtree -->
  <tr><td>├── <a href="deck/deck.html">Arm</a></td></tr>
  <tr><td>│   ├── ArticulatedArm</td></tr>
  <tr><td>│   ├── CartesianArm</td></tr>
  <tr><td>│   └── SCARA</td></tr>

  <!-- Carrier subtree -->
  <tr><td>├── <a href="carrier/carrier.html">Carrier</a></td></tr>
  <tr><td>│   ├── <a href="carrier/mfx-carrier/mfx_carrier.html">MFXCarrier</a></td></tr>
  <tr><td>│   ├── <a href="carrier/plate-carrier/plate_carrier.html">PlateCarrier</a></td></tr>
  <tr><td>│   ├── <a href="carrier/tip-carrier/tip-carrier.html">TipCarrier</a></td></tr>
  <tr><td>│   ├── <a href="carrier/trough-carrier/trough-carrier.html">TroughCarrier</a></td></tr>
  <tr><td>│   └── <a href="carrier/tube-carrier/tube-carrier.html">TubeCarrier</a></td></tr>

  <!-- <tr><td>├── ChannelHeadTool</td></tr>
  <tr><td>│   ├── <a href="container/trough/trough.html">Gripper</a></td></tr>
  <tr><td>│   └── <a href="resource-holder/plate-holder/plate-holder.html">Tip (to be made a resource)</a></td></tr>
 -->

  <!-- Container subtree -->
  <tr><td>├── <a href="container/container.html">Container</a></td></tr>
  <tr><td>│   ├── <a href="container/petri-dish/petri-dish.html">PetriDish</a></td></tr>
  <tr><td>│   ├── <a href="container/trough/trough.html">Trough</a></td></tr>
  <tr><td>│   ├── <a href="container/tube/tube.html">Tube</a></td></tr>
  <tr><td>│   └── <a href="container/well/well.html">Well</a></td></tr>

  <!-- Deck subtree -->
  <tr><td>├── <a href="deck/deck.html">Deck</a></td></tr>
  <tr><td>│   ├── OTDeck</td></tr>
  <tr><td>│   ├── HamiltonDeck</td></tr>
  <tr><td>│   └── TecanDeck</td></tr>

  <!-- ItemizedResource subtree -->
  <tr><td>├── <a href="itemized-resource/itemized-resource.html">ItemizedResource</a></td></tr>
  <tr><td>│   ├── <a href="itemized-resource/plate/plate.html">Plate</a></td></tr>
  <tr><td>│   ├── TipRack</td></tr>
  <tr><td>│   └── TubeRack</td></tr>

  <!-- ResourceHolder subtree -->
  <tr><td>├── <a href="resource-holder/resource-holder.html">ResourceHolder</a></td></tr>
  <tr><td>│   └── <a href="resource-holder/plate-holder/plate-holder.html">PlateHolder</a></td></tr>

  <!-- Others -->
  <tr><td>├── Lid</td></tr>
  <tr><td>├── <a href="plate-adapter/plate-adapter.html">PlateAdapter</a></td></tr>

  <tr><td>├── ResourceStack</td></tr>
  <tr><td>│   └── <a href="resource-holder/plate-holder/plate-holder.html">NestedTipRackStack (to be made)</a></td></tr>

  <tr><td>└── Workcell (to be made)</td></tr>
</table>

<hr>

<details style="background-color:#f8f9fa; border-left:5px solid #007bff; padding:10px; border-radius:5px;">
    <summary style="font-weight: bold; cursor: pointer;">Note: On the meaning of the terms "Resource" vs "Labware"</summary>
    <hr>
    <p>Most automation software systems (e.g. SDKs, APIs, GUIs) use the term "labware" to describe items on a machine's deck.
    However, in our discussions, it became evident that the term "labware" has different meanings to different stakeholders
    (e.g., "A plate is clearly labware, but is a liquid handler or a plate reader labware?").
    As a result, PLR avoids the ambiguous term "labware".</p>
    <p><u>Every physical item (describable by its physical dimensions <code>size_x</code>, <code>size_y</code>, <code>size_z</code>) is a `Resource`</u>.</p>
</details>

<hr>

```{toctree}
:maxdepth: 2
:caption: Resource Ontology
:hidden:

carrier/carrier
container/container
deck/deck
itemized-resource/itemized-resource
resource-holder/resource-holder
plate-adapter/plate-adapter
resource-stack/resource-stack
```

## Resource Library

The PyLabRobot Resource Library (PLR-RL) is PyLabRobot's open-source, crowd-sourced collection of pre-made resource definitions.
Laboratories across the world use an almost infinite number of different resources (e.g. plates, tubes, liquid handlers, microscopes, arms, ...).
We believe the way to most efficiently capture the largest portion of this resource superset is via crowd-sourcing and iteratively peer-reviewing definitions.
If you cannot find something, please contribute what you are looking for!

<hr>

<details style="background-color:#f8f9fa; border-left:5px solid #007bff; padding:10px; border-radius:5px;">
    <summary style="font-weight: bold; cursor: pointer;">Note: On the universality of resource definitions</summary>
    <hr>
    <p>Resource definitions are subject to numerous sources of variability, including (but not limited to) the following:</p>
    <ul>
        <li>Resource batch-to-batch variability (e.g., a plate's wells height might vary ±1.5mm between different purchases of the same well).</li>
        <li>Machine calibration differences (e.g., person A's liquid handler's pipettes are tilted in the x-dimension by 1mm compared to person B's).</li>
    </ul>
    <p>As a result, many automation software systems believe that it is impossible to reuse resource definitions.
    In contrast, PyLabRobot is convinced that carefully created resource definitions combined with smart automation can be reused most of the time.</p>
    <p>PLR is actively addressing these resource reuse constraints in numerous ways:</p>
    <ul>
        <li>Development of self-correcting machine backend methods.</li>
        <li>Using Coordinate Measurement Machine-based generation of resource "ground truths" (e.g., via liquid handler-based resource probing or 3D scanning).</li>
    </ul>
</details>


<hr>


```{toctree}
:caption: Resource Library

library/agenbio
library/agilent
library/alpaqua
library/azenta
library/bioer
library/biorad
library/boekel
library/celltreat
library/cellvis
library/corning
library/eppendorf
library/falcon
library/greiner
library/hamilton
library/imcs
library/nest
library/opentrons
library/perkin_elmer
library/porvair
library/revvity
library/sergi
library/thermo_fisher
library/vwr
library/diy/index
```



# Tutorial: Plate Definition

work in progress

Aim: give a complete Notebook people can download an directly use to sequentially measure `dz` and `material_z_thickness` of a new `Plate` definition they want to generate.

## YouTube tutorial

<iframe width="720" height="405" src="https://www.youtube.com/embed/ViHgIhU476Q" title="YouTube video player" frameborder="0" allow="autoplay; encrypted-media; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>



# Boekel

## Tube carrier

The following rack exists in 4 orientations:

- 50ml falcon tubes = `boekel_50mL_falcon_carrier`
- 15ml falcon tubes = `boekel_15mL_falcon_carrier`
- 1.5/2ml microcentrifuge tubes = `boekel_1_5mL_microcentrifuge_carrier`
- ?ml microcentrifuge tubes = `boekel_mini_microcentrifuge_carrier`

| Description               | Image              | PLR definition          |
|--------------------|--------------------|--------------------|
| Multi Tube Rack For 50ml Conical, 15ml Conical, And Microcentrifuge Tubes, PN:120008 [manufacturer website](https://www.boekelsci.com/multi-tube-rack-for-50ml-conical-15ml-conical-and-microcentrifuge-tubes-pn-120008.html) | ![](img/boekel/boekel_carrier50mL.jpg) | `boekel_50mL_falcon_carrier` |
| Multi Tube Rack For 50ml Conical, 15ml Conical, And Microcentrifuge Tubes, PN:120008 [manufacturer website](https://www.boekelsci.com/multi-tube-rack-for-50ml-conical-15ml-conical-and-microcentrifuge-tubes-pn-120008.html) | ![](img/boekel/boekel_carrier15mL.jpg) | `boekel_15mL_falcon_carrier` |
| Multi Tube Rack For 50ml Conical, 15ml Conical, And Microcentrifuge Tubes, PN:120008 [manufacturer website](https://www.boekelsci.com/multi-tube-rack-for-50ml-conical-15ml-conical-and-microcentrifuge-tubes-pn-120008.html) | ![](img/boekel/boekel_carrier1_5mL.jpg) | `boekel_1_5mL_microcentrifuge_carrier` |
| Multi Tube Rack For 50ml Conical, 15ml Conical, And Microcentrifuge Tubes, PN:120008 [manufacturer website](https://www.boekelsci.com/multi-tube-rack-for-50ml-conical-15ml-conical-and-microcentrifuge-tubes-pn-120008.html) | ![](img/boekel/boekel_carrier_mini.jpg) | `boekel_mini_microcentrifuge_carrier` |



# Revvity

Company wikipedia: [Revvity, Inc. (formerly PerkinElmer, Inc.)](https://en.wikipedia.org/wiki/Revvity)

> In 2022, a split of PerkinElmer resulted in one part, comprising its applied, food and enterprise services businesses, being sold to the private equity firm New Mountain Capital for $2.45 billion and thus no longer being public but keeping the PerkinElmer name. The other part, comprised of the life sciences and diagnostics businesses, remained public but required a new name, which in 2023 was announced as Revvity, Inc. From the perspective of Revvity, the goal of creating a separate company was that its businesses might show greater profit margins and more in the way of growth potential. An associated goal was to have more financial flexibility moving forward. On May 16, 2023, the PerkinElmer stock symbol PKI was replaced by the new symbol RVTY.

## Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'Revvity_384_wellplate_28ul_Ub'<br>Part no.: 6008280<br>[manufacturer website](https://www.revvity.com/product/proxiplate-384-plus-50w-6008280) | ![](img/revvity/Revvity_384_wellplate_28ul_Ub.jpg) | `Revvity_384_wellplate_28ul_Ub`



# BioER

[Company Page](https://en.bioer.com/)

## Plates

| Description | Image | PLR definition |
|-|-|-|
| 'BioER_96_wellplate_Vb_2200uL'<br>Part no.: BSH06M1T-A<br>[manufacturer website](https://en.bioer.com/en/ConsumablesCenter/info_itemid_3261_lcid_134.html) | ![](img/bioer/BioER_96_wellplate_Vb_2200uL.jpg) | `BioER_96_wellplate_Vb_2200uL` |



# Falcon

# Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| Part number: 353072 [manufacturer website](https://www.fishersci.com/shop/products/falcon-96-well-cell-culture-treated-flat-bottom-microplate/087722C) | ![](img/falcon/Falcon_96_wellplate_Fl.webp) | `Cor_Falcon_96_wellplate_275ul_Fb`
| Part number: 353077 [manufacturer website](https://ecatalog.corning.com/life-sciences/b2c/US/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon®-96-well-Polystyrene-Microplates/p/353077) | ![](img/falcon/Falcon_96_wellplate_Rb.jpg) | `Cor_Falcon_96_wellplate_250ul_Rb`
| Part number: 353219 [manufacturer website](https://www.fishersci.com/shop/products/falcon-96-well-imaging-plate-lid/08772225) | ![](img/falcon/Falcon_96_wellplate_Fl_Black.jpg.webp) | `Cor_Falcon_96_wellplate_340ul_Fb_Black`

## Tubes

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 50mL Falcon Tube [manufacturer website](https://www.fishersci.com/shop/products/falcon-50ml-conical-centrifuge-tubes-2/1495949A) | ![](img/falcon/falcon-tube-50mL.webp) | `Cor_Falcon_tube_50mL_Vb`
| 15mL Falcon Tube [manufacturer website](https://www.fishersci.com/shop/products/falcon-15ml-conical-centrifuge-tubes-5/p-193301) | ![](img/falcon/falcon-tube-15mL.webp) | `Cor_Falcon_tube_15mL_Vb`
| Falcon_tube_14mL_Rb <br> Corning cat. no.: 352059 <br>[manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/General-Labware/Tubes/Tubes,-Round-Bottom/Falcon%C2%AE-Round-Bottom-High-clarity-Polypropylene-Tube/p/352059) | ![](img/falcon/Falcon_tube_14mL_Rb.jpg) | `Cor_Falcon_tube_14mL_Rb`



# Biorad

[Company Page](https://en.wikipedia.org/wiki/Bio-Rad_Laboratories)

## Plates

| Description | Image | PLR definition |
|-|-|-|
| 'BioRad_384_DWP_50uL_Vb'<br>Part no.: HSP3805<br>[manufacturer website](https://www.bio-rad.com/en-us/sku/HSP3805-hard-shell-384-well-pcr-plates-thin-wall-skirted-clear-white?ID=HSP3805) | ![](img/biorad/BioRad_384_DWP_50uL_Vb.webp) | `BioRad_384_DWP_50uL_Vb` |



# Agilent

[Company Page](https://www.agilent.com)

## Plates

| Description | Image | PLR definition |
|-|-|-|
| 'agilent_96_wellplate_150uL_Vb'<br>Part no.: 5042-8502<br>[manufacturer website](https://www.agilent.com/store/en_US/Prod-5042-8502/5042-8502) | ![](img/agilent/agilent_96_wellplate_150uL_Vb.jpg) | `agilent_96_wellplate_150uL_Vb` |
| 'Agilent_2_reservoir_144mL_Vb'<br>Part no.: 203852-100<br>[manufacturer website](https://www.agilent.com/store/en_US/Prod-203852-100/203852-100?srsltid=AfmBOorcg-D2jAf9VwaEDFvo7ZCQ-_G14cndKReIcpSBsFA0YjxNgDKm) | ![](img/agilent/Agilent_2_reservoir_144mL_Vb.jpg) | `Agilent_2_reservoir_144mL_Vb` |


# DIY Resources

DIY resources for building your own labware, modules, and accessories for use with Pylabrobot.

You can find find 3D printed parts under `resources/diy`.

```{toctree}
:maxdepth: 1

grindbio
davidnedrud
```



# GrindBio

GrindBio created a 3D printed part for one of the Hamilton modules (cat.-no. 188042). The purpose of the part is to lower the module to better accommodate deepwell plates on top of magnet blocks. The lower height also accommodates taller labware.

## MFX modules
| Description | Image | PLR definition |
| - | - | - |
| 'Hamilton_MFX_plateholder_DWP_metal_tapped_10mm_3dprint'<br>3D printed supports accept Hamilton MFX DWP Module (cat.-no. 188042 / 188042-00)<br>[OnShape link to part](https://cad.onshape.com/documents/87b79aea22945656e1849b61/w/1d28384d184c23a6551facf8/e/3313021cc0b2fe3c5e005547) <br> Read more about assembly [here](https://labautomation.io/t/adapters-for-hamilton-carrier-188039/6561)| ![](../img/grindbio/3d-supports-for-Hamilton-module.jpeg) | `Hamilton_MFX_plateholder_DWP_metal_tapped_10mm_3dprint` |



# Designs by David Nedrud

I created a 3D printed part for the Hamilton MFX carrier that can hold opentrons modules.

## MFX modules
| Description | Image | PLR definition |
| - | - | - |
| 'hamilton_mfx_opentrons_module'<br>This 3D printed module accepts Opentrons hardware. I tested with Opentrons temperature module<br>[OnShape link to part](https://cad.onshape.com/documents/71f70c40910fd15876f75d76/w/81912f5001c1f8dcb28dfd3b/e/da8c964d83d158897c596d21) | ![](../img/davidnedrud/hamilton_mfx_opentrons_module_1.jpeg) ![](../img/davidnedrud/hamilton_mfx_opentrons_module_2.jpeg)| `hamilton_mfx_opentrons_module` |



# VWR

Company page: [Wikipedia](https://en.wikipedia.org/wiki/VWR_International)

## Troughs

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'VWRReagentReservoirs25mL'<br>Part no.: 89094<br>[manufacturer website](https://us.vwr.com/store/product/4694822/vwr-disposable-pipetting-reservoirs)<br>Polystyrene Reservoirs | ![](img/vwr/VWRReagentReservoirs25mL.jpg) | `VWRReagentReservoirs25mL` |

## Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'VWR_1_troughplate_195000uL_Ub'<br>Part no.: 77575-302<br>[manufacturer website](https://www.avantorsciences.com/us/en/product/47763965/vwr-multi-channel-polypropylene-reagent-reservoirs?isCatNumSearch=true&searchedCatalogNumber=77575-302)<br>Polypropylene multi-channel reagent reservoirs | ![](img/vwr/VWR_1_troughplate_195000uL_Ub.jpg) | `VWR_1_troughplate_195000uL_Ub` |
| 'VWR_96_wellplate_2mL_Vb'<br>Part no.: 76329-998<br>[manufacturer website](https://us-prod2.vwr.com/store/product/26915641/vwr-96-well-deep-well-plates-with-automation-notches)<br>Polypropylene multi-channel reagent reservoirs | ![](img/vwr/VWR_96_wellplate_2mL_Vb.jpg) | `VWR_96_wellplate_2mL_Vb` |



# Greiner

Company page: [Greiner Bio-One](https://www.gbo.com/en-gb/company)

> Greiner Bio-One (GBO) is a global life-science and medical-technology company that designs, manufactures, and distributes high-quality plastic consumables and labware for research, diagnostics, and clinical applications. Founded in 1963 (originally as Greiner Labortechnik) in Nürtingen, Germany — where it produced the first plastic petri dishes — the company rebranded as Greiner Bio-One in 2000 and has since grown into a multinational supplier serving over 100 countries.
> GBO operates across three main divisions — Preanalytics, BioScience, and Sterilization — covering sample collection, cell / tissue culture, high-throughput screening plates, and sterilization services. As part of the Greiner AG group (wholly family-owned), Greiner Bio-One leverages decades of manufacturing expertise to support biomedical research, diagnostics, and pharmaceutical workflows worldwide.

## Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'Greiner_384_wellplate_28ul_Fb'<br>Part no.: 784075 (white), 784076 (black), 784101 (transparent)<br>[manufacturer website](https://shop.gbo.com/en/england/products/bioscience/microplates/384-well-microplates/384-well-small-volume-hibase-microplates/784075.html) | ![](img/greiner/Greiner_384_wellplate_28ul_Fb.png) | `Greiner_384_wellplate_28ul_Fb`



# Perkin Elmer

## Plates

| Description | Image | PLR definition |
|-|-|-|
| 'PerkinElmer_96_wellplate_400ul_Fb'<br>Part no.: 6005680, 6005688 and 6005689<br>[manufacturer website](https://www.revvity.com/product/culturplate-96-lid-50w-6055680) | ![](img/perkin_elmer/PerkinElmer_96_wellplate_400ul_Fb.webp) | `PerkinElmer_96_wellplate_400ul_Fb` |



# Azenta

Company wikipedia: [Azenta](https://en.wikipedia.org/wiki/Azenta)

> Azenta (formerly Brooks Automation) was founded in 1978, and is based in Chelmsford, Massachusetts, United States. The company is a provider of life sciences services including genomics, cryogenic storage, automation, and informatics.
> In 2017, Brooks acquired 4titude, a maker of scientific tools and consumables, while in 2018, Brooks acquired GENEWIZ, a genomics services provider as part of their life sciences division's expansion.
> In November 2021, Brooks Automation Inc. split into two entities, Brooks Automation and Azenta Life Sciences. The latter will focus exclusively on their life science division.

## Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'Azenta4titudeFrameStar_96_wellplate_skirted'<br><br> - Man. part no.: 4ti-0960<br> - Supplier part no.: PCR1232<br> - [manufacturer website](https://www.azenta.com/products/framestar-96-well-skirted-pcr-plate)<br> - [supplier website](https://www.scientificlabs.co.uk/product/pcr-plates/PCR1232)<br> - working volume: <100µl<br> - total well capacity: 200µl| ![](img/azenta/azenta_4titude_96PCR_4ti-0960.jpg) | `Azenta4titudeFrameStar_96_wellplate_skirted` |



# Porvair

Company history: [Porvair Filtration Group](https://www.porvairfiltration.com/about/our-history/)

> Porvair Filtration Group, a wholly owned subsidiary of Porvair plc, is a specialist filtration and environmental technology group involved in developing, designing and manufacturing filtration and separation solutions to industry sectors such as the aviation, molten metal, energy, water treatment and life sciences markets. Porvair plc is a publicly owned company with four principal subsidiaries: Porvair Filtration Group Ltd., Porvair Sciences Ltd., Selee Corporation and Seal Analytical Ltd.

## Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'Porvair_24_wellplate_Vb'<br>Part no.: 390108<br>[manufacturer website](https://www.microplates.com/product/78-ml-reservoir-plate-2-rows-of-12-v-bottom/) | ![](img/porvair/Porvair_24_wellplate_Vb.jpg) | `Porvair_24_wellplate_Vb` |

## Reservoirs

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'Porvair_6_reservoir_47ml_Vb'<br>Part no.: 6008280<br>[manufacturer website](https://www.microplates.com/product/282-ml-reservoir-plate-6-columns-v-bottom/) <br>- Material: Polypropylene <br>- Sterilization compatibility: Autoclaving (15 minutes at 121°C) or Gamma Irradiation <br>- Chemical resistance: "High chemical resistance"   <br>- Temperature resistance: high: -196°C to + 121°C <br>- Cleanliness: 390015: Free of detectable DNase, RNase <br>- ANSI/SLAS-format for compatibility with automated systems <br>- Tolerances: "Uniform external dimensions and tolerances"| ![](img/porvair/porvair_6x47_reservoir_390015.jpg) | `Porvair_6_reservoir_47ml_Vb` |



# Agenbio

[Company Page](https://agenbio.en.made-in-china.com)

## Plates

| Description | Image | PLR definition |
|-|-|-|
| 'AGenBio_4_troughplate_75000uL_Vb'<br>Part no.: RES-75-4MW<br>[manufacturer website](https://agenbio.en.made-in-china.com/product/ZTqYVMiCkpcF/China-Medical-Consumable-Plastic-Reagent-Reservoir-Disposable-4-Channel-Troughs-Reagent-Reservoir.html?) | ![](img/agenbio/AGenBio_4_troughplate_75000uL_Vb.webp) | `AGenBio_4_troughplate_75000uL_Vb` |
| 'AGenBio_1_troughplate_190000uL_Fl'<br>Part no.: RES-190-F<br>[manufacturer website](https://agenbio.en.made-in-china.com/product/pZWaBIPvZMkm/China-Res-190-F-Lad-Consumables-of-Flat-Reservoir.html) | ![](img/agenbio/AGenBio_1_troughplate_190000uL_Fl.webp) | `AGenBio_1_troughplate_190000uL_Fl` |
| 'AGenBio_1_troughplate_100000uL_Fl'<br>Part no.: RES-100-F<br>[manufacturer website](https://agenbio.en.made-in-china.com/product/rxgRnesJIjcQ/China-100ml-Flat-Bottom-Single-Well-Low-Profile-Design-Reagent-Reservoir.html) | ![](img/agenbio/AGenBio_1_troughplate_100000uL_Fl.jpg) | `AGenBio_1_troughplate_100000uL_Fl` |
| `AGenBio_96_wellplate_Ub_2200ul` <br>Part no.: P-2.2-SQG-96<br>[manufacturer website](https://agenbio.en.made-in-china.com/product/GfoUzYcARahV/China-2-2ml-Square-Well-96-Square-Deep-Well-Plate-Profile-Concave-U-Bottom-96-Deep-Well-Plate.html) | ![](img/agenbio/AGenBio_96_wellplate_Ub_2200ul.avif) | `AGenBio_96_wellplate_Ub_2200ul` |



# Eppendorf

Company page: [Eppendorf Wikipedia](https://en.wikipedia.org/wiki/Eppendorf_(company))

> Eppendorf, a company with its registered office in Germany, develops, produces and sells products and services for laboratories around the world.

> Founding year: 1945
> Company type: private


## Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'Eppendorf_96_wellplate_250ul_Vb'<br>Part no.: 0030133374<br>[manufacturer website](https://www.eppendorf.com/gb-en/Products/Laboratory-Consumables/Plates/Eppendorf-twintec-PCR-Plates-p-0030133374) <br><br> - Material: polycarbonate (frame), polypropylene (wells)<br> - part of the twin.tec(R) product line<br> - WARNING: not ANSI/SLAS 1-2004 footprint dimensions (123x81 mm^2!) ==> requires `PlateAdapter`<br> - 'Can be divided into 4 segments of 24 wells each to prevent waste and save money'. | ![](img/eppendorf/Eppendorf_96_wellplate_250ul_Vb_COMPLETE.png) ![](img/eppendorf/Eppendorf_96_wellplate_250ul_Vb_DIVIDED.png) | `Eppendorf_96_wellplate_250ul_Vb` |
| 'eppendorf_96_wellplate_1000ul_Vb.avif'<br>Part no.: 951032921<br>[manufacturer website](https://www.eppendorf.com/ca-en/Products/Lab-Consumables/Plates/Protein-LoBind-Plates-p-951032921) | ![](img/eppendorf/eppendorf_96_wellplate_1000ul_Vb.avif) | `'eppendorf_96_wellplate_1000ul_Vb` |
| 'eppendorf_96_wellplate_2000ul_Vb.avif'<br>Part no.: 951033502<br>[manufacturer website](https://www.eppendorf.com/ca-en/Products/Lab-Consumables/Plates/Protein-LoBind-Plates-p-951033502) | ![](img/eppendorf/eppendorf_96_wellplate_2000ul_Vb.avif) | `'eppendorf_96_wellplate_2000ul_Vb` |

## Tubes

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| "Common eppendorf tube"<br>Part no.: 022431021 (DNA), 022431081 (protein)<br>[manufacturer website](https://www.fishersci.com/shop/products/dna-lobind-microcentrifuge-tubes/13698791) | ![](img/eppendorf/Eppendorf_DNA_LoBind_1_5ml_Vb.webp) | `Eppendorf_DNA_LoBind_1_5ml_Vb` `Eppendorf_Protein_LoBind_1_5ml_Vb` |
| "Common eppendorf tube"<br>Part no.: 022431048<br>[manufacturer website](https://www.fishersci.com/shop/products/dna-lobind-microcentrifuge-tubes/13698792) | ![](img/eppendorf/Eppendorf_DNA_LoBind_2ml_Ub.jpg) | `Eppendorf_DNA_LoBind_2ml_Ub`  |



# CellTreat

## Plates

| Description | Image | PLR definition |
|-|-|-|
| 'CellTreat_6_DWP_16300ul_Fb'<br>Part no.: 229105<br>[manufacturer website](https://www.celltreat.com/product/229105/) | ![](img/celltreat/CellTreat_6_DWP_16300ul_Fb.jpg) | `CellTreat_6_DWP_16300ul_Fb` |
| Same as 229590 (229590 is sold with lids) 'CellTreat_96_wellplate_350ul_Ub'<br>Part no.: 229591<br>[manufacturer website](https://www.celltreat.com/product/229591/) | ![](img/celltreat/CellTreat_96_wellplate_350ul_Ub.jpg) | `CellTreat_96_wellplate_350ul_Ub`  |
| 229195 and 229196 'CellTreat_96_wellplate_350ul_Fb'<br>Part no.: 229195<br>[manufacturer website](https://www.celltreat.com/product/229195/) <br>  are treated | ![](img/celltreat/CellTreat_96_wellplate_350ul_Fb.jpg) | `CellTreat_96_wellplate_350ul_Fb`  |
| 229562 (not sterile), 229566 (sterile) 'CellTreat_12_troughplate_15000ul_Vb'<br>[manufacturer website](https://www.celltreat.com/product/229562) <br>  are treated | ![](img/celltreat/CellTreat_12_troughplate_15000ul_Vb.jpg) | `CellTreat_12_troughplate_15000ul_Vb`  |
| 229123, 229124<br>[manufacturer website](https://www.celltreat.com/product/229123) | ![](img/celltreat/CellTreat_24_wellplate_3300ul_Fb.jpg) | `CellTreat_24_wellplate_3300ul_Fb`  |


## Tubes

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 229414 (sterile) <br>[manufacturer website](https://www.celltreat.com/product/229414/) <br>- bottom_type=TubeBottomType.V | ![](img/celltreat/celltreat_15000ul_centrifuge_tube_Vb.webp) | `celltreat_15000ul_centrifuge_tube_Vb` |



# Opentrons

Company page: [Opentrons Wikipedia](https://en.wikipedia.org/wiki/Opentrons)

> Opentrons Labworks, Inc. (or Opentrons) is a biotechnology company that manufactures liquid handling robots that use open-source software, which at one point used open-source hardware but no longer does.

We support Opentrons tip racks and tube racks in PLR. See the definitions below.

Unfortunately, most of the other labware (plates) is missing information that is needed in PLR to get accurate and autonomous systems to work. Please refer to the other pages in this guide for labware made by other manufacturers.

## Tip racks

- `eppendorf_96_tiprack_1000ul_eptips`
- `tipone_96_tiprack_200ul`
- `opentrons_96_tiprack_300ul`
- `opentrons_96_tiprack_10ul`
- `opentrons_96_filtertiprack_10ul`
- `geb_96_tiprack_10ul`
- `opentrons_96_filtertiprack_200ul`
- `eppendorf_96_tiprack_10ul_eptips`
- `opentrons_96_tiprack_1000ul`
- `opentrons_96_tiprack_20ul`
- `opentrons_96_filtertiprack_1000ul`
- `opentrons_96_filtertiprack_20ul`
- `geb_96_tiprack_1000ul`


## Tube Racks

"Aluminum blocks" are also included in this category.

- `opentrons_10_tuberack_falcon_4x50ml_6x15ml_conical`
- `opentrons_10_tuberack_nest_4x50ml_6x15ml_conical`
- `opentrons_15_tuberack_falcon_15ml_conical`
- `opentrons_15_tuberack_nest_15ml_conical`
- `opentrons_24_tuberack_eppendorf_1_5ml_safelock_snapcap`
- `opentrons_24_tuberack_eppendorf_2ml_safelock_snapcap`
- `opentrons_24_tuberack_generic_2ml_screwcap`
- `opentrons_24_tuberack_nest_0_5ml_screwcap`
- `opentrons_24_tuberack_nest_1_5ml_screwcap`
- `opentrons_24_tuberack_nest_1_5ml_snapcap`

| Description | Image | PLR definition |
|-|-|-|
| 'opentrons_24_tuberack_generic_1point5ml_snapcap_short'<br>Part no.: 3405002<br>[manufacturer website](https://www.thingiverse.com/thing:3405002) | ![](img/opentrons/ot2-1.5mL-tube-rack-24w.png) | `opentrons_24_tuberack_generic_1point5ml_snapcap_short` |

- `opentrons_24_tuberack_nest_2ml_screwcap`
- `opentrons_24_tuberack_nest_2ml_snapcap`
- `opentrons_6_tuberack_falcon_50ml_conical`
- `opentrons_6_tuberack_nest_50ml_conical`
- `opentrons_24_aluminumblock_generic_2ml_screwcap`
- `opentrons_24_aluminumblock_nest_0_5ml_screwcap`
- `opentrons_24_aluminumblock_nest_1_5ml_screwcap`
- `opentrons_24_aluminumblock_nest_1_5ml_snapcap`
- `opentrons_24_aluminumblock_nest_2ml_screwcap`
- `opentrons_24_aluminumblock_nest_2ml_snapcap`
- `opentrons_96_aluminumblock_biorad_wellplate_200ul`
- `opentrons_96_aluminumblock_generic_pcr_strip_200ul`
- `opentrons_96_aluminumblock_nest_wellplate_100ul`
- `opentrons_96_well_aluminum_block`


## Plate Adapters

- `opentrons_96_deep_well_temp_mod_adapter`



# Hamilton STAR "ML_STAR"

Company history: [Hamilton Robotics history](https://www.hamiltoncompany.com/history)

> Hamilton Robotics provides automated liquid handling workstations for the scientific community. Our portfolio includes three liquid handling platforms, small devices, consumables, and OEM solutions.

## Carriers

### Tip carriers

| Description | Image | PLR definition |
| - | - | - |
| 'TIP_CAR_480_A00'<br>Part no.: 182085<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/182085) <br>Carrier for 5x 96 tip (10μl, 50μl, 300μl, 1000μl) racks or 5x 24 tip (5ml) racks (6T) | ![](img/hamilton/TIP_CAR_480_A00_182085.jpg) | `TIP_CAR_480_A00` |
| 'TIP_CAR_288_C00'<br>Part no.: 182060<br>[manufacturer website](https://www.hamiltoncompany.com/other-robotics/182060) <br>Carrier for 3x 96 tip (10μl, 50μl, 300μl, 1000μl) racks or 3x 24 tip (5ml) racks (4T) | ![](img/hamilton/TIP_CAR_288_C00.jpg.avif) | `TIP_CAR_288_C00` |

### Plate carriers

| Description | Image | PLR definition |
| - | - | - |
| 'PLT_CAR_L5AC_A00'<br>Part no.: 182090<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/182090) <br>Carrier for 5x 96 Deep Well Plates or for 5x 384 tip racks (e.g.384HEAD_384TIPS_50μl) (6T) | ![](img/hamilton/PLT_CAR_L5AC_A00_182090.jpg) | `PLT_CAR_L5AC_A00` |
| 'PLT_CAR_L5MD_A00'<br>Part no.: 182365/02<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/182365) <br>Carries five ANSI/SLAS footprint MTPs in landscape orientation. Occupies six tracks.| ![](img/hamilton/182365-Plate-Carrier.webp) | `PLT_CAR_L5MD_A00` |
| 'PLT_CAR_P3AC'<br>Part no.: 182365/03<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/182365) <br>Hamilton Deepwell Plate Carrier for 3 Plates (Portrait, 6 tracks wide)| ![](img/hamilton/PLT_CAR_P3AC.jpg) | `PLT_CAR_P3AC` |
| 'PLT_CAR_L5_DWP'<br>Part no.:  93522-01/03<br>manufacturer website? <br>Hamilton Plate Carrier for 5 Plates (Landscape, 6 tracks wide). Plastic tabs. | ![](img/hamilton/PLT_CAR_L5_DWP.jpg) | `PLT_CAR_L5_DWP` |

### MFX carriers

See [MFX Carrier documentation](/resources/carrier/mfx-carrier/mfx_carrier).

| Description | Image | PLR definition |
| - | - | - |
| 'hamilton_mfx_carrier_L5_base'<br>Part no.: 188039<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/188039) <br>Labware carrier base for up to 5 Multiflex Modules <br>Occupies 6 tracks (6T). | ![](img/hamilton/hamilton_mfx_carrier_L5_base.jpg) | `hamilton_mfx_carrier_L5_base` |
| 'MFX_CAR_L4_SHAKER'<br>Part no.: 187001<br>[secondary supplier website](https://www.testmart.com/estore/unit.cfm/PIPPET/HAMROB/187001/automated_pippetting_devices_and_systems/8.html) (cannot find information on Hamilton website)<br>Sometimes referred to as "PLT_CAR_L4_SHAKER" by Hamilton. <br>Template carrier with 4 positions for Hamilton Heater Shaker. <br>Occupies 7 tracks (7T). Can be screwed onto the deck. | ![](img/hamilton/MFX_CAR_L4_SHAKER_187001.png) | `MFX_CAR_L4_SHAKER` |

### MFX modules

See [MFX Carrier documentation](/resources/carrier/mfx-carrier/mfx_carrier).


| Description | Image | PLR definition |
| - | - | - |
| 'MFX_TIP_module'<br>Part no.: 188160 or 188040<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/188040) <br>Module to position a high-, standard-, low volume or 5ml tip rack (but not a 384 tip rack) | ![](img/hamilton/MFX_TIP_module_188040.jpg) | `MFX_TIP_module` |
| 'hamilton_mfx_plateholder_DWP_flat'<br>Part no.: 188229<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/188229) (<-non-functional link?) <br>MFX DWP module rack-based | ![](img/hamilton/MFX_DWP_RB_module_188229_.jpg) | `hamilton_mfx_plateholder_DWP_flat` |
| 'MFX_DWP_module_flat'<br>Part no.: 6601988-01<br>manufacturer website unknown | ![](img/hamilton/MFX_DWP_module_flat.jpg) | `MFX_DWP_module_flat` |
| 'Hamilton_mfx_plateholder_DWP_metal_tapped'<br>Part no.: 188042 <br>[manufacturer website](https://www.hamiltoncompany.com/other-robotics/188042)<br>Carries a single ANSI/SLAS footprint DWP, a Matrix or Micronics tube rack, or a Nunc reagent reservoir. Occupies one MFX site.| ![](img/hamilton/hamilton_MFX_plateholder_DWP_metal_tapped.png) | `Hamilton_mfx_plateholder_DWP_metal_tapped` |

### Tube carriers

Sometimes called "sample carriers" in Hamilton jargon.

| Description | Image | PLR definition |
| - | - | - |
| 'Tube_CAR_24_A00'<br>Part no.: 173400<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/173400) <br>Carries 24 "sample" tubes with 14.5–18 mm outer diameter, 60–120 mm high. Occupies one track. | ![](img/hamilton/Tube_CAR_24_A00.png) | `Tube_CAR_24_A00` |
| 'hamilton_tube_carrier_32_a00_insert_eppendorf_1_5mL'<br>Part no.: 173410<br>[manufacturer website](https://www.hamiltoncompany.com/other-robotics/173410) <br>Carries 32 `Eppendorf_DNA_LoBind_1_5ml_Vb` or `Eppendorf_Protein_LoBind_1_5ml_Vb` tubes. Occupies one track. | ![](img/hamilton/Tube_CAR_32_A00.png.avif) | `hamilton_tube_carrier_32_a00_insert_eppendorf_1_5mL` |
| 'hamilton_tube_carrier_12_b00'<br>Part no.: 182045<br>[manufacturer website](https://www.hamiltoncompany.com/other-robotics/50-ml-falcon-tube-carrier) <br>Carries 12 "sample" tubes with 30 mm outer diameter, 115 mm high. Occupies two tracks. | ![](img/hamilton/hamilton_tube_carrier_12_b00.jpg) | `hamilton_tube_carrier_12_b00` |

### Trough carriers

Sometimes called "reagent carriers" in Hamilton jargon.

| Description | Image | PLR definition |
| - | - | - |
| 'Trough_CAR_4R200_A00'<br>Part no.: 185436 (same as 96890-01?)<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/96890-01) <br>Trough carrier for 4x 200ml troughs. 2 tracks(T) wide. | ![](img/hamilton/Trough_CAR_4R200_A00.png) | `Trough_CAR_4R200_A00` |
| 'Trough_CAR_5R60_A00'<br>Part no.: 53646-01<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/reagent-reservoir-carrier-5-x-60-ml-2) <br>Trough carrier for 5x 60ml troughs. 1 track(T) wide. | ![](img/hamilton/Trough_CAR_5R60_A00.jpg) | `Trough_CAR_5R60_A00` |

## Plate Adapters

| Description | Image | PLR definition |
| - | - | - |
| 'Hamilton_96_adapter_188182'<br>Part no.: 188182<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/188182) (<-non-functional link?) <br>Adapter for 96 well PCR plate, plunged. Does not have an ANSI/SLAS footprint -> requires assignment with specified location. | ![](img/hamilton/hamilton_96_adapter_188182.png) | `Hamilton_96_adapter_188182` |

## Consumables

### TipRacks

| Description | Image | PLR definition |
| - | - | - |
| Hamilton 96 tip rack 10uL.<br>Hamilton name: `LT`.<br>Part number 235900 (non-sterile), 235935 (sterile).<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/10-μl-co-re-ii-tips) | ![](img/hamilton/tip_racks/hamilton_96_tiprack_10uL.jpg.avif) | `hamilton_96_tiprack_10uL` |
| Hamilton 96 tip rack 10uL filter.<br>Hamilton name: `LTF`.<br>Part number: 235936 (sterile), 235901 (non-sterile).<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/10-μl-co-re-ii-tips) | ![](img/hamilton/tip_racks/hamilton_96_tiprack_10uL_filter.jpg.avif) | `hamilton_96_tiprack_10uL_filter` |
| Hamilton 96 tip rack 50uL.<br>Hamilton name: `TIP_50ul`<br>Part number: 235966 (non-sterile), 235978 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/50-μl-co-re-ii-tips)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_50uL.jpg.avif) | `hamilton_96_tiprack_50uL` |
| Hamilton 96 tip rack 50uL filter.<br>Hamilton name: `TIP_50ul_w_filter`<br>Part number: 235948 (non-sterile), 235979 (sterile), 235829 (clear, non-sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/50-μl-co-re-ii-tips) | ![](img/hamilton/tip_racks/hamilton_96_tiprack_50uL_filter.jpg.avif) | `hamilton_96_tiprack_50uL_filter` |
| Hamilton 96 nested tip rack (NTR) 50uL.<br>Hamilton name: ?<br>Part number: 235947 (non-sterile), 235964 (clear, non-sterile), 235987 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/50-μl-co-re-ii-tips) | ![](img/hamilton/tip_racks/hamilton_96_tiprack_50uL_NTR.jpg.avif) | `hamilton_96_tiprack_50uL_NTR` |
| Hamilton 96 tip rack 300uL.<br>Hamilton name: `ST`<br>Part number: 235834 (clear, non-sterile), 235902 (non-sterile), 235937 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/300-μl-co-re-ii-tips)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_300uL.jpg.avif) | `hamilton_96_tiprack_300uL` |
| Hamilton 96 tip rack 300uL filter.<br>Hamilton name: `STF`<br>Part number: 235830 (clear), 235903 (non-sterile), 235938 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/300-μl-co-re-ii-tips)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_300uL.jpg.avif) | `hamilton_96_tiprack_300uL_filter` |
| Hamilton 96 tip rack 300uL filter slim.<br>Hamilton name: `STF_Slim`<br>Part number: 235646<br>[Hamilton website](https://www.hamiltoncompany.com/consumables/300-µl-slim-conductive-tips?part-number=235646)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_300uL_filter_slim.jpg.avif) | `hamilton_96_tiprack_300uL_filter_slim` |
| Hamilton 96 tip rack 300uL filter ultra wide bore.<br>Hamilton name: `STF_ULTRAWIDE`<br>Part number: 235449<br>[Hamilton website](https://www.hamiltoncompany.com/consumables/300-µl-co-re-ii-wide-bore-conductive-tips?part-number=235449)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_300uL_filter_wide.avif) | `hamilton_96_tiprack_300uL_filter_ultrawide` |
| Hamilton 96 tip rack 1000uL.<br>Hamilton name: `HT`<br>Part number: 235822 (clear, non-sterile), 235904 (non-sterile), 235939 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/1000-µl-co-re-ii-disposable-tips)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_1000uL.jpg.avif) | `hamilton_96_tiprack_1000uL` |
| Hamilton 96 tip rack 1000uL filter.<br>Hamilton name: `HTF`<br>Part number: 235820 (clear), 235905 (non-sterile), 235940 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/1000-µl-co-re-ii-disposable-tips)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_1000uL.jpg.avif) | `hamilton_96_tiprack_1000uL_filter` |
| Hamilton 96 tip rack 1000uL filter wide (1.2mm orifice Size).<br>Hamilton name: `HTF_WIDE`<br>Part number: 235678 (non-sterile), 235677 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables/1000-µl-co-re-ii-wide-bore-conductive-tips?part-number=235678)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_1000uL_filter_wide.jpg.avif) | `hamilton_96_tiprack_1000uL_filter_wide` |
| Hamilton 96 tip rack 1000uL filter ultra wide (3.2mm orifice Size).<br>Hamilton name: `HTF_ULTRAWIDE`<br>Part number: 235541 (non-sterile), 235842 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables/1000-µl-co-re-ii-wide-bore-conductive-tips?part-number=235541)| ![](img/hamilton/tip_racks/hamilton_96_tiprack_1000uL_filter_ultrawide.jpg.avif) | `hamilton_96_tiprack_1000uL_filter_ultrawide` |
| Hamilton 24 tip rack 4000uL filter.<br>Hamilton name: `FourmlTF`<br>Part number: 184021 (non-sterile), 184023 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/4000-μl-5000-μl-co-re-tips)| ![](img/hamilton/tip_racks/hamilton_24_tiprack_4000uL_filter.jpg.avif) | `hamilton_24_tiprack_4000uL_filter` |
| Hamilton 24 tip rack 5000uL.<br>Hamilton name: `FivemlT`<br>Part number: 184020 (non-sterile), 184022 (sterile)<br>[Hamilton website](https://www.hamiltoncompany.com/consumables-labware-accessories/co-re-and-co-re-ii-tips/4000-μl-5000-μl-co-re-tips)| ![](img/hamilton/tip_racks/hamilton_24_tiprack_5000uL.jpg.avif) | `hamilton_24_tiprack_5000uL` |

### Troughs

| Description | Image | PLR definition |
| - | - | - |
| 'Hamilton_1_trough_60ml_Vb'<br>Part no.: 56694-01 (natural/white), 56694-02 (black), 56694-03 (black, bulk)<br>[manufacturer website](https://www.hamiltoncompany.com/consumables/60-ml-reagent-reservoirs) <br>Trough 60ml, w lid, self-standing. Barcode-compliant. <br>Compatible with Trough_CAR_5R60_A00 (53646-01). | ![](img/hamilton/hamilton_1_trough_60mL_Vb_56694-01.png) | `hamilton_1_trough_60ml_Vb` |
| 'hamilton_1_trough_120ml_Vb'<br>Part no.: 194052 (white/translucent)<br>[manufacturer website](https://www.hamiltoncompany.com/consumables/120-ml-reagent-reservoir-self-standing-with-barcode-label?srsltid=AfmBOoobNQhgF9KPbwURilJLIDO_pJhS3AnUXMRQ5QATOYMemUnU-aUU) <br>Trough 120mL, without lid, self-standing, transparent. <br>Compatible with Trough_CAR_3R120 (194058). | ![](img/hamilton/hamilton_1_trough_120mL_Vb.png) | `hamilton_1_trough_120mL_Vb` |
| 'Hamilton_1_trough_200ml_Vb'<br>Part no.: 56695-01 (white/translucent), 56695-02 (black/conductive)<br>[manufacturer website](https://www.hamiltoncompany.com/automated-liquid-handling/other-robotics/56695-02) <br>Trough 200ml, w lid, self-standing, Black. <br>Compatible with Trough_CAR_4R200_A00 (185436). | ![](img/hamilton/hamilton_1_trough_200ml_Vb.jpg) | `hamilton_1_trough_200ml_Vb` |



# Wuxi Nest

Wuxi NEST Biotechnology Co., Ltd. a leading life science plastic consumables manufactory, who is integrated with R&D production and sales, was established in 2009, located in Wuxi, Jiangsu, China. Our products have been exported to North America, Europe, Japan, Korea, India and other countries, enjoys an excellent reputation nationwide and abroad. Customers are almost all over the world.

## Plates

| Description | Image | PLR definition |
|-|-|-|
| 'nest_1_troughplate_195000uL_Vb'<br>Part no.: 360101<br>[manufacturer website](https://www.nest-biotech.com/reagent-reserviors/59178416.html)<br>- Material: polypropylene | ![](img/nest/nest_1_troughplate_195000uL_Vb.webp) | `nest_1_troughplate_195000uL_Vb` |
| 'nest_1_troughplate_185000uL_Vb'<br>Part no.: 360101<br>[manufacturer website](https://www.nest-biotech.com/reagent-reserviors/59178415.html)<br>- Material: polypropylene | ![](img/nest/nest_1_troughplate_185000uL_Vb.webp) | `nest_1_troughplate_185000uL_Vb` |
| 'nest_8_troughplate_22000uL_Vb'<br>Part no.: 360101<br>[manufacturer website](https://www.nestscientificusa.com/product/detail/513006470820794368)<br>- Material: polypropylene | ![](img/nest/nest_8_troughplate_22000uL_Vb.jpg) | `nest_8_troughplate_22000uL_Vb` |
| 'nest_12_troughplate_15000uL_Vb'<br>Part no.: 360102<br>[manufacturer website](https://www.nestscientificusa.com/product/detail/513006470820794368)<br>- Material: polypropylene | ![](img/nest/nest_12_troughplate_15000uL_Vb.jpg) | `nest_12_troughplate_15000uL_Vb` |
| 'NEST_96_wellplate_2200uL_Ub'<br>Part no.: 503062<br>[manufacturer website](https://www.nest-biotech.com/deep-well-plates/59253727.html)<br>- Material: polypropylene | ![](img/nest/NEST_96_wellplate_2200uL_Ub.png) | `NEST_96_wellplate_2200uL_Ub` |


# Alpaqua Engineering, LLC

Company page: [Alpaqua Engineering, LLC](https://www.alpaqua.com/about-us/)

> Alpaqua Engineering, LLC, founded in 2006, is a global provider of tools for accelerating genomic applications such as NGS, nucleic acid extraction and clean up, target capture, and molecular diagnostics.
Our products include a line of innovative, high performance magnet plates built with proprietary magnet architecture and spring cushion technology.  Also available are aluminum tube blocks to help maintain temperature control, SBS /ANSI standard tube racks and the Alpillo® Plate Cushion, which enables pipetting from the bottom of a well without tip occlusion​.

## Labware

| Description | Image | PLR definition |
|-|-|-|
| 'Alpaqua_96_magnum_flx'<br>Part no.: A000400<br>[manufacturer website](https://www.alpaqua.com/product/magnum-flx/) | ![](img/alpaqua/Alpaqua_96_magnum_flx.jpg) | `Alpaqua_96_magnum_flx` |



# Corning Inc.

Wikipedia page: [Corning](https://en.wikipedia.org/wiki/Corning_Inc.)

> Corning Incorporated is an American multinational technology company that specializes in specialty glass, ceramics, and related materials and technologies including advanced optics, primarily for industrial and scientific applications. The company was named Corning Glass Works until 1989. Corning divested its consumer product lines (including CorningWare and Visions Pyroceram-based cookware, Corelle Vitrelle tableware, and Pyrex glass bakeware) in 1998 by selling the Corning Consumer Products Company subsidiary (later Corelle Brands, now known as Instant Brands) to Borden.

As of 2014, Corning had five major business sectors: display technologies, environmental technologies, life sciences, optical communications, and specialty materials.

<hr>

```
Corning Inc.
├── Life Sciences
│   ├── Costar
│   ├── Axygen
│   ├── Falcon
│   ├── Pyrex
│   ├── Discovery Labware
│   ├── Gosselin
│   ├── Mediatech (Cellgro)
│   ├── Gentest
│   └── Matrigel & BioCoat
├── Display Technologies
│   └── Gorilla Glass
├── Optical Communications
│   └── Optical Fiber
├── Environmental Technologies
│   └── Ceramic Substrates & Filters
└── Specialty Materials
    └── Advanced Glass
```

<hr>

## Corning - Axygen

Company page: [Corning - Axygen® Brand Products](https://www.corning.com/emea/en/products/life-sciences/resources/brands/axygen-brand-products.html)

> Corning acquired Axygen BioScience, Inc. and its subsidiaries in 2009. This acquisition included Axygen's broad portfolio of high-quality plastic consumables, liquid handling products, and bench-top laboratory equipment, which complemented and expanded Corning's offerings in the life sciences segment​.

(axygen-plates)=
### Plates

| Description | Image | PLR definition |
|-|-|-|
| 'Cor_Axy_24_wellplate_10mL_Vb'<br>Part no.: P-DW-10ML-24-C-S<br>[manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Genomics-&-Molecular-Biology/Automation-Consumables/Deep-Well-Plate/Axygen%C2%AE-Deep-Well-and-Assay-Plates/p/P-DW-10ML-24-C-S) | ![](img/corning_axygen/Cor_Axy_24_wellplate_10mL_Vb.jpg) | `Cor_Axy_24_wellplate_10mL_Vb` |
| 'Cor_Axy_96_wellplate_500uL_Ub'<br>Part no.: P-96-450V-C-S ("-S" indicates sterile labware)<br>[manufacturer website](https://ecatalog.corning.com/life-sciences/b2c/US/en/Genomics-&-Molecular-Biology/Automation-Consumables/Deep-Well-Plate/Axygen%C2%AE-Deep-Well-and-Assay-Plates/p/P-96-450V-C-S) | ![](img/corning_axygen/Cor_Axy_96_wellplate_500uL_Ub.png) | `Cor_Axy_96_wellplate_500uL_Ub` |

## Corning - Costar

(costar-plates)=
### Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'Cos_6_wellplate_16800ul_Fb'<br>Part no.s: <br><ul> <li>[3335 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Costar%C2%AE-Multiple-Well-Cell-Culture-Plates/p/3335)</li> <li>[3506 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Costar%C2%AE-Multiple-Well-Cell-Culture-Plates/p/3506)</li> <li>[3516 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Costar%C2%AE-Multiple-Well-Cell-Culture-Plates/p/3516)</li> <li>[3471 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Costar%C2%AE-Multiple-Well-Cell-Culture-Plates/p/3471)</li> </ul> <br>- Material: ? <br>- Cleanliness: 3516: sterilized by gamma irradiation <br>- Nonreversible lids with condensation rings to reduce contamination <br>- Treated for optimal cell attachment <br>- Cell growth area: 9.5 cm² (approx.) <br>- Total volume: 16.8 mL | ![](img/corning_costar/Cos_6_wellplate_16800ul_Fb.jpg) | `Cos_6_wellplate_16800ul_Fb` |
| 'Cor_12_wellplate_6900ul_Fb' <br>Part no.s: <br><ul> <li>[3336 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3336)</li> <li>[3512 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3512)</li> <li>[3513 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3513)</li> </ul> <br>- Total volume: 6.9 mL | ![](img/corning_costar/Cor_12_wellplate_6900ul_Fb.jpg) | `Cor_12_wellplate_6900ul_Fb` |
| 'Cor_24_wellplate_3470ul_Fb' <br>Part no.s: <br><ul> <li>[3337 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3337)</li> <li>[3524 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3524)</li> <li>[3526 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3526)</li> <li>[3527 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3527)</li> <li>[3473 manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3473)</li> </ul> <br>- Total volume: 3.47 mL | ![](img/corning_costar/Cor_24_wellplate_3470ul_Fb.jpg) | `Cor_24_wellplate_3470ul_Fb` |
| 'Cor_48_wellplate_1620ul_Fb' <br>Part no.: 3548<br>[manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon%C2%AE-96-well-Polystyrene-Microplates/p/3548) <br><br>- Material: TC-treated polystyrene <br>- Cleanliness: sterile <br>- Total volume: 1.62 mL | ![](img/corning_costar/Cor_48_wellplate_1620ul_Fb.jpg) | `Cor_48_wellplate_1620ul_Fb` |
| 'Cos_96_wellplate_2mL_Vb'<br>Part no.: 3516<br>[manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/Microplates/Assay-Microplates/96-Well-Microplates/Costar%C2%AE-Multiple-Well-Cell-Culture-Plates/p/3516) <br><br>- Material: Polypropylene <br>- Resistant to many common organic solvents (e.g., DMSO, ethanol, methanol) <br>- 3960: Sterile and DNase- and RNase-free <br>- Total volume: 2 mL <br>- Features uniform skirt heights for greater robotic gripping surface| ![](img/corning_costar/Cos_96_wellplate_2mL_Vb.jpg) | `Cos_96_wellplate_2mL_Vb` |
'Cor_96_wellplate_360ul_Fb' <br>Part no.: 353376<br>[manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/NL/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon®-96-well-Polystyrene-Microplates/p/353376) <br><br>- Material: TC-treated polystyrene <br> - Cleanliness: sterile <br>- Total volume:  392 uL <br>- Working volume: 25-340 uL | ![](img/corning_costar/Cor_96_wellplate_360ul_Fb.jpg) | `Cor_96_wellplate_360ul_Fb` |

## Falcon

(falcon-plates)=
### Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| Falcon_96_wellplate_Fl [manufacturer website](https://www.fishersci.com/shop/products/falcon-96-well-cell-culture-treated-flat-bottom-microplate/087722C) | ![](img/falcon/Falcon_96_wellplate_Fl.webp) | `Falcon_96_wellplate_Fl`
| Falcon_96_wellplate_Rb [manufacturer website](https://ecatalog.corning.com/life-sciences/b2c/US/en/Microplates/Assay-Microplates/96-Well-Microplates/Falcon®-96-well-Polystyrene-Microplates/p/353077) | ![](img/falcon/Falcon_96_wellplate_Rb.jpg) | `Falcon_96_wellplate_Rb`
| Falcon_96_wellplate_Fl_Black [manufacturer website](https://www.fishersci.com/shop/products/falcon-96-well-imaging-plate-lid/08772225) | ![](img/falcon/Falcon_96_wellplate_Fl_Black.jpg.webp) | `Falcon_96_wellplate_Fl_Black`

### Tubes

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 50mL Falcon Tube [manufacturer website](https://www.fishersci.com/shop/products/falcon-50ml-conical-centrifuge-tubes-2/1495949A) | ![](img/falcon/falcon-tube-50mL.webp) | `falcon_tube_50mL`
| 15mL Falcon Tube [manufacturer website](https://www.fishersci.com/shop/products/falcon-15ml-conical-centrifuge-tubes-5/p-193301) | ![](img/falcon/falcon-tube-15mL.webp) | `falcon_tube_15mL`
| Falcon_tube_14mL_Rb <br> Corning cat. no.: 352059 <br>[manufacturer website](https://ecatalog.corning.com/life-sciences/b2b/UK/en/General-Labware/Tubes/Tubes,-Round-Bottom/Falcon%C2%AE-Round-Bottom-High-clarity-Polypropylene-Tube/p/352059) | ![](img/falcon/Falcon_tube_14mL_Rb.jpg) | `Falcon_tube_14mL_Rb`



# IMCS

INTEGRATED MICRO-CHROMATOGRAPHY SYSTEMS, INC. (IMCS)

[https://imcstips.com](https://imcstips.com)

Automated high-throughput protein purification

## TipRacks

| Description | Image | PLR definition |
| - | - | - |
|IMCS tips for automated protein purification. 300uL. Part numbers:<ul> <li>04T-H8R80A-1-5-96</li> <li>04T-H8R80A-1-10-96</li> <li>04T-H8R80P-1-5-96</li> <li>04T-H8R80P-1-10-96</li> <li>04T-H8R72-1-2-96</li> <li>04T-H8R72-1-5-96</li> <li>04T-H8R72-1-10-96</li> <li>04T-H8R72Q-1-10-96</li> <li>04T-H8R85P-1-5-96</li> <li>04T-H8R85P-1-10-96</li> <li>04T-H8R88F-1-2-96</li> <li>04T-H8R88F-1-5-96</li> <li>04T-H8R88F-1-10-96</li> <li>04T-H8R89-1-10-96</li> <li>04T-H8D20F-1A-3-96</li> <li>04T-H8CD20F-1A-3-96</li> <li>04T-H8R68-1-5-96</li> <li>04T-H8R73-1-10-96</li> <li>04T-H8R05-1-2-96</li> <li>04T-H8R05-1-5-96</li> <li>04T-H8R41-1-2-96</li> <li>04T-H8R53-1-2-96</li> <li>04T-H8R52-1-2-96</li> <li>04T-H8R52-1-5-96</li> <li>04T-H8R30-1-2-96</li> <li>04T-H8R30-1-5-96</li> <li>04T-H8R03R-1-5-96</li> <li>04T-H8R02R-1-2-96</li> <li>04T-H8R02R-1-5-96</li> <li>04T-I3R73-1-10-</li> </uL> <br>[OEM website](https://imcstips.com/) | picture not available | `imcs_96_tiprack_300uL_filter` |



# Cellvis

[Company Page](https://www.cellvis.com)

## Plates

| Description | Image | PLR definition |
|-|-|-|
| 'CellVis_24_wellplate_3600uL_Fb'<br>Part no.: P24-1.5P<br>[manufacturer website](https://www.cellvis.com/_24-well-plate-with--number-1.5-glass-like-polymer-coverslip-bottom-tissue-culture-treated-for-better-cell-attachment-than-cover-glass_/product_detail.php?product_id=65) | ![](img/cellvis/CellVis_24_wellplate_3600uL_Fb.jpg) | `CellVis_24_wellplate_3600uL_Fb` |
| 'CellVis_96_wellplate_350uL_Fb'<br>Part no.: P96-1.5H-N<br>[manufacturer website](https://www.cellvis.com/_96-well-glass-bottom-plate-with-high-performance-number-1.5-cover-glass_/product_detail.php?product_id=50) | ![](img/cellvis/CellVis_96_wellplate_350uL_Fb.jpg) | `CellVis_96_wellplate_350uL_Fb` |



# Thermo Fisher Scientific Inc.

Company page: [Thermo Fisher Scientific Inc. Wikipedia](https://en.wikipedia.org/wiki/Thermo_Fisher_Scientific)

> Thermo Fisher Scientific Inc. is an American supplier of analytical instruments, life sciences solutions, specialty diagnostics, laboratory, pharmaceutical and biotechnology services. Based in Waltham, Massachusetts, Thermo Fisher was formed through the **merger of Thermo Electron and Fisher Scientific in 2006**. Thermo Fisher Scientific has acquired other reagent, consumable, instrumentation, and service providers, including Life Technologies Corporation (2013), Alfa Aesar (2015), Affymetrix (2016), FEI Company (2016), BD Advanced Bioprocessing (2018),and PPD (2021).

A basic structure of the companiy, [its brands](https://www.thermofisher.com/uk/en/home/brands.html) and product lines looks like this:

```
Thermo Fisher Scientific Inc. (TFS, aka "Thermo")
├── Applied Biosystems (AB; brand)
│   └── MicroAmp
│      └── EnduraPlate
├── Fisher Scientific (FS; brand)
├── Invitrogen (INV; brand)
├── Ion Torrent (IT; brand)
├── Gibco (GIB; brand)
├── Thermo Scientific (TS; brand)
│   ├── Nalgene
│   ├── Nunc
│   └── Pierce
├── Unity Lab Services (brand, services)
├── Patheon (brand, services)
└── PPD (brand, services)
```

## Plates

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'Thermo_TS_96_wellplate_1200ul_Rb'<br>Part no.: AB-1127 or 10243223<br>[manufacturer website](https://www.fishersci.co.uk/shop/products/product/10243223) <br><br>- Material: Polypropylene (AB-1068, polystyrene) <br> | ![](img/thermo_fisher/Thermo_TS_96_wellplate_1200ul_Rb.webp) | `Thermo_TS_96_wellplate_1200ul_Rb` |
| 'Thermo_TS_Nunc_96_wellplate_300uL_Fb'<br>Part no.: 165305<br>[manufacturer website](https://www.fishersci.com/shop/products/nunc-microwell-96-well-cell-culture-treated-flat-bottom-microplate/1256670#)  <br> | ![](img/thermo_fisher/Thermo_TS_Nunc_96_wellplate_300uL_Fb.webp) | `Thermo_TS_Nunc_96_wellplate_300uL_Fb` |
| 'Thermo_AB_96_wellplate_300ul_Vb_EnduraPlate'<br>Part no.: 4483354 (TFS) or 15273005 (FS) (= with barcode)<br>Part no.: 16698853 (FS) (= **without** barcode)<br>[manufacturer website](https://www.thermofisher.com/order/catalog/product/4483354) <br><br>- Material: Polycarbonate, Polypropylene<br>- plate_type: semi-skirted<br>- product line: "MicroAmp"<br>- (sub)product line: "EnduraPlate" | ![](img/thermo_fisher/Thermo_AB_96_wellplate_300ul_Vb_EnduraPlate.png) | `Thermo_AB_96_wellplate_300ul_Vb_EnduraPlate` |
| 'Thermo_Nunc_96_well_plate_1300uL_Rb'<br>Part no.: 26025X | ![](img/thermo_fisher/Thermo_Nunc_96_well_plate_1300uL_Rb.jpg) | `Thermo_Nunc_96_well_plate_1300uL_Rb` |
| 'thermo_AB_96_wellplate_300ul_Vb_MicroAmp'<br>Part no.: N8010560/4316813 (w/o barcode)<br>Part no.: 4306737/4326659 (with barcode) | ![](img/thermo_fisher/thermo_AB_96_wellplate_300ul_Vb_MicroAmp.webp) | `thermo_AB_96_wellplate_300ul_Vb_MicroAmp` |
| 'thermo_AB_384_wellplate_40uL_Vb_MicroAmp'<br>Part no.: 4309849, 4326270, 4343814 (with barcode), 4343370 (w/o barcode). | ![](img/thermo_fisher/thermo_AB_384_wellplate_40uL_Vb_MicroAmp.jpg) | `thermo_AB_384_wellplate_40uL_Vb_MicroAmp` |
## Troughs

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'thermo_nunc_1_troughplate_90000uL_Fb_omnitray'<br>Part no.: 165218, 140156, 242811, 264728 | ![](img/thermo_fisher/thermo_nunc_1_troughplate_90000uL_Fb_omnitray.jpg.avif) | `thermo_nunc_1_troughplate_90000uL_Fb_omnitray` |
| 'ThermoFisherMatrixTrough8094'<br>Part no.: 8094<br>[manufacturer website](https://www.thermofisher.com/order/catalog/product/8094) | ![](img/thermo_fisher/ThermoFisherMatrixTrough8094.jpg.avif) | `ThermoFisherMatrixTrough8094` |



# Sergi Lab Supplies

Company page: [Sergi Lab Supplies](https://sergilabsupplies.com/?srsltid=AfmBOoqk2e3QkpWxvWEtSXS4ySJVoly7hvdiji_ehH5-s6tM3gi67SMu)

## Plate Adaptors

| Description               | Image              | PLR definition |
|--------------------|--------------------|--------------------|
| 'SergiLabSupplies_96_MagneticRack_250ul_Vb'<br>Part no.: 1047<br>[manufacturer website](https://sergilabsupplies.com/collections/magnetic-racks/products/96-wells-magnetic-rack-for-dna-rna-and-other-molecules-purification)<br>A separator for purifying DNA, RNA or other biomolecules with magnetic beads | ![](img/sergi/SergiLabSupplies_96_MagneticRack_250ul_Vb.jpg) | `SergiLabSupplies_96_MagneticRack_250ul_Vb` |


# Resources Introduction

This document introduces PyLabRobot Resources (labware and deck definitions) and general subclasses. You can find more information on creating custom resources in the {doc}`custom-resources` section.

In PyLabRobot, a {class}`pylabrobot.resources.resource.Resource` is a piece of labware or equipment used in a protocol or program, a part of a labware item (such as a Well) or a container of labware items (such as a Deck). All resources inherit from a single base class {class}`pylabrobot.resources.resource.Resource` that provides most of the functionality, such as the name, sizing, type, model, as well as methods for dealing with state. The name and sizing are required for all resources, with the name being a unique identifier for the resource and the sizing being the x, y and z-dimensions of the resource in millimeters when conceptualized as a cuboid.

While you can instantiate a `Resource` directly, several subclasses of methods exist to provide additional functionality and model specific resource attributes. For example, a {class}`pylabrobot.resources.plate.Plate` has methods for easily accessing {class}`pylabrobot.resources.well.Well`s.

The relation between resources is modelled by a tree, specifically an [_arborescence_](<https://en.wikipedia.org/wiki/Arborescence_(graph_theory)>) (a directed, rooted tree). The location of a resource in the tree is a Cartesian coordinate and always relative to the bottom front left corner of its immediate parent. The absolute location, the location of the resource wrt the root of the tree it is in, can be computed using {meth}`~pylabrobot.resources.resource.Resource.get_absolute_location`. The location wrt any resource between a given one and the root can be computed using {meth}`~pylabrobot.resources.resource.Resource.get_location_wrt`. The x-axis is left (smaller) and right (larger); the y-axis is front (small) and back (larger); the z-axis is down (smaller) and up (higher). Each resource has `children` and `parent` attributes that allow you to navigate the tree.

{class}`pylabrobot.machines.machine.Machine` is a special type of resource that represents a physical machine, such as a liquid handling robot ({class}`pylabrobot.liquid_handling.liquid_handler.LiquidHandler`) or a plate reader ({class}`pylabrobot.plate_reading.plate_reader.PlateReader`). Machines have a `backend` attribute linking to the backend that is responsible for converting PyLabRobot commands into commands that a specific machine can understand. Other than that, Machines, including {class}`pylabrobot.liquid_handling.liquid_handler.LiquidHandler`, are just like any other Resource.

## Defining a simple resource

The simplest way to define a resource is to subclass {class}`pylabrobot.resources.resource.Resource` and define the `name` and `size_x`, `size_y` and `size_z` attributes.

The size attributes are in millimeters and define the dimensions of the resource as a cuboid. This the complete outer bounding box of the resource. The `name` attribute is a unique identifier for the resource, and it can be used to reference the resource in protocols and programs.

Here's an example of a simple resource:

```python
from pylabrobot.resources import Resource
resource = Resource(name="resource", size_x=10, size_y=10, size_z=10)
```

To assign a child resource, you can use the `assign_child_resource` method:

```python
from pylabrobot.resources import Resource, Coordinate
child = Resource(name="child", size_x=5, size_y=5, size_z=5)
# assign to bottom front left corner of parent
resource.assign_child_resource(child, Coordinate(x=0, y=0, z=0))
```

## Saving and loading resources

PyLabRobot provide utilities to save and load resources and their states to and from files, as well as to serialize and deserialize resources and their states to and from Python dictionaries.

### Definitions

#### Saving to and loading from a file

Resource definitions, that includes deck definitions, can be saved to and loaded from a file using the `pylabrobot.resources.resource.Resource.save` and `pylabrobot.resources.resource.Resource.load` methods. The file format is JSON.

To save a resource to a file:

```python
resource.save("resource.json")
```

This will create a file `resource.json` with the resource definition.

```json
{
  "name": "resource",
  "type": "Resource",
  "size_x": 10,
  "size_y": 10,
  "size_z": 10,
  "location": null,
  "category": null,
  "model": null,
  "children": [],
  "parent_name": null
}
```

To load the resource from the file:

```python
resource = Resource.load_from_json_file("resource.json")
```

#### Serialization and deserialization

To simply serialize a resource to a Python dictionary:

```python
resource_dict = resource.serialize()
```

To load a resource from a Python dictionary:

```python
resource = Resource.deserialize(resource_dict)
```

### State

Each Resource is responsible for managing its own state, as deep down in the arborescence as possible (eg a Well instead of a Plate). The state of a resource is a Python dictionary that contains all the information necessary to restore the resource to a given state as far as PyLabRobot is concerned. This includes the liquids in a container, the presence of tips in a tip rack, and so on.

#### Serializing and deserializing state

The state of a single resource, that includes the volume of a container, can be serialized to and deserialized from a Python dictionary using the `pylabrobot.resources.resource.Resource.serialize_state` and `pylabrobot.resources.resource.Resource.deserialize_state` methods.

To serialize the state of a resource:

```python
from pylabrobot.resources import Container
c = Container(name="container", size_x=10, size_y=10, size_z=10)
c.serialize_state()
```

This will return a dictionary with the state of the resource:

```json
{ "liquids": [], "pending_liquids": [] }
```

To deserialize the state of a resource:

```python
c = Container(name="container", size_x=10, size_y=10, size_z=10)
c.load_state({ "liquids": [], "pending_liquids": [] })
```

This is convenient if you want to use PLR state in your own state management system, or save to a database.

Note that above, only the state of a single resource is serialized. If you want to serialize the state of a resource and all its children, you can use the {meth}`pylabrobot.resources.resource.Resource.serialize_all_state` and {meth}`pylabrobot.resources.resource.Resource.load_all_state` methods. These methods are used internally by the `save_state_to_file` and `load_state_from_file` methods.

#### Saving and loading state to and from a file

The state of a resource, that includes the volume of a container, can be saved to and loaded from a file using the `pylabrobot.resources.resource.Resource.save_state_to_file` and `pylabrobot.resources.resource.Resource.load_state_from_file` methods. The file format is JSON.

To save the state of a resource to a file:

```python
resource.save_state_to_file("resource_state.json")
```

By default, a Resource will not have a state:

```json
{}
```

If you had serialized a {class}`pylabrobot.resources.Container` with a volume of 1000 uL, the file would look like this:

```json
{ "liquids": [], "pending_liquids": [] }
```

To load the state of a resource from a file:

```python
resource.load_state_from_file("resource_state.json")
```



# PlateHolder

TODO: write a tutorial

See :class:`~pylabrobot.resources.PlateHolder` for the API reference.

## Pedestal z height

> ValueError("pedestal_size_z must be provided. See https://docs.pylabrobot.org/resources/resource-holder/plate-holder.html#pedestal_size_z for more information.")

Many plate carriers feature a "pedestal" or "platform" on the sites. Plates can sit on this pedestal, or directly on the bottom of the site. This depends on the pedestal _and_ plate geometry, so it is important that we know the height of the pedestal.

The pedestal information is not typically available in labware databases (like the VENUS or EVOware databases), and so we rely on users to measure and contribute this information.

For background, see PR 143: [https://github.com/PyLabRobot/pylabrobot/pull/143](https://github.com/PyLabRobot/pylabrobot/pull/143).

### Measuring

Here's how you measure the pedestal height using a ruler or caliper:

![Pedestal height measurement](/resources/img/pedestal/measure.jpeg)

To explain what is happening in the image above: you measure the difference between the pedestal top and the top of the second highest surface: the surface that the plate would sit on if it had a very high clearance below its wells (i.e. a very high `dz` value). It is measured from the top of the pedestal to the top of the second highest surface, so it is a negative value. In some cases, the second highest surface is actually a small ridge, not the bigger outer edge of the plate holder. If that is the case, you measure from the top of the pedestal to the top of that ridge.

#### Measurement with z probing

To measure the height of a surface, you might find [z probing](/user_guide/00_liquid-handling/hamilton-star/z-probing) useful. Z-probing is an automated way, using a pipetting channel, to find the z height of an object. You can see a video of automated measurement on our YouTube channel:

<iframe width="720" height="405" src="https://www.youtube.com/embed/_uPf9hyTBog" title="YouTube video player" frameborder="0" allow="autoplay; encrypted-media; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Unlike the video, you do not necessarily need to traverse the entire plate, but multiple measurements are recommended to ensure accuracy.

## Contributing

Once you have measured the pedestal height, you can contribute this information to the PyLabRobot Labware database. Here's a guide on contributing to the open-source project: ["How to Open Source"](/contributor_guide/how-to-open-source.md).



# Defining custom resources

This document describes how to define custom resources in PyLabRobot. We will build a custom liquid container (called "Blue Bucket") and a custom plate, consisting of tubes stuck on top of a plate.

## Defining a custom liquid container

![Blue Bucket](/resources/img/custom-resources/blue-bucket.jpg)

Defining create a custom liquid container, like the blue bucket above, is as easy as instantiating a {class}`pylabrobot.resources.Resource` object:

```python
from pylabrobot.resources import Coordinate, Resource

blue_bucket = Resource(
  name='Blue Bucket',
  size_x=123, # in mm
  size_y=86,
  size_z=75,
)
```

If you want to instantiate many resources sharing the same properties, you can create a subclass of {class}`pylabrobot.resources.Resource` and override the class attributes:

```python
class BlueBucket(Resource):
  def __init__(self, name: str):
    super().__init__(
      name=name,
      size_x=123,
      size_y=86,
      size_z=75,
    )
```

This will allow you to creates instances like so:

```python
blue_bucket = BlueBucket(name="my blue bucket")
```

Because a blue bucket cannot have children, we override the {meth}`pylabrobot.resources.Resource.assign_child_resource` method to raise an exception:

```python
class BlueBucket(Resource):
  ...

  def assign_child_resource(self, child_resource: Resource, location: Coordinate) -> None:
    raise RuntimeError("BlueBuckets cannot have children")
```

### Aspirating from the custom resource

To help PLR track liquids in a container, all liquid-containing resources are subclasses of `Container`. Let's modify the class definition of BlueBucket to be a subclass of `Container`:

```python
class BlueBucket(Container):
```

The default behavior when aspirating from a resource is to aspirate from the bottom center:

```python
lh.aspirate(blue_bucket, vols=10)
```

![Aspirating from the blue bucket](/resources/img/custom-resources/aspirate-blue-bucket.jpg)

With multiple channels, the channels will be spread evenly across the bottom of the resource:

```python
await lh.aspirate(blue_bucket, vols=[10, 10, 10], use_channels=[0, 1, 2])
```

![Aspirating from the blue bucket with multiple channels](/resources/img/custom-resources/aspirate-blue-bucket-multiple-channels.jpg)

What happens when aspirating resources is that PLR creates a list of offsets that equally space the channels across the y-axis in the middle of the resource. These offsets are computed using {meth}`pylabrobot.resources.Resource.get_2d_center_offsets`. We can use this list and modify it to aspirate from a different location. In the example below, we will aspirate 10 mm from the left edge of the resource:

```python
offsets = blue_bucket.get_2d_center_offsets(n=2) # n=2, because we are using 2 channels
offsets = [Coordinate(x=10, y=c.y, z=c.z) for c in offsets] # set x coordinate of offsets to 10 mm
await lh.aspirate(blue_bucket, vols=[10, 10], offsets=offsets) # pass the offsets to the aspirate
```

![Aspirating from the blue bucket with multiple channels and custom offsets](/resources/img/custom-resources/aspirate-blue-bucket-multiple-channels-custom-offsets.jpg)

### Serializing data

Resources in PyLabRobot should be able to serialize and deserialize themselves, to allow them to be saved to disk and transmitted over a network.

On a high level, the `serialize` method creates a dictionary containing all data necessary to reconstruct a resource. This dictionary is passed to a resource's initializer as kwargs, meaning keys in the dictionary must correspond to initializer arguments.

The default Resource serializer encodes information for all resource properties, including the `size_x`, `size_y` and `size_z` attributes. Since we have these fixed for the `BlueBucket` class, we only have to serialize the name (the rest of the data is inferred by the type). So let's override the `serialize` method:

```python
class BlueBucket(Resource):
  ...

  def serialize(self) -> dict:
    return {
      "name": self.name,
      "type": self.__class__.__name__,
    }
```

## Defining a custom plate

![Custom Plate](/resources/img/custom-resources/tube-plate.jpg)

The resource pictured above is a custom plate, consisting of tubes in a rack.

To define the custom "tube plate", we will create a subclass of {class}`pylabrobot.resources.itemized_resource.ItemizedResource`. This class handles item indexing (think `plate["A1"]` and `plate.get_item(0)`).

{class}`pylabrobot.resources.itemized_resource.ItemizedResource` is a [generic class](https://mypy.readthedocs.io/en/stable/generics.html) that expects another class, of which the child resources will be instances. In this case, that class will be a custom `Tube` class. Let's define that first:

```python
class Tube(Container):
  def __init__(self, name: str):
    super().__init__(
      name=name,
      size_x=9,
      size_y=9,
      size_z=45,
    )
```

Next, let's define the custom plate. The `Tube` class is passed as a type argument to the `ItemizedResource` class with `[Tube]`:

```python
from pylabrobot.resources import ItemizedResource, create_equally_spaced_2d

class TubePlate(ItemizedResource[Tube]):
  def __init__(self, name: str):
    super().__init__(
      name=name,
      size_x=127.0,
      size_y=86.0,
      size_z=45.0,
      items=create_equally_spaced_2d(Tube,
        num_items_x=12,
        num_items_y=8,
        dx=9.5,
        dy=7.0,
        dz=1.0,
        item_dx=9.0,
        item_dy=9.0,
      )
    )
```

The {meth}`pylabrobot.resources.create_equally_spaced_2d` function creates a list of items, equally spaced in a grid.

This resource is automatically compatible with the rest of PyLabRobot. For example, we can aspirate from the plate:

```python
tube_plate = TubePlate(name="tube_plate")
lh.deck.assign_child_resource(tube_plate, location=location)

lh.aspirate(tube_plate["A1":"C1"], vols=10)
lh.dispense(tube_plate["A2":"C2"], vols=10)
```

![Aspirating from the tube plate](/resources/img/custom-resources/aspirate-tube-plate.jpg)



# Default Units

Unless otherwise specified, these are the units used in PyLabRobot:

| Quantity           | Unit                      |
| ------------------ | ------------------------- |
| Length             | millimeters (mm)          |
| Volume             | microliters (µL)          |
| Time               | seconds (s)               |
| Angle              | degrees (°)               |
| Weight/Mass        | grams (g)                 |
| Speed              | millimeters/second (mm/s) |
| Flow Rate          | microliters/second (µL/s) |
| Temperature        | degrees Celsius (°C)      |
| Force              | Newtons (N)               |



# Installation

These instructions describe how to install PyLabRobot.

Note that there are additional installation steps for using the firmware (universal) interface to Hamiltons and Tecans, see {ref}`below <using-the-firmware-interface>`.

## Installing PyLabRobot

It is highly recommended that you install PyLabRobot in a virtual environment.

Here's how to create a virtual environment using `venv`:

```bash
mkdir your_project
cd your_project
python -m venv env
source env/bin/activate  # on Windows: .\env\Scripts\activate
```

### From source

Alternatively, you can install PyLabRobot from source. This is particularly useful if you want to contribute to the project.

```bash
git clone https://github.com/pylabrobot/pylabrobot.git
cd pylabrobot
pip install -e ".[dev]"
```

See [CONTRIBUTING.md](/contributor_guide/contributing) for specific instructions on testing, documentation and development.

### Using pip (often outdated NOT recommended)

> The PyPI package is often out of date. Please install from source (see above).

The following will install PyLabRobot and the essential dependencies:

```bash
pip install pylabrobot
```

If you want to build documentation or run tests, you need install the additional
dependencies. Also using pip:

```bash
pip install "pylabrobot[docs]"
pip install "pylabrobot[testing]"
```

There's a multitude of other optional dependencies that you can install. Replace `[docs]` with one of the following items to install the desired dependencies.

- `fw`: Needed for firmware control over Hamilton robots.
- `http`: Needed for the HTTP backend.
- `websockets`: Needed for the WebSocket backend.
- `simulation`: Needed for the simulation backend.
- `opentrons`: Needed for the Opentrons backend.
- `agrow`: Needed for the AgrowPumpArray backend.
- `plate_reading`: Needed to interact with the CLARIO Star plate reader.
- `inheco`: Needed for the Inheco backend.
- `dev`: Everything you need for development.
- `all`: Everything. May not be available on all platforms.

To install multiple dependencies, separate them with a comma:

```bash
pip install 'pylabrobot[fw,http]'
```

Or install all dependencies at once:

```bash
pip install 'pylabrobot[all]'
```

(using-the-firmware-interface)=

## Using the firmware interface with Hamilton or Tecan robots

If you want to use the firmware version of the Hamilton or Tecan interfaces, you need to install a backend for [PyUSB](https://github.com/pyusb/pyusb/). You can find the official installation instructions [here](https://github.com/pyusb/pyusb#requirements-and-platform-support). The following is a complete (and probably easier) guide for macOS, Linux and Windows.

Reminder: when you are using the firmware version, make sure to install the firmware dependencies as follows:

```bash
pip install pylabrobot[fw]
```

### On Linux

You should be all set!

### On Mac

You need to install [libusb](https://libusb.info/). You can do this using [Homebrew](https://brew.sh/):

```bash
brew install libusb
```

```{warning}
People have reported issues with not being able to find the machine on macOS 15 Sonoma. No solution to this is currently known. See [this thread](https://labautomation.io/t/usb-device-not-found-error-potential-macos-15-issue/4568).
```

### On Windows

#### Installing

1. Download and install [Zadig](https://zadig.akeo.ie).

2. Make sure the Hamilton is connected using the USB cable and that no other Hamilton/VENUS software is running.

3. Open Zadig and select "Options" -> "List All Devices".

![](/user_guide/img/installation/install-1.png)

4. Select "ML Star" from the list if you're using a Hamilton STAR or STARlet. If you're using a Tecan robot, select "TECU".

![](/user_guide/img/installation/install-2.png)

5. Select "libusbK" using the arrow buttons.

![](/user_guide/img/installation/install-3.png)

6. Click "Replace Driver".

![](/user_guide/img/installation/install-4.png)

7. Click "Close" to finish.

![](/user_guide/img/installation/install-5.png)

#### Uninstalling

_These instructions only apply if you are using VENUS on your computer!_

If you ever wish to switch back from firmware command to use `pyhamilton` or plain VENUS, you have to replace the updated driver with the original Hamilton or Tecan one.

1. This guide is only relevant if ML Star is listed under libusbK USB Devices in the Device Manager program.

![](/user_guide/img/installation/uninstall-1.png)

2. If that"s the case, double click "ML Star" (or similar) to open this dialog, then click "Driver".

![](/user_guide/img/installation/uninstall-2.png)

3. Click "Update Driver".

![](/user_guide/img/installation/uninstall-3.png)

4. Select "Browse my computer for driver software".

![](/user_guide/img/installation/uninstall-4.png)

5. Select "Let me pick from a list of device drivers on my computer".

![](/user_guide/img/installation/uninstall-5.png)

6. Select "Microlab STAR" and click "Next".

![](/user_guide/img/installation/uninstall-6.png)

7. Click "Close" to finish.

![](/user_guide/img/installation/uninstall-7.png)

### Troubleshooting

If you get a `usb.core.NoBackendError: No backend available` error: [this](https://github.com/pyusb/pyusb/blob/master/docs/faq.rst#how-do-i-fix-no-backend-available-errors) may be helpful.

If you are still having trouble, please reach out on [discuss.pylabrobot.org](https://discuss.pylabrobot.org).

## Cytation imager

In order to use imaging on the Cytation, you need to:

1. Install python 3.10
2. Download Spinnaker SDK and install (including Python) [https://www.teledynevisionsolutions.com/products/spinnaker-sdk/](https://www.teledynevisionsolutions.com/products/spinnaker-sdk/)
3. Install numpy==1.26 (this is an older version)

If you just want to do plate reading, heating, shaknig, etc. you don't need to follow these specific steps.



# Setting up PLR on a Raspberry Pi

You can use PLR on any operating system, but Raspberry Pis can be a good choice if you want to run PLR on a dedicated device. They are cheap ($50) and can be left running 24/7. Any user on your network can ssh into it and use a workcell.

## Setting up the Raspberry Pi

- Use the Raspberry Pi Imager to install the Raspberry Pi OS on a microSD card: [https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/).
  - During the flashing, it is recommended to add a hostname and create an initial user so that you can SSH into the Raspberry Pi headlessly.
- After flashing, insert the microSD card into the Raspberry Pi and boot it up. Connect it to your network using an Ethernet cable.
- Alternatively, you can use WiFi if you configured it during flashing.
- SSH into the Raspberry Pi using the hostname and user you created during flashing.
  ```bash
  ssh <username>@<hostname>.local
  ```
- Update the Raspberry Pi:
  ```bash
  sudo apt update
  sudo apt upgrade
  ```
- Make USB devices accessible to users: add the following line to `/etc/udev/rules.d/99-usb.rules`:
  ```
  SUBSYSTEM=="usb", MODE="0666"
  SUBSYSTEM=="tty", MODE="0666"
  ```
- Reload the udev rules with
  ```bash
  sudo udevadm control --reload-rules && sudo udevadm trigger
  ```

```{warning}
This adds permissions to all USB devices. This is useful when you control the device and don't want to worry when plugging in new devices, but it could be a security risk if the machine is shared with untrusted users. See [udev documentation](https://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html) for more granular control.
```

## Setting up PLR

- See [installation instructions](https://docs.pylabrobot.org/user_guide/installation.html#installing-pylabrobot).



# User guide

<hr>

```{toctree}
:maxdepth: 1
:caption: Getting started
:hidden:

_getting-started/installation
How PLR Works <_getting-started/plr-architecture>
_getting-started/rpi
```


```{toctree}
:maxdepth: 1
:caption: Machines
:hidden:

machines
definitions
00_liquid-handling/_liquid-handling
01_material-handling/_material-handling
02_analytical/_analytical
```

```{toctree}
:maxdepth: 1
:caption: Machine-Agnostic Features
:hidden:

machine-agnostic-features/using-the-visualizer
machine-agnostic-features/using-trackers
machine-agnostic-features/writing-robot-agnostic-protocols
machine-agnostic-features/tip-spot-generators
machine-agnostic-features/validation
machine-agnostic-features/error-handling-general
machine-agnostic-features/sila-discovery
```

```{toctree}
:maxdepth: 1
:caption: Configuration
:hidden:

configuration
```


This guide helps you get started with PyLabRobot (PLR) and shows you how to build and run lab automation workflows. Whether you're new to lab robotics or already have hardware set up, this guide will help you understand how everything fits together.

The guide is divided into three parts:

- **Getting Started** – Learn how to install PLR, and how its core system is designed.

- **Machines** – Explore how to use the different types of lab hardware supported by PyLabRobot.

- **Machine-Agnostic Features** – Discover powerful tools that work across all devices, like the visualizer, trackers, reusable protocol patterns, validation tools, and error handling.

Check out [the list of supported machines](/user_guide/machines).

<hr>


<style>
  .machine_classification {
    border: 3px solid black;
    border-collapse: collapse;
    background-color: #FAF3DD;
    margin-left: 5px;
  }

  .machine_classification td {
    font-family: "Fira Code", monospace;
    font-size: 15px;
    font-weight: bold;
    line-height: 1.2;
    padding: 0 10px;
    border: none;
    white-space: pre;
  }
</style>

<table class="machine_classification">
  <tr><td>Machines</td></tr>

  <!-- Liquid Handling -->
  <tr><td>├── Liquid Handling</td></tr>
  <tr><td>│   ├── Pipetting Robots</td></tr>
  <tr><td>│   ├── Plate Washers</td></tr>
  <tr><td>│   └── Reagent Dispensers</td></tr>

  <!-- Material Handling -->
  <tr><td>├── ⚙️ Material Handling</td></tr>
  <tr><td>│   ├── Transport Systems</td></tr>
  <tr><td>│   │   ├── Conveyors</td></tr>
  <tr><td>│   │   ├── Robotic Arms</td></tr>
  <tr><td>│   │   └── Smart Storage (e.g. carousels)</td></tr>
  <tr><td>│   ├── Consumable Manipulation</td></tr>
  <tr><td>│   │   ├── Cappers & Decappers</td></tr>
  <tr><td>│   │   └── Sealers & Peelers</td></tr>
  <tr><td>│   └── Identification</td></tr>
  <tr><td>│       └── Barcode Labellers And Readers</td></tr>

  <!-- Environmental Control -->
  <tr><td>├── Environmental Control</td></tr>
  <tr><td>│   ├── Temperature And Motion Control</td></tr>
  <tr><td>│   │   ├── Automated Freezers/Fridges</td></tr>
  <tr><td>│   │   ├── Automated Incubators</td></tr>
  <tr><td>│   │   ├── Heated Cooled Blocks</td></tr>
  <tr><td>│   │   ├── Incubated Shakers</td></tr>
  <tr><td>│   │   ├── Shakers</td></tr>
  <tr><td>│   │   ├── Thermal Shakers</td></tr>
  <tr><td>│   │   └── Thermocyclers</td></tr>
  <tr><td>│   └── Airflow & Contamination Control</td></tr>
  <tr><td>│       ├── Air Circulation Fans</td></tr>
  <!-- <tr><td>│       ├── Gas Controlled Chambers</td></tr> -->
  <tr><td>│       ├── HEPA Filtration Modules</td></tr>
  <!-- <tr><td>│       ├── Laminar Flow Hoods</td></tr> -->
  <tr><td>│       └── UV-C Decontamination Units</td></tr>

  <!-- Sample Preparation And Processing -->
  <tr><td>├── Sample Preparation And Processing</td></tr>
  <tr><td>│   ├── Automated Centrifuges</td></tr>
  <tr><td>│   ├── Chromatography Systems</td></tr>
  <tr><td>│   ├── Colony Pickers</td></tr>
  <!-- <tr><td>│   ├── Filtration Units</td></tr> -->
  <!-- <tr><td>│   ├── Liquid Extractors</td></tr> -->
  <!-- <tr><td>│   ├── Lysis Modules</td></tr> -->
  <!-- <tr><td>│   ├── Magnetic Bead Purifiers</td></tr> -->
  <!-- <tr><td>│   ├── Pre-PCR Prep Stations</td></tr> -->
  <!-- <tr><td>│   ├── Sonicators</td></tr> -->
  <tr><td>│   └── Tissue Homogenizers</td></tr>

  <!-- Analytical And Detection -->
  <tr><td>└── 🔬 Analytical And Detection</td></tr>
  <tr><td>    ├── Balances / Scales</td></tr>
  <tr><td>    ├── Optical Detection</td></tr>
  <tr><td>    │   ├── Automated Microscopes</td></tr>
  <!-- <tr><td>        ├── Colony Counters</td></tr> -->
  <tr><td>    │   ├── Flow Cytometers</td></tr>
  <!-- <tr><td>        ├── Gel Imagers</td></tr> -->
  <!-- <tr><td>        ├── Microarray Scanners</td></tr> -->
  <tr><td>    │   ├── Plate Readers</td></tr>
  <!-- <tr><td>        ├── qPCR Machines</td></tr> -->
  <!-- <tr><td>        ├── Sequencers (DNA / RNA / Protein)</td></tr> -->
  <tr><td>    │   └── Spectrophotometers</td></tr>
  <tr><td>    └── pH Meters</td></tr>
</table>

<hr>



# Supported Machines

```{raw} html
<style>
tr > td:first-child { width: 15%; }
tr > td:nth-child(2) { width: 15%; }
tr > td:nth-child(3) { width: 20%; }
tr > td:nth-child(4) { width: 15%; }
tr > td:nth-child(5) { width: 15%; }
.badge {
  border-radius: 8px;
  padding: 2px 8px;
  display: inline-block;
  font-size: 90%;
  margin-right: 4px;
  color: black;
}
.badge-liquid { background: #d0eaff; }
.badge-transfer { background: #f0d0ff; }
.badge-centrifuge { background: #e6e6fa; }
.badge-heating { background: #ffd6d6; }
.badge-cooling { background: #d6f1ff; }
.badge-shaking { background: #ddffdd; }
.badge-thermo { background: #fff4cc; }
.badge-sealing { background: #ffe0b3; }
.badge-weight { background: #f0f0f0; }
.badge-reading { background: #d6eaff; }
.badge-cyto { background: #f5ccff; }
.badge-air { background: #e6f7ff; }
.badge-tilt { background: #e0f7da; }
.badge-storage { background: #b2e0e0; }
.badge-microscopy { background: #e0cfff; }
.badge-absorbance { background: #ffe6cc; }
.badge-fluorescence { background: #e0ffcc; }
.badge-luminescence { background: #e6e6ff; }
.badge-time-resolved-fluo { background: #ddffdd; }
.badge-fluo-polarization { background: #ddf2ffff; }
</style>
```


## Liquid Handling

### Liquid Handling Workstations

| Manufacturer | Machine | Features | PLR-Support | Links |
|--------------|---------|----------|-------------|--------|
| Hamilton | STAR(let) | <span class="badge badge-transfer">arm</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/00_liquid-handling/hamilton-star/_hamilton-star.html) / [OEM](https://www.hamiltoncompany.com/microlab-star) |
| Hamilton | Vantage | <span class="badge badge-transfer">arm</span> | Mostly | [PLR](https://docs.pylabrobot.org/user_guide/00_liquid-handling/hamilton-vantage/_hamilton-vantage.html) / [OEM](https://www.hamiltoncompany.com/microlab-vantage) |
| Hamilton | Prep | | WIP | [OEM](https://www.hamiltoncompany.com/microlab-prep) |
| Hamilton | Nimbus | <span class="badge badge-transfer">arm</span> | WIP | [OEM](https://www.hamiltoncompany.com/microlab-nimbus) |
| Tecan | EVO | <span class="badge badge-transfer">arm</span> | Basic | [PLR](https://docs.pylabrobot.org/user_guide/00_liquid-handling/tecan-evo/_tecan-evo.html) / [OEM](https://lifesciences.tecan.com/freedom-evo-platform) |
| Opentrons | OT-2 |  | Mostly | [PLR](https://docs.pylabrobot.org/user_guide/00_liquid-handling/opentrons-ot2/_opentrons-ot2.html) / [OEM](https://opentrons.com/products/ot-2-robot) |

### Pumps

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Cole Parmer | Masterflex L/S 07522-20 07522-30 07551-20 07551-30 07575-30 07575-40 | Full | [PLR](https://docs.pylabrobot.org/user_guide/00_liquid-handling/pumps/cole-parmer-masterflex.html) / [OEM](https://www.masterflex.nl/assets/uploads/2017/09/07551-xx.pdf) |
| Agrowtek | Pump Array | Full | [OEM](https://www.agrowtek.com/index.php/products/dosing_systems/dosing-pumps/agrowdose-adi-digital-persitaltic-dosing-pumps-detail) |

---

## Material Handling

### Arms

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Brooks Automation | PreciseFlex PF400 |  Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/arms/c_scara/precise-flex-pf400/_precise-flex-pf400.html)/ [OEM](https://www.brooks.com/laboratory-automation/collaborative-robots/preciseflex-400/) |
| Brooks Automation | PreciseFlex PF3400 |  Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/arms/c_scara/precise-flex-pf400/_precise-flex-pf400.html) / [OEM](https://www.brooks.com/laboratory-automation/collaborative-robots/preciseflex-400/) |
| PAA | KX2 | WIP | |

### Centrifuges

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Agilent | VSpin | Mostly | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/centrifuge/agilent_vspin.html) / [OEM](https://www.agilent.com/en/product/automated-liquid-handling/automated-microplate-management/microplate-centrifuge) |
| Agilent | VSpin Access2 Loader | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/centrifuge/agilent_vspin.html#loader) / [OEM](https://www.agilent.com/en/product/automated-liquid-handling/automated-microplate-management/microplate-centrifuge) |

### Fans

| Manufacturer | Machine | Features | PLR-Support | Links |
|--------------|---------|----------|-------------|--------|
| Hamilton | HEPA Fan | <span class="badge badge-air">air filtration</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/fans/fans.html) |

### Heater Shakers

| Manufacturer | Machine | Features | PLR-Support | Links |
|--------------|---------|----------|-------------|--------|
| Inheco | Thermoshake RM | <span class="badge badge-heating">heating</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/heating_shaking/inheco.html) / [OEM](https://www.inheco.com/thermoshake-classic.html) |
| Inheco | Thermoshake | <span class="badge badge-heating">heating</span><span class="badge badge-cooling">active cooling</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/heating_shaking/inheco.html) / [OEM](https://www.inheco.com/thermoshake.html) |
| Inheco | Thermoshake AC | <span class="badge badge-heating">heating</span><span class="badge badge-cooling">active cooling</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/heating_shaking/inheco.html) / [OEM](https://www.inheco.com/thermoshake-ac.html) |
| Opentrons | Thermoshake | <span class="badge badge-heating">heating</span> | Full | [OEM](https://opentrons.com/products/heater-shaker-module) |
| Hamilton | Heater Shaker | <span class="badge badge-heating">heating</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/heating_shaking/hamilton.html) / [OEM](https://www.hamiltoncompany.com/temperature-control/hamilton-heater-shaker) |
| QInstruments | BioShake | <span class="badge badge-heating">heating</span><span class="badge badge-cooling">active cooling</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/heating_shaking/qinstruments.html) / [OEM](https://www.qinstruments.com/automation/) |

### Storage

| Manufacturer | Machine | Features | PLR-Support | Links |
|--------------|---------|----------|-------------|--------|
| Thermo Fisher Scientific | Cytomat 6000 | <span class="badge badge-heating">heating</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/incubators/cytomat.html) / [OEM](https://assets.thermofisher.com/TFS-Assets/CMD/brochures/br-90468-cytomat-2-c-lin-br90468-en.pdf) |
| Thermo Fisher Scientific | Cytomat 6002 | <span class="badge badge-heating">heating</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/incubators/cytomat.html) / [OEM](https://www.thermofisher.com/order/catalog/product/50075279) |
| Thermo Fisher Scientific | Cytomat 2 C_50 | <span class="badge badge-heating">heating</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/incubators/cytomat.html) / OEM? |
| Thermo Fisher Scientific | Cytomat 2 C425 | <span class="badge badge-heating">heating</span><span class="badge badge-cooling">active cooling</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/incubators/cytomat.html) / [OEM](https://www.thermofisher.com/order/catalog/product/51033032) |
| Thermo Fisher Scientific | Cytomat 2 C450_SHAKE | <span class="badge badge-heating">heating</span><span class="badge badge-shaking">shaking</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/incubators/cytomat.html) / [OEM](https://www.thermofisher.com/order/catalog/product/51033035) |
| Thermo Fisher Scientific | Cytomat 5C | <span class="badge badge-heating">heating</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/incubators/cytomat.html) / [OEM](https://www.thermofisher.com/order/catalog/product/51031526) |
| Thermo/Liconic | Heraeus Cytomat | <span class="badge badge-heating">heating</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/incubators/cytomat.html) / OEM? |
| Inheco | Incubator Shaker (MTP/DWP) | <span class="badge badge-heating">heating</span><span class="badge badge-shaking">shaking</span> | Mostly | [OEM](https://www.inheco.com/incubator-shaker.html) |
| Inheco | SCILA | <span class="badge badge-heating">heating</span><span class="badge badge-shaking">shaking</span> | Mostly | [OEM](https://www.inheco.com/scila.html) |

### Peelers

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Azenta Life Sciences | XPeel | Full | [OEM](https://www.azenta.com/products/automated-plate-seal-remover-formerly-xpeel) |

### Sealers

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Azenta Life Sciences | a4S | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/sealers/a4s.html) / [OEM](https://www.azenta.com/products/automated-roll-heat-sealer-formerly-a4s) |

### Thermocyclers

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Opentrons | Thermocycler | Full | [OEM](https://opentrons.com/products/thermocycler-module-1) |
| Thermo Fisher Scientific | ATC | Full | [OEM](https://www.thermofisher.com/us/en/home/life-science/pcr/thermal-cyclers-realtime-instruments/thermal-cyclers/automated-thermal-cycler-atc.html) |
| Thermo Fisher Scientific | ProFlex | Full | [OEM](https://www.thermofisher.com/us/en/home/life-science/pcr/thermal-cyclers-realtime-instruments/thermal-cyclers/proflex-pcr-system.html) |
| Inheco | ODTC | WIP | [OEM](https://www.inheco.com/odtc.html) |

### Temperature Controllers

| Manufacturer | Machine | Features | PLR-Support | Links |
|--------------|---------|----------|-------------|--------|
| Opentrons | Temperature Module | <span class="badge badge-heating">heating</span><span class="badge badge-cooling">active cooling</span> | Mostly | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/temperature.html) / [OEM](https://opentrons.com/products/temperature-module-gen2) |
| Inheco | CPAC | <span class="badge badge-heating">heating</span><span class="badge badge-cooling">active cooling</span> | Full | [OEM](https://www.inheco.com/cpac.html) |

### Tilting

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Hamilton | Tilt Module | Full | [PLR](https://docs.pylabrobot.org/user_guide/01_material-handling/tilting.html) / [OEM](https://www.hamiltoncompany.com/other-robotics/188061) |

---

## Analytical Machines

### Plate Readers

| Manufacturer | Machine | Features | PLR-Support | Links |
|--------------|---------|----------|-------------|--------|
| BMG Labtech | CLARIOstar (Plus) | <span class="badge badge-absorbance">absorbance</span><span class="badge badge-fluorescence">fluorescence</span><span class="badge badge-luminescence">luminescence</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/02_analytical/plate-reading/bmg-clariostar.html) / [OEM](https://www.bmglabtech.com/en/clariostar-plus/) |
| Agilent (BioTek) | Cytation 1 | <span class="badge badge-absorbance">absorbance</span><span class="badge badge-fluorescence">fluorescence</span><span class="badge badge-luminescence">luminescence</span><span class="badge badge-microscopy">microscopy</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/02_analytical/plate-reading/cytation.html) / [OEM](https://www.agilent.com/en/product/cell-analysis/cell-imaging-microscopy/cell-imaging-multimode-readers/biotek-cytation-1-cell-imaging-multimode-reader-1623200) |
| Agilent (BioTek) | Cytation 5 | <span class="badge badge-absorbance">absorbance</span><span class="badge badge-fluorescence">fluorescence</span><span class="badge badge-luminescence">luminescence</span><span class="badge badge-microscopy">microscopy</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/02_analytical/plate-reading/cytation.html) / [OEM](https://www.agilent.com/en/product/cell-analysis/cell-imaging-microscopy/cell-imaging-multimode-readers/biotek-cytation-5-cell-imaging-multimode-reader-1623202) |
| Agilent (BioTek) | Synergy H1 | <span class="badge badge-absorbance">absorbance</span><span class="badge badge-fluorescence">fluorescence</span><span class="badge badge-luminescence">luminescence</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/02_analytical/plate-reading/synergyh1.html) / [OEM](https://www.agilent.com/en/product/microplate-instrumentation/microplate-readers/multimode-microplate-readers/biotek-synergy-h1-multimode-reader-1623193) |
| Byonoy | Absorbance 96 Automate | <span class="badge badge-absorbance">absorbance</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/02_analytical/plate-reading/byonoy/absorbance.html) / [OEM](https://byonoy.com/absorbance-96-automate/) |
| Byonoy | Luminescence 96 | <span class="badge badge-luminescence">luminescence</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/02_analytical/plate-reading/byonoy/luminescence.html) / [OEM](https://byonoy.com/luminescence-96/) |
| Byonoy | Luminescence 96 Automate | <span class="badge badge-luminescence">luminescence</span> | Full | [PLR](https://docs.pylabrobot.org/user_guide/02_analytical/plate-reading/byonoy/luminescence.html) / [OEM](https://byonoy.com/luminescence-96-automate/) |
| Molecular Devices | SpectraMax M5e | <span class="badge badge-absorbance">absorbance</span><span class="badge badge-fluorescence">fluorescence</span> <span class="badge badge-time-resolved-fluo">time-resolved fluorescence</span><span class="badge badge-fluo-polarization">fluorescence polarization</span> | Full | [OEM](https://www.moleculardevices.com/products/microplate-readers/multi-mode-readers/spectramax-m-series-readers) |
| Molecular Devices | SpectraMax 384plus | <span class="badge badge-absorbance">absorbance</span> | Full | [OEM](https://www.moleculardevices.com/products/microplate-readers/absorbance-readers/spectramax-abs-plate-readers) |


### Flow Cytometers

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Beckman Coulter | CytoFLEX S | WIP | [OEM](https://www.beckman.com/flow-cytometry/research-flow-cytometers/cytoflex-s) |

### qPCR Machines

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Thermo Fisher Scientific | QuantStudio 5 | WIP | [OEM](https://www.thermofisher.com/order/catalog/product/A34322) |

### Scales

| Manufacturer | Machine | PLR-Support | Links |
|--------------|---------|-------------|--------|
| Mettler Toledo | WXS205SDU | Full | [PLR](https://docs.pylabrobot.org/user_guide/02_analytical/scales.html#mettler-toledo-wxs205sdu) / [OEM](https://www.mt.com/us/en/home/products/Industrial_Weighing_Solutions/high-precision-weigh-sensors/weigh-module-wxs205sdu-15-11121008.html) |

---

## Understanding the Tables

Classifying lab automation equipment can be challenging.
There are many reasons for this, including (but not limited to):
- many machines have overlapping capabilities (the TFS Cytomat 2 C470 can be a fridge, heated chamber, oven, smart storage/plate hotel and shaker all in one machine!),
- different user groups require varying levels of software integration but tend to only refer to the capabilities they use in that moment (e.g. what is a shaker to one group might be a heater to another),
- balancing naming/classification based on user intuition/historic legacy and first principles, (e.g. a thermocycler is just a speedy heater/cooler but scientists are used to the term thermocycler)
- there is no widely accepted naming standard.

PyLabRobot does not solve these human classification issues.
But to provide *some* structure PyLabRobot classifies machines into three purposefully broad categories:

- **Liquid handling**: Machines directly manipulating liquids.
- **Material handling**: Machines handling materials other than liquids.
- **Analytical**: Machines primarily responsible for performing measurements.

**Table Columns Explained:**

- **Features**: Core capabilities provided by the machine.
- **PLR-Support**: Indicates PyLabRobot integration status:
  - **WIP**: Work in progress.
  - **Basics**: Core functionalities available.
  Code integrated into `pylabrobot:main`. Documentation pages in `docs.pylabrobot.org`.
  - **Mostly**: Most capabilities available, but some known commands still missing.
  - **Full**: Comprehensive capabilities (≥90%) fully supported, extensive documentation available.

Note: PyLabRobot aims to provide access to all hardware-firmware capabilities available on integrated equipment, even beyond OEM software.
This allows users to *choose* the machine functionalities they require.



# Writing Machine-Agnostic Protocols

This document describes best practices for writing methods that are agnostic to the robot backend.

> This is a work in progress. Please contribute!

## Keeping the layout separate from the protocol

It is recommended to keep the layout of the deck separate from the protocol. This allows you to easily change the layout of the deck without having to change the protocol.

```py
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.resources import Deck, TipRack, Plate

# Write a method that creates a deck and defines its layout.
def make_deck() -> Deck:
  deck = Deck()

  deck.assign_child_resource()
  deck.assign_child_resource()

  return deck

# Instantiate the liquid handler using a deck and backend.
deck = make_deck()
backend = STARBackend()
lh = LiquidHandler(backend=backend, deck=deck)

# Get references to the resources you need. Use type hinting for autocompletion.
tip_rack: TipRack = lh.deck.get_resource('tip_rack')
plate: Plate = lh.deck.get_resource('plate')

# the protocol...
lh.pick_up_tip(tip_rack["A1"])
```

## Strictness checking

Strictness checking is a feature that allows you to specify how strictly you want the {class}`LiquidHandler <pylabrobot.liquid_handling.liquid_handler.LiquidHandler>` to enforce the protocol. The following levels are available:

- {attr}`STRICT <pylabrobot.liquid_handling.strictness.Strictness.STRICT>`: The {class}`LiquidHandler <pylabrobot.liquid_handling.liquid_handler.LiquidHandler>` will raise an exception if you are doing something that is not legal on the robot.
- {attr}`WARN <pylabrobot.liquid_handling.strictness.Strictness.WARN>`: The default. The {class}`LiquidHandler <pylabrobot.liquid_handling.liquid_handler.LiquidHandler>` will warn you if you are doing something that is not recommended, but will not stop you from doing it.
- {attr}`IGNORE <pylabrobot.liquid_handling.strictness.Strictness.IGNORE>`: The {class}`LiquidHandler <pylabrobot.liquid_handling.liquid_handler.LiquidHandler>` will silently log on the debug level if you are doing something that is not legal on the robot.

You can set the strictness level for the entire protocol using {func}`pylabrobot.liquid_handling.strictness.set_strictness`.

```py
from pylabrobot.liquid_handling import Strictness, set_strictness

set_strictness(Strictness.IGNORE)
lh.pick_up_tips(my_tip_rack["A1"], illegal_argument=True) # will log on debug level

set_strictness(Strictness.WARN)
lh.pick_up_tips(my_tip_rack["A1"], illegal_argument=True) # will warn

set_strictness(Strictness.STRICT)
lh.pick_up_tips(my_tip_rack["A1"], illegal_argument=True) # will raise a TypeError
```



# Centrifuges

Centrifuges are controlled by the {class}`~pylabrobot.centrifuge.centrifuge.Centrifuge` class. This class takes a backend as an argument. The backend is responsible for communicating with the centrifuge and is specific to the hardware being used.

The {class}`~pylabrobot.centrifuge.centrifuge.Centrifuge` class has a number of methods for controlling the centrifuge. These are:

- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.open_door`: Open the centrifuge door.
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.close_door`: Close the centrifuge door.
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.lock_door`: Lock the centrifuge door.
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.unlock_door`: Unlock the centrifuge door.
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.lock_bucket`: Lock centrifuge buckets.
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.unlock_bucket`: Unlock centrifuge buckets.
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.go_to_bucket1`: Rotate to Bucket 1.
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.go_to_bucket2`: Rotate to Bucket 2.
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.rotate_distance`: Rotate the buckets a specified distance (8000 = 360 degrees).
- {meth}`~pylabrobot.centrifuge.centrifuge.Centrifuge.start_spin_cycle`: Start centrifuge spin cycle.

PLR supports the following centrifuges:

```{toctree}
:maxdepth: 1

agilent_vspin
```



# Fans (Air Filtration Systems)

In PyLabRobot, fans refer to air filtration units that condition air within or around the deck to protect the sample from contamination.

Their main purpose is to maintain a clean environment for experiments by ensuring consistent airflow and particle removal, reducing risks from dust, aerosols, and microorganisms.
These systems are not primarily designed for operator safety; separate equipment like fume extractors or biosafety cabinets serves that role.

Common filter technologies include:

- **HEPA filters**: Capture ≥99.97% of airborne particles ≥0.3 µm, widely used to keep samples clean.

- **ULPA filters**: Capture even smaller particles for higher-level cleanroom requirements.

- **Activated carbon filters**: Remove volatile organic compounds (VOCs) and chemical fumes.

- **Prefilters**: Trap larger particles to extend the lifespan of HEPA/ULPA filters.


```{toctree}
:maxdepth: 1
:hidden:
hamilton_hepa_scap
```



# Heater Shakers

Heater-shakers are a hybrid of {class}`~pylabrobot.temperature_controllers.temperature_controller.TemperatureController` and {class}`~pylabrobot.shakers.shaker.Shaker`. They are used to control the temperature of a sample while shaking it.

PyLabRobot supports the following heater shakers:

- Inheco ThermoShake RM (tested)
- Inheco ThermoShake (should have the same API as RM)
- Inheco ThermoShake AC (should have the same API as RM)
- Hamilton Heater Shaker (tested)
- QInstruments BioShake (3000 elmm, 5000 elm, and D30-T elm tested)

```{toctree}
:maxdepth: 1

Inheco ThermoShake <inheco>
Hamilton Heater Shaker <hamilton>
QInstruments BioShake <qinstruments>
```



# Tilting

Currently only the Hamilton tilt module is supported.

```python
from pylabrobot.tilting.hamilton import HamiltonTiltModule

tilter = HamiltonTiltModule(name="tilter", com_port="COM1")

await lh.move_plate(my_plate, tilter)

await tilter.set_angle(10) # absolute angle, clockwise, in degrees
await tilter.tilt(-1) # relative
```



# Thermocycling

This section provides an overview of how to use thermocyclers in PyLabRobot.

Thermocyclers are essential for temperature-controlled processes like PCR (Polymerase Chain Reaction). PyLabRobot offers a high-level `Thermocycler` class to interact with these devices, along with various backends for different hardware.

## Key Features

- **Temperature Control:** Set and monitor block and lid temperatures.
- **Lid Control:** Open and close the thermocycler lid.
- **Profile Execution:** Run complex temperature profiles, including standard PCR protocols.
- **Status Monitoring:** Query the current state of the thermocycler, including temperature, lid status, and profile progress.

## Supported Thermocyclers

- Opentrons Thermocycler



# Sealers

In automated wet lab workflows, **microplate sealers** are essential for preserving sample integrity.
They prevent **evaporation**, **cross-contamination**, and **spillage**, especially during heating, shaking, storage, or robotic transport.

PyLabRobot supports integration with various sealer machines, allowing you to programmatically seal plates as part of your automation workflows.

---

## Types of Sealers

There are two primary categories of sealers commonly used in automated labs:

### Thermal Sealers

These use heat and pressure to bond a sealing film (typically foil or heat-reactive plastic) to the top of the microplate.

- **Examples**: Azenta a4S, Bio-Rad PX1, Agilent PlateLoc (thermal mode)
- **Best for**: Long-term storage, PCR/qPCR workflows, high-integrity applications
- **Pros**:
  - Very strong seal (potentially, depends on chosen parameters)
  - Compatible with a wide range of films
- **Cons**:
  - Slower sealing time (typically 5–10 seconds per plate)
  - Requires warm-up time
  - May need precise plate/film alignment
  - When peeled, thermal seals remove (at least some) well material.
  Thermal seals might therefore only be usable until too much well material has been ripped off.

### Adhesive (Pressure) Sealers

These apply pre-cut adhesive seals to the plate using downward mechanical pressure.
They do **not** use heat, making them faster and simpler for certain workflows.

- **Examples**: Agilent PlateLoc (adhesive mode), Thermo ALPS5000 (in adhesive mode)
- **Best for**: Medium-throughput workflows, frequent access, short-term incubation
- **Pros**:
  - Faster (as low as 1–2 seconds per plate)
  - No warm-up period
  - Compatible with repeelable seals
- **Cons**:
  - Weaker seal compared to thermal
  - Not suitable for long-term storage or high-temperature protocols

---


```{toctree}
:maxdepth: 1
:hidden:

Azenta a4S <a4s>
```



# Definitions

We try to keep jargon to a minimum, but some terms are commonly used in lab automation speak/PLR docs. It is a form of tacit knowledge. In some cases it's best to accept the universally used terms and not reinvent the wheel with more descriptive/longer terms. In those cases, we help newcomers by defining those terms here.

| Term | Definition |
|-|-|
| 96 head | A pipetting head with 96 channels that do not move independently. |



# Configuring PLR

The `pylabrobot.config` module provides the `Config` class for configuring PLR. The configuration can be set programmatically or loaded from a file.

The configuration currently only supports logging configuration.

## The `Config` class

You can create a `Config` object as follows:

```python
import logging
from pathlib import Path
from pylabrobot.config import Config

config = Config(
  logging=Config.Logging(
    level=logging.DEBUG,
    log_dir=Path("my_logs")
  )
)
```

Then, call `pylabrobot.configure` to apply the configuration:

```python
import pylabrobot
pylabrobot.configure(config)
```

## Loading from a file

PLR supports loading configuration from a number of file formats. The supported formats are:

- INI files
- JSON files

Files are loaded using the `pylabrobot.config.load_config` function:

```python
from pylabrobot.config import load_config
config = load_config("config.json")

import pylabrobot
pylabrobot.configure(config)
```

If no file is found, a default configuration is used.

`load_config` has the following parameters:

```python
def load_config(
  base_file_name: str,
  create_default: bool = False,
  create_module_level: bool = True
) -> Config:
```

A `pylabrobot.ini` file is used if found in the current directory. If not found, it is searched for in all parent directories. If it still is not found, it gets created at either the project level that contains the `.git` directory, or the current directory.

### INI files

Example of an INI file:

```ini
[logging]
level = DEBUG
log_dir = .
```

### JSON files

```json
{
  "logging": {
    "level": "DEBUG",
    "log_dir": "."
  }
}
```



# Cole Parmer Masterflex

PyLabRobot supports the following pumps:

- {ref}`Cole Parmer Masterflex <masterflex>`

## Introduction

Pumps are controlled by the {class}`~pylabrobot.pumps.pump.Pump` class. These take a backend as an argument. The backend is responsible for communicating with the pump and is specific to the hardware being used.

```python
from pylabrobot.pumps import Pump
backend = SomePumpBackend()
p = Pump(backend=backend)
await p.setup()
```

The {meth}`~pylabrobot.pumps.pump.Pump.setup` method is used to initialize the pump. This is where the backend will connect to the pump and perform any necessary initialization.

The {class}`~pylabrobot.pumps.pump.Pump` class has a number of methods for controlling the pump. These are:

- {meth}`~pylabrobot.pumps.pump.Pump.run_continuously`: Run the pump continuously at a given speed.

- {meth}`~pylabrobot.pumps.pump.Pump.run_revolutions`: Run the pump for a given number of revolutions.

- {meth}`~pylabrobot.pumps.pump.Pump.halt`: Stop the pump immediately.

Run the pump for 5 seconds at 100 RPM:

```python
await p.run_continuously(speed=100)
await asyncio.sleep(5)
await p.halt()
```

(masterflex)=

## Cole Parmer Masterflex

The Masterflex pump is controlled by the {class}`~pylabrobot.pumps.cole_parmer.masterflex_backend.MasterflexBackend` class. This takes a serial port as an argument. The serial port is used to communicate with the pump.

```python
from pylabrobot.pumps.cole_parmer.masterflex import MasterflexBackend
m = MasterflexBackend(com_port='/dev/cu.usbmodemDEMO000000001')
```

(I have tried on the L/S 07551-20, but it should work on other models as well.)

Documentation available at: [https://web.archive.org/web/20210924061132/https://pim-resources.coleparmer.com/instruction-manual/a-1299-1127b-en.pdf](https://web.archive.org/web/20210924061132/https://pim-resources.coleparmer.com/instruction-manual/a-1299-1127b-en.pdf)



# Hamilton Prep

Coming soon. See [https://github.com/PyLabRobot/pylabrobot/pull/407](https://github.com/PyLabRobot/pylabrobot/pull/407).



# iSWAP Module

The `R0` module allows fine grained control of the iSWAP gripper.

## Common tasks

- Parking

You can park the iSWAP using {meth}`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STARBackend.park_iswap`.

```python
await star_backend.park_iswap()
```

- Opening gripper:

You can open the iSWAP gripper using {meth}`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STARBackend.iswap_open_gripper`. Warning: this will release any object that is gripped. Used for error recovery.

```python
# opening all the way
await star_backend.iswap_open_gripper()
```

```python
# opening partially to 90mm
await star_backend.iswap_open_gripper(open_position=90)
```

- Closing gripper: note: this will throw an error if there is no object to grip.

```python
await star_backend.iswap_close_gripper()
```

## Rotations

You can rotate the iSWAP to 12 predefined positions using {meth}`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STARBackend.iswap_rotate`.

the positions and their corresponding integer specifications are shown visually here.

![alt text](iswap_positions.png)

The `iswap_rotate` method can be used to move the wrist drive and the rotation drive simultaneously in one smooth motion. It takes a parameter for the rotation drive, and the final `grip_direction` of the iswap. The `grip_direction` is the same parameter used by {meth}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.pick_up_resource` and {meth}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.drop_resource`, and is with respect to the deck. This is easier than controlling the rotation drive, which is with respect to the wrist drive.

To extend the iSWAP fully to the left, call `iswap_rotate(rotation_drive=STARBackend.RotationDriveOrientation.LEFT, grip_direction=GripDirection.RIGHT)`. `GripDirection.RIGHT` means the gripper will be gripping the object from the right hand side meaning the gripper fingers will be pointing left wrt the deck. Compared this to `iswap_rotate(rotation_drive=STARBackend.RotationDriveOrientation.RIGHT, grip_direction=GripDirection.RIGHT)`, where the gripper fingers will still be pointing left wrt the deck, but the rotation drive is pointing right. This means the wrist drive is in "REVERSE" orientation (folded up).

Moving the iswap between two positions with the same `grip_direction` while changing the rotation drive will keep the plate pointing in one direction. The internal motion planner on the STAR will automatically adjust the wrist drive to keep the plate in the same orientation.

### Controlling the wrist and rotation drive individually

You can also control the wrist (T-drive) and rotation drive (W-drive) individually using {meth}`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STARBackend.rotate_iswap_wrist` and {meth}`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STARBackend.rotate_iswap_rotation_drive` respectively. Make sure you have enough space (you can use {meth}`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STARBackend.move_iswap_y_relative`)

```python
rotation_drive = random.choice([STARBackend.RotationDriveOrientation.LEFT, STARBackend.RotationDriveOrientation.RIGHT, STARBackend.RotationDriveOrientation.FRONT])
wrist_drive = random.choice([STARBackend.WristDriveOrientation.LEFT, STARBackend.WristDriveOrientation.RIGHT, STARBackend.WristDriveOrientation.STRAIGHT, STARBackend.WristDriveOrientation.REVERSE])
await star_backend.rotate_iswap_rotation_drive(rotation_drive)
await star_backend.rotate_iswap_wrist(wrist_drive)
```

## Slow movement

You can make the iswap move more slowly during sensitive operations using {meth}`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STARBackend.slow_iswap`. This is useful when you want to avoid splashing or other disturbances.

```python
async with star_backend.slow_iswap():
  await lh.move_plate(plate, plt_car[1])
```

## Manual movement (teaching / calibration)

1. For safety, move the other components as far away as possible before teaching. This is easily done using the firmware command `C0FY`, implemented in PLR as `position_components_for_free_iswap_y_range`:

```python
await star_backend.position_components_for_free_iswap_y_range()
```

2. Move the iSWAP wrist and rotation drive to the correct orientation as [explained above](#rotations). Repeated: be careful to move the iSWAP to a position where it does not hit any other components. See commands below for how to do this.

3. You can then use the following three commands to move the iSWAP in the X, Y and Z directions. All units are in mm.

```python
await star_backend.move_iswap_x(x)
```

```python
await star_backend.move_iswap_y(y)
```

```python
await star_backend.move_iswap_z(z)
```

4. Note that the x, y and z here refer to the **center** of the iSWAP gripper. This is to make it agnostic to plate size. But in PLR all locations are with respect to LFB (left front bottom) of the plate. To get the LFB after calibrating to the center, subtract the distance from the plate LFB to CCB:

```python
from pylabrobot.resources import Coordinate

calibrated_position = Coordinate(x, y, z)
plate_lfb_absolute = calibrated_position - plate.get_anchor("c", "c", "b")
```

Then you get the plate's LFB position in absolute coordinates. The location of the plate will probably be defined wrt some other resource. To get the relative location of the plate wrt that parent resource, you have to subtract the absolute location of the parent from the absolute location of the plate:

```python
parent_absolute = parent.get_location_wrt(deck)
plate_relative = plate_lfb_absolute - parent_absolute
```

This will be the location of the plate wrt the parent. You can use this with `parent.assign_child_resource(plate, location=plate_relative)` to assign the plate to the parent resource.

### Relative movements

You can also move the iSWAP relative to its current position using the following commands. All units are in mm.

```python
await star_backend.move_iswap_x_relative(x)
```

```python
await star_backend.move_iswap_y_relative(y)
```

```python
await star_backend.move_iswap_z_relative(z)
```

This is the center of the iSWAP gripper. See the note above.



# Liquid level detection on Hamilton STAR(let)

Liquid level detection (LLD) is a feature that allows the Hamilton STAR(let) to move the pipetting tip down slowly until a liquid is found using either a) the pressure sensor, or b) a change in capacitance, or c) both. This feature is useful if you want to aspirate or dispense at a distance relative to the liquid surface, but you don't know the exact height of the liquid in the container.

To use LLD, you need to specify the LLD mode when calling the `aspirate` or `dispense` methods. Here is how you can use pressure or capacative LLD with the `aspirate` :

```python
await lh.aspirate([tube], vols=[300], lld_mode=[STARBackend.LLDMode.GAMMA])
```

The `lld_mode` parameter can be one of the following:

- `STARBackend.LLDMode.OFF`: default, no LLD
- `STARBackend.LLDMode.GAMMA`: capacative LLD (cLLD)
- `STARBackend.LLDMode.PRESSURE`: pressure LLD (pLLD)
- `STARBackend.LLDMode.DUAL`: both capacative and pressure LLD
- `STARBackend.LLDMode.Z_TOUCH_OFF`: find the bottom of the container

The `lld_mode` parameter is a list, so you can specify a different LLD mode for each channel.

```{note}
The `lld_mode` parameter is only available when using the `STAR` backend.
```

## Going into or out of the liquid

You can use the `immersion_depth` backend kwarg to move the tip with respect to the found liquid surface. A positive value means to go deeper into the liquid, a negative value means to go above the liquid.

Going 1mm below the liquid for aspiration:

```python
await lh.aspirate(
  [tube],
  vols=[300],
  lld_mode=[STARBackend.LLDMode.GAMMA],
  immersion_depth=[1])
```

Going 1mm above the liquid for dispens:

```python
await lh.dispense(
  [tube],
  vols=[300],
  lld_mode=[STARBackend.LLDMode.GAMMA],
  immersion_depth=[-1])
```

## Moving with liquid surface (liquid following)

Through another backend kwarg, `surface_following_distance`, you can move with the liquid:

```python
await lh.aspirate(
  [tube],
  vols=[300],
  lld_mode=[STARBackend.LLDMode.GAMMA],
  surface_following_distance=[10],  # 10mm
)
```

## Catching errors

All channelized pipetting operations raise a `ChannelizedError` exception when an error occurs, so that we can have specific error handling for each channel.

When no liquid is found in the container, the channel will have a `TooLittleLiquidError` error. This is useful for detecting that your container is empty.

You can catch the error like this:

```python
from pylabrobot.liquid_handling.errors import ChannelizedError
from pylabrobot.resources.errors import TooLittleLiquidError
channel = 0
try:
  await lh.aspirate([tube], vols=[300], lld_mode=[STARBackend.LLDMode.GAMMA], use_channels=[channel])
except ChannelizedError as e:
  if isinstance(e.errors[channel], TooLittleLiquidError):
    print("Too little liquid in tube")
```



# Debugging STAR issues

This page explains how to debug issues with PLR and a Hamilton STAR(let).

## Finding VENUS trace files

To get the firmware instructions sent by venus when doing specific operations, locate the following file:

`C:\Program Files (x86)\HAMILTON\LogFiles\HxUsbCommYYYMMDD.trc`

This information will be useful to see how the firmware commands sent by VENUS differ from the ones we send in PLR.

```{warning}
This file may contain firmware output of entire protocols you are running, so be careful with sharing it. You may want to look at the timestamps and filter the file to only include the relevant parts, or share the file privately.
```



# Replacing iSWAP arm on Hamilton STAR

This guide provides instructions for replacing the iSWAP arm on a Hamilton STAR liquid handling system.

Caution/Disclaimer:
1. This procedure is a work in progress and the user assumes all responsibility for any damage that may be done as a result.
2. This procedure should not be performed on any system that are either under the OEM Warranty period or currently on a service contract with the OEM or any third party service organization. This will certainly void the OEM Warranty/Service contract and likely invalidate any service agreement with third parties.
3. This procedure DOES NOT encapsulate the entire OEM adjustment procedure which includes specialized tooling and software to perform. Consult [iSWAP Auto Adjustment Guide](adjusting-iswap.md) for auto-calibrating arm after installation proceduce.
4. Once completing this procedure it is necessary to check, and if needed, reteach the locations that are to be accessed by the iSWAP.

Note: Due to the way the iSWAP is taught, the calibration positions from machine to machine are typically very close. This means an iSWAP can be SWAPPED (pun intended) and function largely the same with minor tweaks.

## Tools

- 2mm hex key
- 4mm hex key
- Computer with STAR Service or PLR installed
- Caliper (useful for rough leveling, but not required)

## Removing the iSWAP Arm

1. Ensure that the Hamilton STAR system is powered off.

2. Undo the following two FFC cables:

![](./img/replace-iswap/ffc.jpg)

3. Slightly loosen the two screws on the side using a 2mm hex key, enough to slide off the metal piece. It is easiest to keep the screws in place.

![](./img/replace-iswap/side-screws.jpg)

4. Undo the two main screws on the back of the iSWAP arm using a 4mm hex key. Remove them. Start with the adjustment screw (1), then the main screw (2). Be careful, the arm might fall off if you don't hold it.

![](./img/replace-iswap/main-screws.jpg)

5. The iSWAP arm can now be removed from the Hamilton STAR system. After removing the arm, you are left with this:

![](./img/replace-iswap/after-remove.jpg)

## Attaching the New iSWAP Arm and rough leveling

6. Place the replacement arm on the system, insert and tighten the two fixing screws, reattach the communication and Y-drive ribon cables.

Note: Once physically installed on the system it is recommended that you level the arm in relation to the deck.

7. Loosen the two fixing screws until the iSWAP is fixed in position but can still be rotated about the X Axis (left to right) of the machine.
8. Manually position the X-Arm in the center of the machine and the iSWAP in the middle of the X-Arm.
9. Remove any labware below the iSWAP.
10. Power on the machine and verify there are no errors when calling `lh.setup()`.

This code is most easily run in a Jupyter notebook so that you can send the other commands whenever you are ready.

```python
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.resources import STARDeck
star_backend = STARBackend()
lh = LiquidHandler(backend=star_backend, deck=STARDeck())
await lh.setup()
```

11. **!!While supporting the iSWAP in the Z axis!!** release the Z axis brake on the iSWAP.

```python
input("Confirm the deck is clear and press Enter to continue...")
await star_backend.position_components_for_free_iswap_y_range()
await star_backend.move_iswap_y(300)
x = lh.deck.rails_to_location(deck.num_rails/2).x
await star_backend.move_iswap_x(x)
```

hold the iSWAP arm in place while you do this, as it will fall if you don't:

```python
await star_backend.iswap_dangerous_release_break()  # firmware command "R0BA"
```

12. Lower the iSWAP until the gripper fingers are just above the deck surface (2-5mm) but still above the little "submarines".
13. Reengage the Z axis brake

```python
await star_backend.iswap_reengage_break()  # firmware command "R0BO"
```

14. Orient the iSWAP with the main arm to the right with the gripper facing you and rotate the iSWAP about the X axis by adjusting the screws until the gripper fingers are equidistant from the deck.

```python
await star_backend.iswap_rotate(
  rotation_drive=STARBackend.RotationDriveOrientation.RIGHT,
  grip_direction=GripDirection.BACK
)
```

15. Rotate the main iSWAP are 180 degrees to the left and rotate the gripper hand around until it is facing you. Repeat the X axis rotation until the gripper fingers are equidistant from the deck.

```python
await star_backend.iswap_rotate(
  rotation_drive=STARBackend.RotationDriveOrientation.LEFT,
  grip_direction=GripDirection.BACK
)
```

16. Repeat steps 14 and 15 until both sides are relatively the same.
17. Make sure there is no chance of Z axis collision and initialize the Z axis of the iSWAP.

```python
await star_backend.iswap_initialize_z_axis()  # firmware command "R0ZI"
```

18. Check/Reteach all iSWAP locations in your programs.



# Hamilton STAR Hardware Guide

```{toctree}
:maxdepth: 1

replacing-iswap
adjusting-iswap
adjusting-robot
adjusting-iswap-gripper-parrallelity
```



# Auto-Adjustment of iSWAP

STAR service macro scripts auto-define positions for every iSWAP arm/wrist conformation, resolving issues where properly defined labware is far off from the position an iSWAP repeatedly picks/places. This can be a cause for plate mishandling, especially when changing arm/wrist conformations between pickup and placement.

After adjustment, test all iSWAP movements, especially to locations external to the workcell. These will likely need change a few mm as the iSWAP is in an updated coordinate space.

Adjusting an iSWAP is essential to keeping a workcell healthy in demanding, high-uptime production labs.

Email RoboticsServicePartQuote@hamiltoncompany.com for the most rapid quoting process for 182990 and 173960, required for the automatic calibration process.

Hamilton may request in-person training before providing access to STAR service and service macros.

note: it is best to perform iSWAP adjustment after first fully defining the coordinate space of the STAR with gantry and pipette macros.

## Calibration of iSWAP using Hamilton iSWAP auto-adjustment kit PN#182990

Ensure none of the calibration tools are mounted on the iSWAP prior to starting the calibration macro.

1. Install the iswap adjustment tool in slot 15. Loosen the indicated thumbscrew before placing on-deck. Once on-deck, slide tool as far toward back of STAR as it will go, then tighten thumbscrew. Tool should be flush with STAR carrier backstops

![](./img/adjust-iswap/iswap-tool-install.jpg)

2. Begin adjust_iswap.mcr, let robot initialize, and wait until prompted to install the gripper probe tool on iSWAP arm.

    First loosen two indicated thumbscrews on wire guide, then mount onto metal plate of iSWAP arm segment. Tighten and route gripper probe into gripper.

    Make sure the connection wire is routed on the left side of the gripper tool exactly as pictured. Otherwise, the cable will bind on the iSWAP causing an error during macro execution

![](./img/adjust-iswap/gripper-probe-install.jpg)


3. Mount wire holder at top of iSWAP using indicated thumbscrew and plug connector into leftmost position on top of iSWAP circuit board
    
    the blocked pin on the connector should line up with the missing pin on your iSWAP board as pictured

![](./img/adjust-iswap/iswap-board-connect.jpg)

4. Ensure electrical contact sensing works:

![](./img/adjust-iswap/ground-probe.jpg)

5. Begin automatic calibration.
    
    It will run for ~5 minutes before you are prompted to install 2 more tools:
    
    screw in the "cylindrical tool" directly onto the Z axis of the iSWAP:

    ![](./img/adjust-iswap/cylindrical-tool.jpg)
    
    the pin tool installs in two parts. place the pin through the bottom of the wrist joint, and catch this threaded pin with the indicated thumbscrew mounted on the top of the wrist joint. there is a thru-hole to accommodate the pin:

    ![](./img/adjust-iswap/pin-tool.jpg)

    Connect the red wire plugs to the gripper tool. When ready, the final iSWAP calibration assembly looks like this:

    ![](./img/adjust-iswap/iswap-calibration-assembly.jpg)

6. Resume automatic calibration.

    Will run for ~5 minutes before you are prompted to remove JUST the cylindrical tool. Keep the pin tool installed on the wrist joint like so:

![](./img/adjust-iswap/cylinder-tool-removed.jpg)


7. Resume automatic calibration.
    Will run for ~10 minutes before finishing. Make sure to click through macro until "end macro" msg, as robot configuration is being written up until the very end of the macro.


## Calibration of iSWAP over labware using Hamilton Channel Calibration Tool PN#173960

This Adjust_iSWAP_above_Labware macro is typically not required.

__Critical__: The taller Pipetting Channel Calibration Tool is used during the Adjust_iSWAP_above_Labware macro, instead of the short iSWAP adjustment tool used above.

Steps are similar to the auto-adjustment process described above.

![](./img/adjust-iswap/adjust-iswap-over-labware.jpg)


# Adjust iSWAP gripper parallelity

The steel pointy bits at the end of the iSWAP grippers are intended to be the primary points of contact with a plate.

They physically deform plastic, leading to a repeatable secure grip.

Over time, the aluminum fingers leading up to the metal grippers can begin to angle outward, leaving the grip narrower toward the back of the iSWAP hand and wider at the steel pointy bits.

In iSWAPs with this calibration issue, a plate can accidentally be picked up using force primarily through the smooth aluminum fingers instead of the steel pointy bits. This predisposes the plate to pivot around the smooth fingers, rotating downwards and causing catastrophic plate crashes to external hotel locations when it fails.

In our testing, improper grips can be reliable for hundreds of pick/place operations, but fail after thousands. To achieve robust operation, physical adjustment is required.

![](./img/adjust-iswap-gripper/before-after.jpg)

## Tools
- 1.5mm hex key
- 2.5mm hex key

## Step-by-step hardware adjustment guide

Loosen by <1 turn the 4 adjustment screws (1.5mm hex) on top of the iSWAP hand corresponding to the right gripper finger. Do not fully remove the screws. This frees the slider bearing to rotate around the Z axis.

There should be ~1mm of play at the end of the finger.

Narrow the angle of the finger and retighten these 4 screws.

A bit of force may be required initially to unstick/free the bearing to rotate, but not enough force to bend the aluminum.

Remove 2 screws (2.5mm hex) holding the data wire in place on the left gripper finger. This exposes the other 4 adjustment screws. Repeat the process for these 4.

![](./img/adjust-iswap-gripper/rotate-slider-bearing.jpg)


You may need to run the Hamilton [iSWAP calibration macro](adjusting-iswap.md) to recalibrate grip width after making these changes, however in our testing hotel coordinate locations are altered <1mm by the physical adjustment of gripper parallelity.



# Complete Adjustment Procedure for STAR(let)

See [Microlab STAR Service Manual](https://archive.org/details/manual_Hamilton_Microlab_STAR_Service_Manual) for official instructions & photos of an older STAR that follows the same adjustment principles.

## Tools:
- 4 mm hex wrench  
- 3 mm hex wrench  
- 2 mm hex wrench  
- 8 mm hex socket, long (> 50 mm reach and > 12 mm depth)  
- Hamilton Channel Calibration Tool PN #137960  
  contact RoboticsServicePartQuote@hamiltoncompany.com for quick quoting  

Install the channel calibration tool by loosening the circled thumbscrew, placing it on the deck, and sliding it along the submarines to the end stop at the back of the STAR. Tighten the thumbscrew when the tool is in position.

![](./img/adjust-robot/channel-calibration-tool.jpg)

If there is trouble with conductive-probe sensing, clean the tool’s registration points with ethanol.

## Adjust Arm Z  
Using `adjust_arm_z.mcr`, measure the current gantry height and level the Z height of the X‑slider bar at the top front of the robot, from left to right. Often, dust on the deck must be wiped with ethanol for successful sensing.

1. Start the macro. After about 5 minutes of automatic measurement, you’ll be prompted to adjust the gantry bar.  
2. Loosen the fixing screws (6 on STAR, 5 on STARlet; indicated by red arrows in the example) with a 4 mm hex key.  
3. The gantry now rests on two set screws at the top of the aluminum X‑slider assembly. These allow ±Z alignment with a 2 mm hex wrench. Each full turn is ~ 40 steps. Make small adjustments and test often until you meet the macro’s specifications.

  ![](./img/adjust-robot/adjust-arm-z.jpg)

## Check X‑Arm Differential  
Using `check_x_arm_diff.mcr`, adjust the Z rotation of the entire pipetting gantry—essential for controlling Z‑rotated iSWAPs and accurate pipetting.

Once the macro finishes, you’ll be prompted to rotate the gantry per the measurements:

![](./img/adjust-robot/check-x-arm-diff-script-0.jpg)

1. Loosen the eight nuts (red arrows) securing the pipetting gantry to the X‑drive sliders at its base.  
   ![](./img/adjust-robot/check-x-arm-diff.jpg)  
2. The gantry rests at three points: two at the back (pictured) and one at the front-top X‑slider.  
3. The mounting holes are slotted to permit rotation around the Z axis.  
4. An adjustment value of 30 is small. Fine‑tune by hand: press the gantry against the sliders, hand‑tighten, and re‑test often.  
5. For coarse adjustment, grasp the back of the gantry and rotate with your arms extended to the front (this will overshoot by hundreds).

A negative X‑arm correction value means a counterclockwise rotation around Z (in the positive X direction):

![](./img/adjust-robot/rotate-x-arm-around-z.jpg)  
^ *Graphic sourced from [STAR Service Manual](https://archive.org/details/manual_Hamilton_Microlab_STAR_Service_Manual)*

A successful adjustment looks like this:

![](./img/adjust-robot/check-x-arm-diff-script-1.jpg)

## Adjust Pip Manual  
Using `adjust_pip_manual.mcr`, align each pipette’s X translation, Y rotation, and X rotation. Every channel is measured, and a report shows the required adjustments:

![](./img/adjust-robot/adjust-pip-script-0.jpg)

In this example, the pipette must shift left in X (front‑view) with no X‑axis rotation:

![](./img/adjust-robot/adjust-pip-0.jpg)

1. To shift left, loosen the upper or lower channel screw. Rotate the pipette up and away from the calibration tool slightly to achieve both rotation and translation along the red‑arrow axis:  
   ![](./img/adjust-robot/adjust-pip-1.jpg)  
2. Tighten that screw, leaving the pipette offset:  
   ![](./img/adjust-robot/adjust-pip-2.jpg)  
3. Loosen the remaining channel screw to finalize translation and correct rotation:  
   ![](./img/adjust-robot/adjust-pip-3.jpg)  
4. Align the channel with the tool—perfect alignment isn’t always exact. When close, follow STAR Service’s guidance. An aligned pipette looks like this:  
   ![](./img/adjust-robot/adjust-pip-4.jpg)  
5. Repeat for every channel until all are within specification:  
   ![](./img/adjust-robot/adjust-pip-script-1.jpg)  
6. Click through dialogue boxes until the macro ends; values write to the STAR until the final step.

## Adjust Pip  
Using `adjust_pip.mcr`, an automated script writes Y and Z offsets for each pipette directly to the STAR, aligning them evenly. It begins on the left, prompts you to move the tool to the right, then back to the left. The final automated phase tests and fine‑adjusts every pipette and can take > 30 minutes. No user intervention is required.

## Check Pip  
Run `check_pip.mcr` to verify all pipettes remain in calibration after adjustments. This step is optional.



# Visualizer Architecture and Contributing

The PyLabRobot visualizer renders the state of a running protocol in a browser.
It is implemented as a lightweight web application served by the
{class}`~pylabrobot.visualizer.visualizer.Visualizer` class in Python.  The
visualizer itself does not perform any simulation logic; instead it receives
messages over a websocket from Python and passively updates the drawing.

This document gives an overview of how the visualizer is structured and where the
code lives so new contributors can quickly get started.

## File layout

The source lives in the :mod:`pylabrobot.visualizer` package:

```
pylabrobot/visualizer/
├── index.html            # entry point served to the browser
├── lib.js                # helper functions and resource definitions
├── vis.js                # websocket setup and event handling
├── main.css              # styling for the page
├── gif.js, gif.worker.js # GIF recording utilities
└── visualizer.py         # Python server component
```

The HTML/JS/CSS files make up a static web page.  The Python
:mod:`visualizer.visualizer` module exposes a :class:`Visualizer` class which
spins up two threads:

1. **File server** – a simple HTTP server that serves the static files above.
2. **Websocket server** – used to push state updates from Python to the browser.

When `Visualizer.setup()` is called, it launches both servers and optionally
opens a browser pointing to the file server.  As resources are assigned to the
root resource or their state changes, callbacks in Python send JSON messages to
the browser via the websocket.

## Browser side

The web page establishes a websocket connection when loaded.  Incoming messages
are dispatched in `vis.js` and update the Konva.js drawing.  The main events are:

- `set_root_resource` – initial resource tree sent when the connection is ready.
- `resource_assigned` / `resource_unassigned` – update the tree structure.
- `set_state` – update tracker state such as volumes or tip usage.

The JavaScript does not compute new state on its own; it simply renders what it
receives.

## Developing the visualizer

To work on the frontend, run a Python script that starts the
:class:`Visualizer` and open the provided URL in your browser.  Changes to the
HTML/JS/CSS files require a reload in the browser.  If you modify the Python
side you may need to restart the script.

Useful entry points are the examples in the user guide or the unit tests in
`pylabrobot/visualizer/visualizer_tests.py` which demonstrate typical usage.

Because communication happens over websockets, you can also drive the visualizer
from unit tests or scripts without a physical robot.  The
{class}`~pylabrobot.liquid_handling.backends.chatterbox.ChatterboxBackend` works
well for this purpose.

## Contributing tips

- Keep the Python server lightweight.  All rendering logic should stay in the
  JavaScript code.
- When sending new events from Python, add matching handlers in `vis.js` and
  document the payload format in comments.
- Try to keep the websocket protocol stable; update the
  `STANDARD_FORM_JSON_VERSION` if breaking changes are introduced.

If you have ideas for improvements or run into issues, feel free to open a topic
on the development forum before submitting a pull request.



# Contributor guide

```{toctree}
:maxdepth: 2
:caption: General

contributing
how-to-open-source
contributing-to-docs
```
<hr>

```{toctree}
:maxdepth: 2
:caption: Adding Backends/Drivers

new-machine-type
new-concrete-backend
```

<hr>

```{toctree}
:maxdepth: 2
:caption: Adding Resource Definitions

contributing-new-resources
```

<hr>

```{toctree}
:maxdepth: 2
:caption: Expanding the Visualizer/Simulator

visualizer
```

<hr>

```{toctree}
:maxdepth: 2
:caption: Adding to the Cookbook

adding-coookbook-recipes
```



# Contributing New Resources

PyLabRobot ships with a growing library of resource definitions for common labware.
If you define a new resource it helps the community when you contribute it back.
This page describes the information to include and how to format it.

```{attention}
PLEASE TEST YOUR RESOURCE DEFINITION BEFORE CONTRIBUTING!
```

## 1. Update the resource library

Add an entry for your resource under the appropriate manufacturer page in
{doc}`the resource library </resources/index>`.
List the part number, name, a picture and a link to the manufacturer's website.
Existing entries use a table format like this:

```
| Description | Image | PLR definition |
|-------------|-------|----------------|
| 'VWRReagentReservoirs25mL'<br>Part no.: 89094<br>[manufacturer website](https://us.vwr.com/store/product/4694822/vwr-disposable-pipetting-reservoirs)<br>Polystyrene Reservoirs | ![](img/vwr/VWRReagentReservoirs25mL.jpg) | `VWRReagentReservoirs25mL` |
```

Use the same style and folder structure for images.

If a section for your resource type (e.g. "Plates"/"Troughs"/etc.) already exists, add your resource to it. Add no new line between the rows.
If a section does not exist, create a new section (see other files for examples).

Please add an image of the resource to the `resources/library/img/<manufacturer>` folder.
The image should have the same name as the resource definition you will create.
The file type can be anything. Please compress and scale down the image to reduce its size (ideally below 100kB).

## 2. Document attribute sources

When writing a resource definition annotate each attribute with its origin.
Link any technical drawings you consulted using an archived copy for
permanence and mark those values with `# from spec`.
If you measured a value yourself append `# measured`.

````python
# example

def AGenBio_96_wellplate_Ub_2200ul(name: str, lid: Optional[Lid] = None) -> Plate:
 """
  AGenBio Catalog No. P-2.2-SQG-96
  - Material: Polypropylene
  - Max. volume: 2200 uL
  """
  INNER_WELL_WIDTH = 8  # measured
  INNER_WELL_LENGTH = 8  # measured

  well_kwargs = {
    "size_x": INNER_WELL_WIDTH,  # measured
    ...
  }

  return Plate(
    name=name,
    size_x=127.76,  # from spec
    size_y=85.48,  # from spec
    size_z=42.5,   # from spec
    ...
  )
````

## 3. Add imports

If you place your resource in a new module, remember to import it from the
package's `__init__.py` so users can load it directly.

Thank you for helping expand the resource library!

## 4. Submit a pull request

Once you have:
- [ ] added your resource to the library
- [ ] documented the sources of your attributes (measured, from spec, etc.)
- [ ] added the name, part number, link and image to the docs
- [ ] added the imports
- [ ] verified that your resource works as expected

You are ready to submit a pull request.

Please create a separate new pull request for each resource you add.
This makes it easier to review and faster to merge.



# Contributing to Docs

This document provides guidelines for contributing to the documentation.

## Images

When you include images, use the `resize.py` script to resize them to a width of 720 pixels and save them as compressed JPEGs. This ensures that images are optimized for web use. This helps reduce page load times and reduce total repo size.

```python
from PIL import Image
import sys
import os

def resize_image(input_path, output_path=None, width=720, quality=80):
  """
  Resize an image to the specified width while maintaining aspect ratio,
  then save it as a compressed JPEG for web use.
  """
  img = Image.open(input_path)

  if img.width > width:
    w_percent = width / float(img.width)
    height = int(img.height * w_percent)
    img = img.resize((width, height), Image.LANCZOS)
    print(f"Resized down to {width}x{height}")
  else:
    print(f"Skipping resize: image width ({img.width}px) <= target width ({width}px)")

  if img.mode in ("RGBA", "P"):
    img = img.convert("RGB")

  if output_path is None:
    base, _ = os.path.splitext(input_path)
    output_path = f"{base}_resized.jpg"

  img.save(output_path, "JPEG", quality=quality, optimize=True)
  print(f"Saved: {output_path} (quality={quality}%)")

if __name__ == "__main__":
  if len(sys.argv) < 2:
    print("Usage: python resize.py <input_path> [output_path]")
    sys.exit(1)
  inp = sys.argv[1]
  outp = sys.argv[2] if len(sys.argv) > 2 else None
  resize_image(inp, outp)
```

You can easily resize images in bulk using a bash script:

```bash
for img in *.png *.jpg; do
  python resize.py "$img"
done
```



# Contributing a New Recipe

This page explains how to contribute a new **Cookbook-Recipe** to PyLabRobot.
It is assumed you are already familiar with the general contributor workflow as outlined in the Contributor Guide (see [Contributing to PyLabRobot](https://docs.pylabrobot.org/contributor_guide/contributing.html)).

<hr>

## 1. Where to add the Recipe

1. Fork the repository and clone to your local machine, as per the usual workflow.
2. Navigate to your fork's documentation directory: `pylabrobot/docs/cookbook/recipes/`
3. Create a new Jupyter Notebook (recommended) for your recipe. For example:  
`star_movement_plate_to_alpaqua_core.ipynb`  
4. Ensure the notebook is self-contained (includes code, narrative, images, and outputs) and follows the style of existing recipes.

<hr>

## 2. Adding a Recipe Card to the Cookbook Page

Once your recipe notebook is ready and committed to `docs/cookbook/`, you must add an entry to the `pylabrobot/docs/cookbook/index.rst` file so that the recipe shows up on the website.
Add something like the following:

```rst
.. plrcard::
   :header: Move plate to Alpaqua magnet using CORE grippers
   :card_description: <ul>
      <li>Resource movement using CORE grippers</li>
      <li>Resource position check using grippers</li>
      <li>PLR autocorrection of plate placement onto PlateAdapter/magnet</li>
      </ul>
   :image: cookbook/assets/star_movement_plate_to_alpaqua_core/preview.png
   :image_hover: cookbook/assets/star_movement_plate_to_alpaqua_core/animation.mp4
   :link: star_movement_plate_to_alpaqua_core.html
   :tags: ResourceMovement PlateAdapter HamiltonSTAR
```

<details style="background-color:#f8f9fa; border-left:5px solid #007bff; padding:10px; border-radius:5px;">
   <summary style="font-weight: bold; cursor: pointer;"><code>plrcard</code> Legend </summary>
   <hr>
   <p> <code>:image:</code> is the static preview shown in the Cookbook grid.</p>
   <p> <code>:image_hover:</code> is the dynamic image or video displayed when hovering over the card.</p>
   <p>  Both paths are relative to the docs/ folder.</p>
</details>

<p></p>

Then, further down in the same index.rst, add the TOC reference:

```rst
.. -----------------------------------------
.. Page TOC
.. -----------------------------------------
.. toctree::
   :maxdepth: 2
   :hidden:

   recipes/star_movement_plate_to_alpaqua_core
```

Replace `star_movement_plate_to_alpaqua_core` with your recipe’s base name.

### 2.1 Add Preview Images or Hover Videos

Each recipe card displays a **static image** and an optional **hover image** (which may be an animated GIF or MP4 video).  
These preview files live in: `pylabrobot/docs/cookbook/assets/`

Follow these conventions:

- Name the files like this:
  - `preview.png`
  - `animation.gif` or `animation.mp4`
- Keep filenames lowercase and avoid spaces.
- Use JPG for static images.
- Use GIF (short animations) or MP4 (hover videos) for dynamic previews.
- Keep files optimized: < 100 kb per static image, < 5 MB per hover file.

When you commit, ensure both static and hover assets are included under `cookbook/assets/` in your PR.

<hr>

## 3. Adding New Tags (Optional)

**Tags** categorize Cookbook recipes by topic, device, or feature.  
They populate the filter buttons at the top of the Cookbook page, helping users quickly find related content - for example:  
- `ResourceMovement` (type of operation)  
- `HamiltonSTAR` (robot platform)
- `PlateAdapter` (PLR resource type)

If your recipe introduces a **new tag** (for example, `MagneticSeparation`), follow these steps:

1. Add the new tag to the `:tags:` line in your `plrcard` above.  
2. Open `pylabrobot/docs/_templates/plr_card_grid.html` and add a new filter button, for example:

   ```html
   <div class="plr-filter-btn" data-tag="MagneticSeparation">Magnetic Separation</div>

This ensures your new tag appears as a filterable button on the Cookbook cards grid.

<hr>

## 4. Checklist Before Submitting Your Pull Request

- The new notebook is located in `docs/cookbook/recipes/`.  
- You added a `plrcard` entry and a `toctree` reference to `index.rst`.  
- All image assets (e.g. `_static/cookbook_img/...`) are included and referenced correctly.  
- Any new tags are added to `plr_card_grid.html`. 

- Documentation builds without errors (`make docs`).  
- The notebook executes cleanly from start to finish.  
- PR title and description clearly describe your new recipe.  
- Linting, formatting, and typing checks pass:

```bash
make lint
make format-check
make typecheck
```
- Tests run successfully and coverage is unaffected.

<hr>

## 5. Example Pull Request

Example PR: [PR#726 Start PLR Cookbook](https://github.com/PyLabRobot/pylabrobot/pull/726/)

- Suppose you are adding the recipe file `star_movement_plate_to_alpaqua_core.ipynb`.
- Your PR would contain:
   - the recipe notebook: `docs/cookbook/recipes/star_movement_plate_to_alpaqua_core.ipynb`
   - image/video files such as `docs/_static/cookbook_img/recipe_01_core_move_static.png`, `recipe_01_core_move.mp4`.
   - Modifications to `docs/cookbook/index.rst` adding the card and TOC entry.
   - If relevant: Modification to `docs/_templates/plr_card_grid.html` to add new tag(s).
   - In the PR description mention something like: *“Add new Cookbook recipe: Move plate to Alpaqua magnet using CORE grippers (resources movement, gripper position check, placement correction).”*
   - Link to any relevant issue or discussion for context.

<hr>

## 6. Style Tips for Cookbook Recipes

- **Write clearly and narratively** – start with the recipe’s goal, list prerequisites (hardware, deck layout, robot backend), and describe the expected outcome.  
- **Combine code and explanation** – keep code cells short and follow them with brief commentary rather than large, unannotated blocks.  
- **Include visuals** – add static screenshots for deck layouts and optional GIF or MP4 animations to show motion or results.  
- **Use consistent section headings** – for example: *Prerequisites*, *Protocol Mode*, *Setup*, *Execution*, and *Variations*.  
- **Ensure smooth execution** – notebooks must run cleanly from start to finish without errors or manual input.  
- **Always include a simulation run** - recipes must support `protocol_mode == "simulation"` to allow a complete *in silico* execution of the automated protocol (aP) without errors, and remain valid when executed on actual hardware.  
- **Keep language accessible** – avoid hardware-specific jargon without context. Even if a recipe targets a particular machine (for example, `HamiltonSTAR`), write so readers unfamiliar with that platform can follow the logic.  
- **Be explicit about external dependencies** – if a recipe relies on components outside PyLabRobot (for example, third-party Python libraries, SDKs, or local data files), **document this clearly** in the *Prerequisites* section.  
- **Make recipes concise and complete** – each should be self-contained and reproducible, demonstrating a full automation concept without hidden dependencies.

<hr>

## 7. Questions & Support

For questions, feedback, or collaboration on Cookbook recipes - including structure, formatting, or contribution workflow - 
visit the community forum at [discuss.pylabrobot.org](https://discuss.pylabrobot.org).

<hr>

Thank you for helping expand the PyLabRobot Cookbook - concise, self-contained, and well-documented recipes are invaluable for both human developers and AI systems.  
They illustrate how to write complete, reproducible automation protocols and form the foundation for AI-assisted protocol generation.



# Adding Support for a New Machine of an Existing Type

This guide explains how to add support for a new machine of an existing type. For example, if you want to add support for a new liquid handler, you should read this guide. If you want to add support for a new type of machine, you should read {doc}`this guide <new-machine-type>` first.

The machine types that are currently can be found [here](/user_guide/machines).

Two documents that you can read before you start are:

- [CONTRIBUTING.md](https://github.com/PyLabRobot/pylabrobot/blob/main/CONTRIBUTING.md): This document contains general information about contributing to PyLabRobot, and covers things like installation and testing.
- [How to Open Source](https://docs.pylabrobot.org/how-to-open-source.html): This document contains step-by-step instructions for contributing to an open source project. It is not specific to PyLabRobot, and serves as a reference.

Thank you for contributing to PyLabRobot!

## Background

Backends are minimal classes that are responsible for communicating with a machine and are thus specific to one machine. Frontends are higher level classes that are responsible for orchestrating higher-level state and providing nice interfaces to users, and should work with any machine. For example, the STAR liquid handler backend is responsible for executing the liquid handling operations on a Hamilton STAR, while the LiquidHandler frontend is responsible for making sure a requested operation is valid given the current state of the deck.

Backends should contain minimal state. We prefer to manage the state in the frontend, because this allows us to share the code across all machines of a type. For example, the liquid handler backend does not contain any information about the deck, because this is managed by the frontend. If a certain machine has a specific state that needs to be managed, like whether the gripper arm is parked on a liquid handling robot, that should be done by the backend because it is specific to the machine.

## 0. Get in touch

Please make a post on [the PyLabRobot Development forum](https://discuss.pylabrobot.org) to let us know what you are working on. This will help you avoid duplicating work, and it is also a good place to get support.

## 1. Creating a new concrete backend class

It is easiest to start by copying the abstract base class for the machine type to a new file. You will find this in `backend.py` in the module for the machine type. For example, the liquid handling abstract base class is located at `pylabrobot.liquid_handling.backends.backend`. You should copy this file to a new file called `<machine_name>.py` in the same directory. For example, the liquid handling backend for the Hamilton STAR is located at `pylabrobot.liquid_handling.backends.hamilton.STAR`.

## 2. Implementing the abstract methods

The abstract base class contains a number of abstract methods. These are the methods that are expected to be implemented by the concrete backend. You should implement these methods in the concrete backend. You can use the abstract base class as a reference for what the methods should do.

PyLabRobot aims to be OS-agnostic, meaning that it should work on Windows, Mac, and Linux. This maximizes flexibility for users and the reproducibility of experiments. However, this also means that you should not use any OS-specific libraries or dlls in the backend.

If an operation is not supported by the machine, you should raise a `NotImplementedError`.

The actual process of implementing the methods varies widely from machine to machine. It is generally useful to search for firmware documents, search for log files generated by a manufacturer's software, or find other open source projects that have implemented the same machine.

## 3. Adding documentation (recommended)

Find the relevant module in the `docs` directory. For example, the liquid handling backends module is located at `docs/pylabrobot.liquid_handling.backends.rst`. Then, add the name of the new backend to make sure that the new backend is automatically documented in the API reference.

If you want, you can also add a new page to the `docs` directory that explains how to use the new backend. This is not required, but it is strongly recommended. Experience has shown that this is the best way to get people to actually use the new backend.



# Contributing to PyLabRobot

Thank you for your interest in contributing to PyLabRobot! This document will help you get started.

## Getting Started

See the installation instructions [here](../user_guide/_getting-started/installation.md). For contributing, you should install PyLabRobot from source.

If this is your first time contributing to open source, check out [How to Open Source](/contributor_guide/how-to-open-source.md) for an easy introduction.

It's highly appreciated by the PyLabRobot developers if you communicate what you want to work on, to minimize any duplicate work. You can do this on [discuss.pylabrobot.org](https://discuss.pylabrobot.org).

## Development Tips

It is recommend that you use VSCode, as we provide a workspace config in `/.vscode/settings.json`, but you can use any editor you like, of course.

Some VSCode Extensions I'd recommend:

- [Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python)
- [Typos Checker](https://github.com/tekumara/typos-lsp)
- [mypy](https://marketplace.visualstudio.com/items?itemName=matangover.mypy)

## Testing, linting, formatting

PyLabRobot uses `pytest` to run unit tests. Please make sure tests pass when you submit a PR. You can run tests as follows.

```bash
make test # run test on the latest version
```

`ruff` is used to lint and to enforce code style. The rc file is `/pyproject.toml`.

```bash
make lint
make format-check
```

Running the auto formatter:

```bash
make format
```

`mypy` is used to enforce type checking.

```bash
make typecheck
```

### Pre-commit hooks

PyLabRobot uses [pre-commit](https://pre-commit.com/) to run the above commands before every commit. To install pre-commit, run `pip install pre-commit` and then `pre-commit install`.

## Writing documentation

It is important that you write documentation for your code. As a rule of thumb, all functions and classes, whether public or private, are required to have a docstring. PyLabRobot uses [Google Style Python Docstrings](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html). In addition, PyLabRobot uses [type hints](https://docs.python.org/3/library/typing.html) to document the types of variables.

To build the documentation, run `make docs` in the root directory. The documentation will be built in `docs/_build/html`. Run `open docs/_build/html/index.html` to open the documentation in your browser.

## Common Tasks

### Fixing a bug

Bug fixes are an easy way to get started contributing.

Make sure you write a test that fails before your fix and passes after your fix. This ensures that this bug will never occur again. Tests are written in `<filename>_tests.py` files. See [Python's unittest module](https://docs.python.org/3/library/unittest.html) and existing tests for more information. In most cases, adding a few additional lines to an existing test should be sufficient.

### Adding resources

If you have defined a new resource, it is highly appreciated by the community if you add them to the repo. In most cases, a [partial function](https://docs.python.org/3/library/functools.html#functools.partial) is enough. There are many examples, like [tipracks.py](https://github.com/PyLabRobot/pylabrobot/blob/main/pylabrobot/liquid_handling/resources/hamilton/tipracks.py). If you are writing a new kind of resource, you should probably subclass resource in a new file.

Make sure to add your file to the imports in `__init__.py` of your resources package.

### Writing a new backend

Backends are the primary objects used to communicate with hardware. If you want to integrate a new piece of hardware into PyLabRobot, writing a new backend is the way to go. Here's, very generally, how you'd do it:

1. Copy the `pylabrobot/liquid_handling/backends/backend.py` file to a new file, and rename the class to `<BackendName>Backend`.
2. Remove all `abc` (abstract base class) imports and decorators from the class.
3. Implement the methods in the class.

## Support

If you have any questions, feel free to reach out using the [PyLabRobot forum](https://discuss.pylabrobot.org).



# Contributing a New Type of Machine to PLR

PyLabRobot supports a number of different types of machines. They can be found [here](/user_guide/machines).

If you want to add support for a new type of machine, this guide will explain the process. If you want to add a new machine for a type that already exists, you should read {doc}`this guide <new-concrete-backend>` instead.

This guide is not a definitive step-by-step guide (otherwise we would have automated it), but rather a collection of high-level ideas and suggestions. Often, it only becomes clear what the best abstractions are after two or more machines for a type have been implemented, so it is totally valid (and encouraged) to make some assumptions and then refactor later.

Two documents that you can read before you start are:

- [CONTRIBUTING.md](https://github.com/PyLabRobot/pylabrobot/blob/main/CONTRIBUTING.md): This document contains general information about contributing to PyLabRobot, and covers things like installation and testing.
- [How to Open Source](https://docs.pylabrobot.org/how-to-open-source.html): This document contains step-by-step instructions for contributing to an open source project. It is not specific to PyLabRobot, and serves as a reference.

Thank you for contributing to PyLabRobot!

## 0. Get in touch

Please make a post on [the PyLabRobot Development forum](https://discuss.pylabrobot.org) to let us know what you are working on. This will help you avoid duplicating work, and it is also a good place to get support.

## 1. Creating a new module

Each machine type has its own module in PLR. For example, the liquid handling module is located at `pylabrobot.liquid_handling`. This module contains:

- the machine front end: the user-facing API for the machine type. Example: `LiquidHandler`.
- the abstract base class for the machine type: the minimal set of atomic commands that the machine type is expected to support. Example: `LiquidHandlerBackend`.
- the concrete backends: the actual implementations of the abstract base class for specific machines. See {doc}`the concrete backends guide <new-concrete-backend>` for more information. Example: `STAR`.

## 2. Creating a new abstract backend class

Abstract backends are used to define the interface for a type of machine in terms of the minimal set of atomic commands. For example, all liquid handlers should have an `aspirate` method.

The commands should be interactive and minimal. Interactive means that the command is expected to be executed immediately when its method is called. Minimal means the commands cannot be broken into sub-commands that a user would reasonably want to use. For example, the abstract liquid handler backend contains commands for `aspirate` and `dispense`, but not `transfer` (a convenience method that exists on the frontend). At the same time, `aspirate` does move the pipetting head to a certain location because this move and the actual aspiration are reasonably expected to always occur together. For new machines, it is fine to make some assumptions and revisit them later.

The purpose of minimality is to make adding new concrete backends as easy as possible. The purpose of interactivity is to make the iteration cycle when developing new methods as short as possible.

You must put the abstract base class in `backend.py` in the module you created in step 1. The abstract class {class}`~pylabrobot.machine.MachineBackend` must be used as the base class for all backends. This class defines the `setup` and `stop` methods, which are used to initialize and stop the machine.

## 3. Creating a new front end class

Front ends are used to define the user-facing interface for a specific machine type, and shared across all machines of this type in PLR. They expose the atomic backend commands in addition to providing higher level utilities and orchestrating state. For example, `LiquidHandler` has a `transfer` method that is not defined in the abstract backend (it is not minimal), but instead simply calls `aspirate` and `dispense` on the backend. This way, the `transfer` implementation is shared across all supported liquid handling robots. `LiquidHandler` also maintains a reference to the deck, to make sure the requested operations are valid given the current state of the deck.

The abstract class {class}`~pylabrobot.machine.MachineFrontend` must be used as the base class for all front ends. This class defines the `setup` and `stop` methods, which are used to initialize and stop the machine. It also defines the `backend` attribute, which is used to access the backend.

You should put the front end in a file called `<machine_type>.py` in the module you created in step 1. For example, the liquid handling front end is located at `pylabrobot.liquid_handling.liquid_handler.py`.

If your devices updates the resource tree or its state, the front end should handle this. See [the resources guide](/resources/introduction.md) for more information.

## 4. Creating a new concrete backend for a specific machine

Refer to the {doc}`the concrete backends guide <new-concrete-backend>`.

## 5. Adding documentation (strongly recommended)

Each module should have a corresponding documentation page in the `docs` directory. Experience has shown that this is the best way to get people to actually use the new module.

### API documentation

API documentation is generated automatically based on docstrings, but has to be linked to from the main API documentation.

1. Create a new file in the `docs` directory called `pylabrobot.<module_name>.rst`. You can look at the existing files for examples.
2. Add a link to this file to the API documentation in [`docs/pylabrobot.rst`](https://github.com/PyLabRobot/pylabrobot/blob/main/docs/pylabrobot.rst).

### Brief introduction

It is also recommended to add a brief introduction to the module which explains what it is and how to use it. You can write this introduction in Markdown, reStructuredText, or a Jupyter notebook (recommended). You can look at [`basic.ipynb`](https://github.com/PyLabRobot/pylabrobot/blob/main/docs/basic.ipynb) for an example.

1. Put the introduction in the `docs` folder.
2. Link to the new file from [`docs/index.rst`](https://github.com/PyLabRobot/pylabrobot/blob/main/docs/index.rst).



# How to Open Source

This is a general guide on how to contribute to open source projects, like PyLabRobot, for people who are new to open source. If you are looking for a tutorial on how to contribute specifically to PyLabRobot, please see [CONTRIBUTING.md](https://github.com/PyLabRobot/pylabrobot/blob/main/CONTRIBUTING.md). You are invited to follow along with this guide and create your first contribution to PyLabRobot!

Before we start, I recommend you use a git gui, like [GitHub Desktop](https://desktop.github.com/), [Tower](https://www.git-tower.com), or the one built into [VSCode](https://code.visualstudio.com). **While command line commands are included in this guide, it is generally much easier to just use the gui.** This guide will use GitHub Desktop as an example, so if you have never contributed to open source before, start by installing [GitHub Desktop](https://desktop.github.com).

_If you just want to make a small changes, like fixing a typo, check out {ref}`this section <quick-changes>`._

## Prerequisites

- A GitHub account. If you don't have one, you can create one [here](https://github.com/signup)
- Git installed on your computer. If you don't have it, you can download it [here](https://git-scm.com/downloads).
- Recommended: a git gui.

## The 8 step workflow

This 8 step workflow is the general process for contributing to open source projects.

### 1. Forking a Project

Forking a project is just making a copy of the project on your own GitHub account. This is done by clicking the "Fork" button in the top right of [the project's GitHub page](https://github.com/pylabrobot/pylabrobot).

![Forking a project](img/how-to-os/fork-0.png)

Then click "Create fork".

![Forking a project](img/how-to-os/fork-1.png)

### 2. Cloning a Project

Cloning a project means downloading the project to your computer. This is done by clicking "Clone a Repository from the Internet..." in GitHub Desktop.

![Cloning a project](img/how-to-os/clone-0.png)

Then click "URL" and paste the URL of your forked project. Then click "Clone".

![Cloning a project](img/how-to-os/clone-1.png)

```bash
git clone https://github.com/<your-username>/pylabrobot.git
```

### 3. Creating a Branch

A branch is just a copy of the project that you can make changes to without affecting the main project. This is done by clicking the "Current branch" button in the top left of the GitHub Desktop window, and then clicking "New branch".

![Creating a branch](img/how-to-os/branch-0.png)
![Creating a branch](img/how-to-os/branch-1.png)

Then type in a name for your branch, and click "Create branch".

![Creating a branch](img/how-to-os/branch-2.png)

Branches are useful because you can have multiple branches, each with different changes. This is useful if you want to make multiple changes to a project, but you don't want to submit them all at once. You can submit each branch as a separate pull request.

```bash
git checkout -b <branch-name>
```

### 4. Making Changes

Now that you have a copy of the project on your computer, you can make changes to it. You can use any editor you like, but I recommend [VSCode](https://code.visualstudio.com/).

### 5. Committing Changes

Committing changes is just saving your changes to your local copy of the project. Select all files you changed and want to commit (this is a good time to go over your changes!). Write a short description in the bottom left of the GitHub Desktop window. Then click "Commit to \<branch-name\>".

![Committing changes](img/how-to-os/commit-0.png)

```bash
git add .
git commit -m "A short description"
```

Optionally, if your contribution consists of multiple parts, you can go back to step 4 and make some more changes. This can make it easier to track why changes are made. Keep in mind that PRs should be self contained and not too large. Aim for 1-3 commits and <300 lines of code per PR.

### 6. Pushing Changes

After you commit your changes, you need to push them to your forked copy of the project on GitHub. This is done by clicking the "Publish branch" button in the top left of the GitHub Desktop window. If you have pushed commits from this branch before, select "Push origin".

![Pushing changes](img/how-to-os/push-0.png)

```bash
git push origin <branch-name>
```

### 7. Creating a Pull Request

After you push your changes, you need to submit a pull request. This is done by going back to your browser and refreshing the page. You should see a button that says "Compare & pull request".

![Creating a pull request](img/how-to-os/pull-0.png)

Please write a short description of your changes and click "Create pull request".

![Creating a pull request](img/how-to-os/pull-1.png)

### 8. Code Review

After you submit a pull request, the project maintainers will review your code. They may ask you to make changes, or they may merge your pull request. Go to step 4 and repeat the process until the merge!

(quick-changes)=

## Quick changes

If your changes are small, you can do everything in the GitHub web interface. This is useful if you are fixing a typo in the code or documentation.

_Hint: If you are fixing a typo in the documentation, there is an edit button at the top right of every page. That button can be used instead of step 1 in this guide._

### 1. Clicking edit

Navigate to the file you want to edit, and click the edit button.

![Clicking edit](img/how-to-os/quick-0.png)

### 2. Making changes

Make your changes in the text editor.

![Editing a file](img/how-to-os/quick-1.png)

### 3. Committing changes

After you make your changes, you need to commit them.

Go to "Preview changes" to review your changes. Then write a good commit message and click "Commit changes".

![Committing changes](img/how-to-os/quick-2.png)

### 4. Creating a pull request

After you commit your changes, you need to submit a pull request. This is done by clicking "Create pull request".

![Creating a pull request](img/how-to-os/quick-3.png)

Optionally, you can add a description of your changes. Then click "Create pull request".

![Creating a pull request](img/how-to-os/quick-4.png)

## Support

If you have any questions, feel free to reach out using the [PyLabRobot forum](https://discuss.pylabrobot.org).



# MFXCarrier

MFX Carriers are a user-configurable carrier system, created by Hamilton. The user can configure the carrier system by placing plate sites, tip racks, tilt modules and other items at specific locations by screwing them into pre-threaded holes in the carrier. Different carrier bases are available.

In this tutorial, we will show how to create a custom carrier system using the MFX Carriers in PyLabRobot. We will use the `MFX_CAR_L5_base` as the base, and a deep well plate module (`MFX_DWP_rackbased_module`) and a tip module (`MFX_TIP_module`) as the modules.


```python
%load_ext autoreload
%autoreload 2
```


```python
from pylabrobot.resources import (
  MFX_CAR_L5_base,
  MFX_DWP_rackbased_module,
  MFX_TIP_module,
)
```

Start by creating variables for your mfx modules. Depending on the type of module, the class might be a {class}`pylabrobot.resources.resource_holder.ResourceHolder` (for tip rack holders), a {class}`pylabrobot.resources.carrier.PlateHolder` (for plate modules), or a `Machine` class.

Let's create plate and a tip rack modules:


```python
my_plate_module = MFX_DWP_rackbased_module(name="my_plate_module")
my_plate_module
```




    PlateHolder(name=my_plate_module, location=None, size_x=135.0, size_y=94.0, size_z=59.80500000000001, category=plate_holder)




```python
my_tip_rack_module = MFX_TIP_module(name="my_tip_rack_module")
my_tip_rack_module
```




    ResourceHolder(name=my_tip_rack_module, location=None, size_x=135.0, size_y=94.0, size_z=96.60500000000002, category=resource_holder)



Using a dictionary, you can place your mfx modules in arbitrary locations:


```python
carrier = MFX_CAR_L5_base(
  name="my_carrier",
  modules={
    0: my_plate_module,
    3: my_tip_rack_module,
  }
)
```

    {0: PlateHolder(name=my_plate_module, location=(000.000, 005.000, 018.195), size_x=135.0, size_y=94.0, size_z=59.80500000000001, category=plate_holder), 3: ResourceHolder(name=my_tip_rack_module, location=(000.000, 293.000, 018.195), size_x=135.0, size_y=94.0, size_z=96.60500000000002, category=resource_holder)}


The children of an MFXCarrier are the sites you specified when creating the carrier.


```python
carrier[0]
```




    PlateHolder(name=carrier-my_carrier-spot-0, location=(000.000, 005.000, 018.195), size_x=135.0, size_y=94.0, size_z=59.80500000000001, category=plate_holder)




```python
carrier[3]
```




    ResourceHolder(name=carrier-my_carrier-spot-3, location=(000.000, 293.000, 018.195), size_x=135.0, size_y=94.0, size_z=96.60500000000002, category=resource_holder)



When a site is not defined, indexing into it will raise a `KeyError`.


```python
try:
  carrier[1]
except KeyError as e:
  print(f"KeyError, as expected.")
```

    KeyError, as expected.


To define in PLR that there is a plate on some module in the carrier, you can assign a plate to that module using the usual `assign_child_resource` method.


```python
from pylabrobot.resources import Cos_96_wellplate_2mL_Vb
my_plate = Cos_96_wellplate_2mL_Vb(name="my_plate")
carrier[0].assign_child_resource(my_plate)
my_plate.parent
```




    PlateHolder(name=carrier-my_carrier-spot-0, location=(000.000, 005.000, 018.195), size_x=135.0, size_y=94.0, size_z=59.80500000000001, category=plate_holder)



As with other carriers, you can also assign it directly to the site using the following syntax:


```python
from pylabrobot.resources import hamilton_96_tiprack_1000uL_filter
my_tip_rack = hamilton_96_tiprack_1000uL_filter(name="my_tip_rack")
carrier[3] = my_tip_rack
my_tip_rack.parent
```




    ResourceHolder(name=carrier-my_carrier-spot-3, location=(000.000, 293.000, 018.195), size_x=135.0, size_y=94.0, size_z=96.60500000000002, category=resource_holder)





# PlateCarrier

Plate carriers slide into rails on railed-decks like Hamilton STAR(let) and Tecan EVO, and are used to hold Plates.

## Using a plate carrier

The PyLabRobot Resource Library (PLR-RL) has a big number of predefined carriers. You can find these in the [PLR-RL docs](https://docs.pylabrobot.org/resources/index.html). [Hamilton Plate Carriers](https://docs.pylabrobot.org/resources/library/ml_star.html#plate-carriers) may be of particular interest.


```python
from pylabrobot.resources.hamilton import PLT_CAR_L5AC_A00
```


```python
my_plate_carrier = PLT_CAR_L5AC_A00(name="my_plate_carrier")
my_plate_carrier.capacity
```




    5



To assign a plate at a specific location in the plate carrier, simply set it at a specific index. In PLR, carriers are 0-indexed where the site at the front of the robot (nearest to the door) is 0.


```python
from pylabrobot.resources import Cor_96_wellplate_360ul_Fb

my_plate = Cor_96_wellplate_360ul_Fb(name="my_plate")
my_plate_carrier[0] = my_plate
```

You can assign plates to a variable and to the carrier in a single line.


```python
my_plate_carrier[1] = my_other_plate = Cor_96_wellplate_360ul_Fb(name="my_other_plate")
```

The children (in the arborescence) of a plate carrier are {class}`pylabrobot.resources.carrier.PlateHolder` objects. These model the sites for plates on the carrier. A `PlateHolder` may or may not have a `Plate` as a child, depending on whether the spot is occupied.


```python
my_plate_carrier[0]
```




    PlateHolder(name=my_plate_carrier-0, location=Coordinate(004.000, 008.500, 086.150), size_x=127.0, size_y=86.0, size_z=0, category=plate_holder)




```python
my_plate.parent
```




    PlateHolder(name=my_plate_carrier-0, location=Coordinate(004.000, 008.500, 086.150), size_x=127.0, size_y=86.0, size_z=0, category=plate_holder)



You can use the `PlateHolder.resource` attribute to access the `Plate` object, if it exists.


```python
my_plate_carrier[0].resource
```




    Plate(name=my_plate, size_x=127.76, size_y=85.48, size_z=14.2, location=Coordinate(000.000, 000.000, -03.030))




```python
my_plate_carrier[2].resource is None
```




    True



### Moving plates onto carrier sites

If your liquid handling robot has a robotic arm, or if you are using an external robot arm that can interface with carriers, you can move plates out of or onto carriers using the `move_plate` method. For this, you can specify the destination by indexing into the carrier. This will return a `PlateHolder` object.

As an example, we will use the LiquidHandlerChatterboxBackend, but this code will work on any robot that supports moving plates.


```python
from pylabrobot.liquid_handling import LiquidHandler, LiquidHandlerChatterboxBackend
from pylabrobot.resources import STARDeck
lh = LiquidHandler(backend=LiquidHandlerChatterboxBackend(), deck=STARDeck())
lh.deck.assign_child_resource(my_plate_carrier, rails=1)
await lh.setup()
```

    Resource my_plate_carrier was assigned to the liquid handler.
    Setting up the liquid handler.
    Resource deck was assigned to the liquid handler.
    Resource trash was assigned to the liquid handler.
    Resource trash_core96 was assigned to the liquid handler.
    Resource teaching_carrier was assigned to the liquid handler.
    Resource my_plate_carrier was assigned to the liquid handler.



```python
await lh.move_resource(my_plate, my_plate_carrier[2])
```

    Picking up resource: ResourcePickup(resource=Plate(name=my_plate, size_x=127.76, size_y=85.48, size_z=14.2, location=Coordinate(000.000, 000.000, -03.030)), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=0, direction=<GripDirection.FRONT: 1>)
    Dropping resource: ResourceDrop(resource=Plate(name=my_plate, size_x=127.76, size_y=85.48, size_z=14.2, location=Coordinate(000.000, 000.000, -03.030)), destination=Coordinate(x=104.0, y=263.5, z=183.12), destination_absolute_rotation=Rotation(x=0, y=0, z=0), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=0, pickup_direction=<GripDirection.FRONT: 1>, drop_direction=<GripDirection.FRONT: 1>, rotation=0)
    Resource my_plate was unassigned from the liquid handler.
    Resource my_plate was assigned to the liquid handler.




# Tutorial: Plate Quadrants

<div style="background-color:#f8f9fa; border-left:5px solid #007bff; padding:10px;">
    <strong>Note:</strong> This notebook can be downloaded and used directly.
</div>

In many automated protocols liquid transfers have to be performed between different plate formats, e.g.: between 96-wellplate to 24-wellplates, or between 384-wellplates to 96-wellplates.

To facilitate these liquid transfers, PLR standardized the definition of `Plate` "Quadrants" and enables dynamically accessing these quadrants to generate complex transfer pipetting patterns with ease:

```python
Plate_instance.get_quadrant(
    quadrant: Literal[
      "tl", "top_left",
      "tr", "top_right",
      "bl", "bottom_left",
      "br", "bottom_right"
    ],
    quadrant_type: Literal["block", "checkerboard"] = "checkerboard",
    quadrant_internal_fill_order: Literal["column-major", "row-major"] = "column-major",
  ) -> List["Well"]
```


---

## Attribute Explanations
### Quadrant Type
Depending on 1) manual vs fully-automated processing, and 2) y-channel spacing ability, two common definitions for “quadrant types” are:

- **“block”**
    - division of plate into 4 zones based on the plate’s 2 symmetric axes
- **“checkerboard”**
    - division of plate into 4 zones based on using every other row + every other column


```{image} ./img/250304_explainer_quadrants_96.jpg
:width: 500px
:align: center

```{image} ./img/250304_explainer_quadrants_384.jpg
:width: 500px
:align: center

### Quadrant identifiers
To extract a specific quadrant we simply call the relative position of the desired quadrant, relative to the `Plate` origin / front-left-bottom:

```{image} ./img/250304_explainer_quadrant_identifiers.jpg
:width: 500px
:align: center

### Fill Order
All matrices, including plates, can be filled in two different orders:

- **"row-major" order** (row-wise filling)
   - Filling proceeds across a row before moving to the next row.
   - Mostly used by manual handling of plates.
- **"column-major" order** (column-wise filling)
   - Filling proceeds down a column before moving to the next column.
   - Common standard in robotic handling of plates due to parallelization opportunity of liquid transfer actions in the same x-coordinate(–> massive temporal acceleration)

```{image} ./img/250304_explainer_fill_order.jpg
:width: 500px
:align: center

## Examples


Start by creating a minimal deck in simulation mode:


```python
from pylabrobot.resources import (
  Cor_6_wellplate_16800ul_Fb,
  CellVis_24_wellplate_3600uL_Fb,
  Thermo_TS_96_wellplate_1200ul_Rb,
  Revvity_384_wellplate_28ul_Ub
)

example_6_wellplate = Cor_6_wellplate_16800ul_Fb(name="example_6_wellplate")
example_24_wellplate = CellVis_24_wellplate_3600uL_Fb(name="example_24_wellplate")
example_96_wellplate = Thermo_TS_96_wellplate_1200ul_Rb(name="example_96_wellplate")
example_384_wellplate = Revvity_384_wellplate_28ul_Ub(name="example_384_wellplate")
```

### "checkerboard" + "column-major" (default)


```python
example_24_wellplate.get_quadrant(
  quadrant="tl",
  quadrant_type="checkerboard",  # default
  quadrant_internal_fill_order="column-major"  # default
)
```




    [Well(name=example_24_wellplate_well_0_0, location=Coordinate(009.280, 063.800, 000.750), size_x=15.54, size_y=15.54, size_z=19, category=well),
     Well(name=example_24_wellplate_well_0_2, location=Coordinate(009.280, 025.200, 000.750), size_x=15.54, size_y=15.54, size_z=19, category=well),
     Well(name=example_24_wellplate_well_2_0, location=Coordinate(047.880, 063.800, 000.750), size_x=15.54, size_y=15.54, size_z=19, category=well),
     Well(name=example_24_wellplate_well_2_2, location=Coordinate(047.880, 025.200, 000.750), size_x=15.54, size_y=15.54, size_z=19, category=well),
     Well(name=example_24_wellplate_well_4_0, location=Coordinate(086.480, 063.800, 000.750), size_x=15.54, size_y=15.54, size_z=19, category=well),
     Well(name=example_24_wellplate_well_4_2, location=Coordinate(086.480, 025.200, 000.750), size_x=15.54, size_y=15.54, size_z=19, category=well)]



For simplified inspection, we can call `.get_identifier()` on each Well instance returned:


```python
print([well.get_identifier() for well in example_96_wellplate.get_quadrant(
    quadrant="tl",
    quadrant_type = "checkerboard",  # default
    quadrant_internal_fill_order = "column-major"  # default
)])
```

    ['A1', 'C1', 'E1', 'G1', 'A3', 'C3', 'E3', 'G3', 'A5', 'C5', 'E5', 'G5', 'A7', 'C7', 'E7', 'G7', 'A9', 'C9', 'E9', 'G9', 'A11', 'C11', 'E11', 'G11']


### "checkerboard" + "row-major"


```python
print([well.get_identifier() for well in example_96_wellplate.get_quadrant(
  quadrant="tl",
  quadrant_type = "checkerboard", # Literal["block", "checkerboard"]
  quadrant_internal_fill_order = "row-major" # Literal["column-major", "row-major"]
)])
```

    ['A1', 'A3', 'A5', 'A7', 'A9', 'A11', 'C1', 'C3', 'C5', 'C7', 'C9', 'C11', 'E1', 'E3', 'E5', 'E7', 'E9', 'E11', 'G1', 'G3', 'G5', 'G7', 'G9', 'G11']


### "block" + "column-major"


```python
print([well.get_identifier() for well in example_96_wellplate.get_quadrant(
  quadrant="tl",
  quadrant_type = "block",
  quadrant_internal_fill_order = "column-major"
)])
```

    ['A1', 'B1', 'C1', 'D1', 'A2', 'B2', 'C2', 'D2', 'A3', 'B3', 'C3', 'D3', 'A4', 'B4', 'C4', 'D4', 'A5', 'B5', 'C5', 'D5', 'A6', 'B6', 'C6', 'D6']


### "block" + "row-major"


```python
print([well.get_identifier() for well in example_96_wellplate.get_quadrant(
    quadrant="tl",
    quadrant_type = "block", # Literal["block", "checkerboard"]
    quadrant_internal_fill_order = "row-major" # Literal["column-major", "row-major"]
)])
```

    ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6']




# ResourceStack

`ResourceStack` represents a collection of resources stacked together into a single
resource. It can grow along the x, y or z axis. This is useful when you want to
treat multiple resources as a single unit, for instance stacking lids vertically or
arranging plates side by side before placing them on the deck.

Because the stack is itself a `Resource`, it can be assigned to other resources or
the deck like any other labware. When the stack grows along the z-axis it behaves
like a traditional *stack* where items are added and removed from the top.

Below we demonstrate creating stacks in different orientations and interacting with
them.


```python
from pylabrobot.resources import Resource, Plate, Lid, Coordinate
from pylabrobot.resources import ResourceStack
```

## Creating an empty stack
Pass the name and direction of growth (`"x"`, `"y"`, or `"z"`).


```python
stack_x = ResourceStack("stack_x", "x")
stack_y = ResourceStack("stack_y", "y")
stack_z = ResourceStack("stack_z", "z")
(stack_x.children, stack_y.children, stack_z.children)
```




    ([], [], [])



## Stacking resources at construction time
You can also supply a list of resources which will be assigned immediately.


```python
stack = ResourceStack(
    "stack",
    "x",
    [
        Resource("A", size_x=10, size_y=10, size_z=10),
        Resource("B", size_x=10, size_y=10, size_z=10),
    ],
)
([child.name for child in stack.children], stack.get_size_x())
```




    (['A', 'B'], 20)



The total size along the x-axis equals the sum of the children sizes.


```python
stack_y2 = ResourceStack(
    "stack_y2",
    "y",
    [
        Resource("A", size_x=10, size_y=10, size_z=10),
        Resource("B", size_x=10, size_y=10, size_z=10),
    ],
)
stack_y2.get_size_y()
```




    20



## Adding and removing items
New items are positioned automatically at the edge returned by
`get_resource_stack_edge()`. When stacking in the z direction you can only remove
the current top item.


```python
lid1 = Lid(name="L1", size_x=10, size_y=10, size_z=5, nesting_z_height=1)
lid2 = Lid(name="L2", size_x=10, size_y=10, size_z=5, nesting_z_height=1)
stack_z.assign_child_resource(lid1)
stack_z.assign_child_resource(lid2)
stack_z.get_top_item().name
```




    'L2'




```python
stack_z.unassign_child_resource(lid2)
stack_z.get_top_item().name
```




    'L1'



Attempting to remove `lid1` now would raise a `ValueError` because it is not the
top item in this z-growing stack.

## Using a ResourceStack as a stacking area
A common use case is stacking plates next to a reader or washer. After placing a
plate on the stack you can retrieve it again using `get_top_item()`.


```python
plate = Plate("p1", size_x=1, size_y=1, size_z=1, ordered_items={})
stacking_area = ResourceStack("stacking_area", "z")
stacking_area.assign_child_resource(plate)
stacking_area.get_top_item() is plate
```




    True



When using a :class:`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler` the
stack behaves just like any other resource:

```python
lh.move_plate(stacking_area.get_top_item(), plate_carrier[0])
```

This allows temporary storage of plates or lids during automated workflows.



# PlateAdapter

`PlateAdapter` represents accessories that hold plates while providing a
standardized grid of holes or wells. It is useful when a plate cannot be placed
directly on a carrier site because the skirt or dimensions do not match the
standard ANSI/SLAS format. Examples include magnetic racks, heater shakers or
adapters for semi-skirted PCR plates.

By treating adapters as resources, PyLabRobot can automatically compute the
position of the plate relative to the adapter. This ensures wells line up with
the adapter holes while keeping a simple API for moving plates around.

In most workflows you create an adapter and then assign a plate to it.

## Creating a PlateAdapter

You can instantiate a `PlateAdapter` directly by specifying its size and the
layout of its holes. The example below creates a simplified magnetic rack for a
96 well plate.


```python
from pylabrobot.resources.plate_adapter import PlateAdapter

magnet = PlateAdapter(
    name="magnet",
    size_x=127.76,
    size_y=85.48,
    size_z=35.0,
    dx=9.8,
    dy=6.8,
    dz=27.5,  # height of the plate above the deck
    adapter_hole_size_x=8.0,
    adapter_hole_size_y=8.0,
    adapter_hole_size_z=8.0,
)
magnet
```

## Placing a plate on an adapter

`PlateAdapter.assign_child_resource()` automatically aligns the plate's wells
with the adapter holes. This uses `compute_plate_location()` internally.
Below we place a Corning 96 well plate on our magnetic rack.


```python
from pylabrobot.resources.corning import Cor_96_wellplate_2mL_Vb

plate = Cor_96_wellplate_2mL_Vb(name="plate")
magnet.assign_child_resource(plate)
magnet.children
```

`compute_plate_location()` can also be called directly to see where the plate
will be positioned relative to the adapter.


```python
magnet.compute_plate_location(plate)
```



# ResourceHolder

`ResourceHolder` is a mixin class for resources that can hold exactly one other
resource. Examples include the sites of plate carriers which hold a single
plate, or the docking position of a module that accepts one plate or trough.

`ResourceHolder` ensures that the child resource is placed correctly inside the
holder. When the holder is rotated the child resource is automatically shifted
so that its local origin lines up with the correct corner of the holder. This
avoids having to manually adjust coordinates for every rotation.

For `ResourceHolder`s that hold plates, use the `PlateHolder` subclass instead.

```{toctree}
plate-holder
```

## Why use a ResourceHolder?

Many pieces of labware are designed to accommodate another resource at a
fixed position. A `PlateHolder` inside a carrier for example always contains
exactly one plate. The `ResourceHolder` abstraction models this behaviour.
It guarantees that only one resource is assigned at a time and exposes
convenient methods to work with the contained resource.

By subclassing from `ResourceHolder` your own holder classes immediately gain
these behaviours without duplicating logic.

## Basic usage


```
from pylabrobot.resources import Resource, ResourceHolder

holder = ResourceHolder(name="holder", size_x=100, size_y=80, size_z=10)
plate  = Resource(name="plate", size_x=100, size_y=80, size_z=15)

holder.assign_child_resource(plate)
holder.resource.name
```

After assignment the `resource` property returns the held item.


```
holder.resource is plate
```

## Custom child location

By default the child is positioned at the holder's origin. You can offset this
by passing ``child_location`` when constructing the holder.


```
from pylabrobot.resources import Coordinate

offset_holder = ResourceHolder(
    name="offset_holder",
    size_x=100,
    size_y=80,
    size_z=10,
    child_location=Coordinate(x=10, y=5, z=0),
)
lid = Resource(name="lid", size_x=95, size_y=75, size_z=5)
offset_holder.assign_child_resource(lid)
offset_holder.resource.location
```



# Byonoy Luminescence 96 Automate

- [OEM Link](https://byonoy.com/luminescence-automate/)
- **Communication Protocol / Hardware:** HID / USB-A/C
- **Communication Level:** Firmware
- VID:PID `16d0:119b`
- Takes a single SLAS-format 96-wellplate on the base unit, enables movement of the reader unit over it, and reads all 96 wells simultaneously.

---
## Setup Instructions (Physical)

The Byonoy Luminescence 96 Automate (L96A) is a luminescence plate reader consisting of...
1. a `base_unit` which holds the plate,
2. a `reader_unit` containing the light sensors that sits on top of the base unit.

### Communication
It requires only one cable connection to be operational:
1. USB cable (USB-C at `reader_unit` end; USB-A at control PC end)

---
## Setup Instructions (Programmatic)


```python
%load_ext autoreload
%autoreload 2
```


```python
from pylabrobot.plate_reading.byonoy import byonoy_l96a
```


```python
base_unit, reader_unit = byonoy_l96a("Luminescence96 Automate")
reader_unit
```




    ByonoyLuminescence96Automate(name='Luminescence96 Automate_reader', location=Coordinate(000.000, 000.000, 006.300), size_x=138, size_y=97.5, size_z=41.7, category=plate_reader)




```python
await reader_unit.setup()
```

### Measure Luminescence

Before you can do a plate reading measurement in PLR, you need to assign a plate to the reader.


```python
from pylabrobot.resources.corning.plates import Cor_96_wellplate_360ul_Fb
demo_plate = Cor_96_wellplate_360ul_Fb(name="plate")
```


```python
reader_unit.assign_child_resource(demo_plate)
```


```python
data = await reader_unit.read_luminescence(
  focal_height=1,
  use_new_return_type=True,
)

print(f"Time: {data[0]['time']}")
print(f"Temperature: {data[0]['temperature']}")
print("Data")
print(data[0]['data'])
```

    Time: 1770236622.314785
    Temperature: None
    Data
    [[200552272.0, 201907664.0, 218108208.0, 234161952.0, 251950976.0, 8104904.0, 1781678.0, 1690456.0, 2708988.0, 2377269.0, 5855379.0, 289570432.0], [183959648.0, 183223568.0, 186845840.0, 187736528.0, 3184948.0, 1934996.0, 1431882.0, 1225921.0, 1186311.0, 1238371.0, 1392693.0, 3190326.0], [209724544.0, 200640128.0, 4695649.0, 2133116.0, 2067423.0, 1974764.0, 1769515.0, 1576723.0, 1396270.0, 1392762.0, 1163494.0, 1340111.0], [8631671.0, 2948252.0, 1878185.0, 1944314.0, 1928056.0, 1818789.0, 1538142.0, 1391728.0, 1203908.0, 1180876.0, 1094184.0, 1385255.0], [2561222.0, 2007909.0, 2202352.0, 2187162.0, 2016595.0, 1628429.0, 1532333.0, 1342909.0, 1310737.0, 1187646.0, 1123093.0, 1284595.0], [2612154.0, 2109698.0, 2374385.0, 2376566.0, 2073923.0, 1862185.0, 1761917.0, 1637089.0, 1429714.0, 1279758.0, 937221.0, 1471533.0], [3401529.0, 2545716.0, 2582033.0, 2696296.0, 2458846.0, 2448346.0, 2106862.0, 1956427.0, 1705456.0, 1578239.0, 1126263.0, 1378166.0], [6511548.0, 5467399.0, 6249315.0, 6408278.0, 5996644.0, 5163665.0, 5879837.0, 5222682.0, 4798715.0, 4238464.0, 3052718.0, 1889772.0]]


## Disconnect from Reader


```python
await reader_unit.stop()
```

## Resource model

In the example above, we instantiated the Byonoy Luminescence 96 Automate reader using the `byonoy_l96a` function, which automatically creates the necessary resources for the reader.


```python
base_unit.reader_unit_holder.resource is reader_unit
```




    True





# Byonoy Absorbance 96 Automate

- [OEM Link](https://byonoy.com/absorbance-automate/)
- **Communication Protocol / Hardware:** HID / USB-A/C
- **Communication Level:** Firmware
- VID:PID `16d0:1199`
- Takes a single SLAS-format 96-wellplate on the detection unit, enables movement of the cap/illumination unit over it, and reads all 96 wells simultaneously.
- Up to 6 configurable absorbance wavelengths (dependent on specifications during purchase).

---
## Setup Instructions (Physical)

The Byonoy Absorbance 96 Automate (A96A) is a an absorbance plate reader consisting of...
1. a `detection_unit` containing the light sensors,
2. a `illumination_unit` containing the light source,
3. a `parking_unit` representing a simple resource_holder for the `illumination_unit` that is equivalent to the detection unit in terms of shape, and
4. an `sbs_adapter` which is an optional holder for the `detection_unit` or `parking_unit`, enabling placement of this machine onto a standard SLAS/SBS-format plate holder.

### Communication
It requires only one cable connection to be operational:
1. USB cable (USB-C at `base` end; USB-A at control PC end)

---
## Setup Instructions (Programmatic)


```python
%load_ext autoreload
%autoreload 2
```


```python
from pylabrobot.plate_reading.byonoy import byonoy_a96a
```


```python
reader, illumination_unit = byonoy_a96a("Absorbance96 Automate")
reader
```


```python
await reader.setup()
```

### Query Machine Configuration


```python
wavelengths = await reader.backend.get_available_absorbance_wavelengths()
wavelengths
```

### Measure Absorbance

Before you can do a plate reading measurement in PLR, you need to assign a plate to the reader.


```python
from pylabrobot.resources.corning.plates import Cor_96_wellplate_360ul_Fb
demo_plate = Cor_96_wellplate_360ul_Fb(name="plate")
```


```python
reader.assign_child_resource(demo_plate)
```


```python
wavelength = wavelengths[0]  # Choose the first available wavelength

data = await reader.read_absorbance(
  wavelength=wavelength,
  use_new_return_type=True,
)

print(f"Wavelength: {data[0]['wavelength']} nm")
print(f"Time: {data[0]['time']}")
print(f"Temperature: {data[0]['temperature']}")
print("Data")
print(data[0]['data'])
```

## Disconnect from Reader


```python
await reader.stop()
```

## Resource model

In the example above, we instantiated the Byonoy Absorbance 96 Automate reader using the `byonoy_a96a` function, which automatically creates the necessary resources for the reader.


```python
reader.illumination_unit_holder.resource is illumination_unit
```



# BMG Labtech CLARIOstar (Plus)

| Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Photo                                            |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| - [OEM Link](https://www.bmglabtech.com/en/clariostar-plus/)<br>- **Communication Protocol / Hardware**: Serial (FTDI)/ USB-A<br>- **Communication Level**: Firmware<br>- **Measurement Modes**: Absorbance, Luminescence, Fluorescence <br>- **Plate Delivery**: Loading tray<br>- **Additional Standard Features**: Temperature sontrol, Shaking<br><br>- **Additional Upgrades**: Injector system, increased max temperature, plate stacking system, ... | ![quadrants](img/bmg-labtech-clariostar-plus.png) |


---
## Setup Instructions (Physical)

The CLARIOstar and CLARIOstar Plus require a minimum of two cable connections to be operational:
1. Power cord (standard IEC C13)
2. USB cable (USB-B with security screws at CLARIOstar end; USB-A at control PC end)

Optional:
If you have a plate stacking unit to use with the CLARIOstar (Plus), an additional RS-232 port is available on the CLARIOstar (Plus).


---
## Setup Instructions (Programmatic)




```python
%load_ext autoreload
%autoreload 2
```

To control the BMG Labtech CLARIOstar (Plus), generate a `PlateReader` frontend instance that uses a `CLARIOstarBackend` instance as its backend.

To access the CLARIOstar-specific machine features you can still use the backend directly.
For convenience, it is useful to therefore store the backend instance as a separate `clariostar_backend` variable.


```python
from pylabrobot.plate_reading import PlateReader

from pylabrobot.plate_reading.clario_star_backend import CLARIOstarBackend
clariostar_backend = CLARIOstarBackend()

pr = PlateReader(
    name="CLARIOstar",
    backend=clariostar_backend,
    size_x=0.0, # TODO: generate new handling for resources with loading tray 
    size_y=0.0,
    size_z=0.0
)
```


```python
await pr.setup()
```

```{note}
Expected behaviour: the machine should perform its initialization routine.
```

---

## Usage / Machine Features

### Loading Tray


```python
await pr.open()
```


```python
# perform arm movement to move your plate of interest onto the CLARIOstar's loading tray
# this movement can be performed by a human
# or it can be performed by a robotic arm
```


```python
await pr.close()
```

### Set Temperature

The CLARIOstar offers a temperature control feature.
Reaching a set temperature is relatively slow compared to standalone temperature controllers.
We therefore recommend setting the temperature early on in your automated Protocol (aP).


```python
# WIP: feature exposure in active development
```

### Set Shaking

The CLARIOstar offers a shaking feature.


```python
# WIP: feature in active development
```

---
### Measuring Absorbance




```python
# WIP: feature in active development including
# reading subsets of wells
# specifying orbital diameter
# specifying number of technical replicate measurements per well
# specifying start position for reading: topleft, topright, bottomleft, bottomright
# ...

results_absorbance = await pr.read_absorbance()

```

`results` will be a width x height array of absorbance values.




#### Performing a Spectral Scan




```python
# WIP: feature in active development
```

### Measuring Luminescence



```python
# WIP: feature in active development

results_luminescence = await pr.read_luminescence()
```

### Measuring Fluorescence



```python
# WIP: feature in active development
```

### Using the Injector Needles



```python
# WIP: feature in active development
```



# Cytation

Cytation is an Agilent BioTek microplate reader / imager combination. This backend has been tested on the Cytation 1 and 5.

See installation instructions `cytation-imager`.


```python
%load_ext autoreload
%autoreload 2
```


```python
import matplotlib.pyplot as plt
from pylabrobot.plate_reading import ImageReader, ImagingMode, Objective
from pylabrobot.plate_reading import CytationBackend
```


```python
# for imaging, we need an environment variable to point to the Spinnaker GenTL file
import os
os.environ["SPINNAKER_GENTL64_CTI"] = "/usr/local/lib/spinnaker-gentl/Spinnaker_GenTL.cti"
```


```python
pr = ImageReader(name="PR", size_x=0,size_y=0,size_z=0, backend=CytationBackend())
await pr.setup(use_cam=True)
```


```python
await pr.backend.get_firmware_version()
```




    '1320200  Version 2.07'




```python
await pr.open(slow=False)
```

Before closing, assign a plate to the plate reader. This determines the spacing of the loading tray in the machine, as well as the positioning of wells where spectrophotometric measurements and pictures will be taken.


```python
from pylabrobot.resources import CellVis_24_wellplate_3600uL_Fb
plate = CellVis_24_wellplate_3600uL_Fb(name="plate")
pr.assign_child_resource(plate)
```


```python
await pr.close(slow=True)
```

## Plate reading

Note: these measurements were taken with a 96 well plate.


```python
data = await pr.read_absorbance(wavelength=434)
plt.imshow(data)
```




    <matplotlib.image.AxesImage at 0x1353cc790>




    
![png](cytation.ipynb_files/cytation.ipynb_11_1.png)
    



```python
data = await pr.read_fluorescence(
  excitation_wavelength=485, emission_wavelength=528, focal_height=7.5
)
plt.imshow(data)
```




    <matplotlib.image.AxesImage at 0x16e144850>




    
![png](cytation.ipynb_files/cytation.ipynb_12_1.png)
    



```python
data = await pr.read_luminescence(focal_height=4.5)
plt.imshow(data)
```




    <matplotlib.image.AxesImage at 0x16e1a83d0>




    
![png](cytation.ipynb_files/cytation.ipynb_13_1.png)
    


## Shaking


```python
await pr.backend.shake(
  shake_type=CytationBackend.ShakeType.LINEAR,
  frequency=4  # linear frequency in mm, 1 <= frequency <= 6
)
```


```python
await pr.backend.stop_shaking()
```

## Heating and cooling

Cytation supports heating and active cooling.


```python
await pr.backend.set_temperature(temperature=37) # Temperature in degrees C
```


```python
await pr.backend.get_current_temperature() # Returns temperature in degrees C
```


```python
await pr.backend.stop_heating_or_cooling() # Stop temperature control
```

## Imaging

### Installation

See [Cytation imager installation instructions](https://docs.pylabrobot.org/user_guide/installation.html#cytation-imager).

### Usage

Supported objectives:

- `O_4x_PL_FL_PHASE`
- `O_20x_PL_FL_PHASE`
- `O_40x_PL_FL_PHASE`

Supported imaging modes:

- `C377_647`
- `C400_647`
- `C469_593`
- `ACRIDINE_ORANGE`
- `CFP`
- `CFP_FRET_V2`
- `CFP_YFP_FRET`
- `CFP_YFP_FRET_V2`
- `CHLOROPHYLL_A`
- `CY5`
- `CY5_5`
- `CY7`
- `DAPI`
- `GFP`
- `GFP_CY5`
- `OXIDIZED_ROGFP2`
- `PROPOIDIUM_IODIDE`
- `RFP`
- `RFP_CY5`
- `TAG_BFP`
- `TEXAS_RED`
- `YFP`


```python
res = await pr.capture(
  well=(1, 2),
  mode=ImagingMode.BRIGHTFIELD,
  objective=Objective.O_4X_PL_FL_Phase,
  focal_height=0.833,
  exposure_time=5,
  gain=16,
  led_intensity=10,
)
plt.imshow(res.images[0], cmap="gray", vmin=0, vmax=255)
```




    <matplotlib.image.AxesImage at 0x144295ed0>




    
![png](cytation.ipynb_files/cytation.ipynb_24_1.png)
    


#### Autofocus

Auto-focus can be configured with `pr.backend.set_auto_focus_search_range` where the parameters are the minimum and maximum focus heights in mm respectively.


```python
from pylabrobot.plate_reading.standard import AutoFocus
from pylabrobot.plate_reading.imager import evaluate_focus_nvmg_sobel

res = await pr.capture(
  well=(1, 2),
  mode=ImagingMode.BRIGHTFIELD,
  objective=Objective.O_4X_PL_FL_Phase,
  focal_height=AutoFocus(
    low=1.8,
    high=2.0,
    evaluate_focus=evaluate_focus_nvmg_sobel,
    timeout=30,
  ),
  exposure_time=5,
  gain=16,
  led_intensity=10
)
plt.imshow(res.images[0], cmap="gray", vmin=0, vmax=255)
```




    <matplotlib.image.AxesImage at 0x177d24400>




    
![png](cytation.ipynb_files/cytation.ipynb_26_1.png)
    


#### Autoexposure

Two autoexposure functions are available in the PLR library:
- `max_pixel_at_fraction`: the value of the highest pixel in the image is a fraction of the maximum possible value (e.g. highest value is 50% of max, which would be 255/2 = 127.5 in the case of an 8 bit image)
- `fraction_overexposed`: the fraction of pixels at the cap (eg 255 for an 8 bit image) should be a certain fraction of the total number of pixels (e.g. 0.5% of pixels should be at the cap, so 0.005 * total_pixels). This is useful for images that are not well illuminated, as it ensures that a certain fraction of pixels is overexposed, which can help with image quality.

You can also define your own autoexposure function.

The `AutoExposure` dataclass is used to configure the autoexposure settings, including the evaluation function, maximum number of rounds, and low and high exposure time limits.


```python
from pylabrobot.plate_reading.imager import Imager, max_pixel_at_fraction, fraction_overexposed
from pylabrobot.plate_reading.standard import AutoExposure

res = await pr.capture(
  exposure_time=AutoExposure(
    # evaluate_exposure=fraction_overexposed(fraction=0.005, margin=0.005/10),
    evaluate_exposure=max_pixel_at_fraction(fraction=0.90, margin=0.05),
    max_rounds=15,
    low=1,
    high=100
  ),
  well=(2, 2),
  mode=ImagingMode.PHASE_CONTRAST,
  objective=Objective.O_20X_PL_FL_Phase,
  focal_height=1.8,  # focal height must be specified when using auto exposure
  gain=20  # gain must be specified when using auto exposure
)
```

#### Exporting

`.capture` returns a `List[Image]` where `Image = List[List[float]]` where each item is `0 <= x <= 255`. You can export this to an image file in many ways. Here's one example of exporting to a 16-bit tiff:


```python
from PIL import Image
import numpy as np

array = np.array(res.images[0], dtype=np.float32)
array_uint16 = (array * (65535 / 255)).astype(np.uint16)
Image.fromarray(array_uint16).save("test.tiff")
```

#### Coverage

Use the `coverage` parameter to take multiple pictures of the same well. The `coverage` parameter is an tuple `(num_rows, num_columns)` or `"full"`.

When we send the exact same commands as gen5.exe, with overlap = 0, we still get some overlap in the resulting images. This is probably because gen5.exe crops. For now, we don't support stitching or cropping in PLR yet, but we will in the future.


```python
num_rows = 4
num_cols = 4

res = await pr.capture(
  well=(1, 2),
  mode=ImagingMode.BRIGHTFIELD,
  objective=Objective.O_4X_PL_FL_Phase,
  focal_height=0.833,
  exposure_time=5,
  gain=16,
  coverage=(num_rows, num_cols),
  center_position=(-6, 0),
)
len(res.images)
```




    16




```python
fig = plt.figure(figsize=(12, 8))
for row in range(num_rows):
  for col in range(num_cols):
    plt.subplot(num_rows, num_cols, row * num_cols + col + 1)
    plt.imshow(res.images[row * num_cols + col], cmap="gray", vmin=0, vmax=255)
    plt.axis("off")
```


    
![png](cytation.ipynb_files/cytation.ipynb_34_0.png)
    


#### How long does it take to capture an image?


```python
import time
import numpy as np

exposure_time = 1904

# first time setting imaging mode is slower
_ = await pr.capture(well=(1, 1), mode=ImagingMode.BRIGHTFIELD, focal_height=3.3, exposure_time=exposure_time)

l = []
for i in range(10):
  t0 = time.monotonic_ns()
  _ = await pr.capture(well=(1, 1), mode=ImagingMode.BRIGHTFIELD, focal_height=3.3, exposure_time=exposure_time)
  t1 = time.monotonic_ns()
  l.append((t1 - t0) / 1e6)

print(f"{np.mean(l):.2f} ms ± {np.std(l):.2f} ms")
print(f"Overhead: {(np.mean(l) - exposure_time):.2f} ms")
```

    2089.59 ms ± 15.72 ms
    Overhead: 185.59 ms




# Synergy H1

Synergy H1 is an Agilent BioTek microplate reader that can read absorbance, fluorescence, and luminescence. Please refer to the [user guide](https://cqls.oregonstate.edu/sites/cqls.oregonstate.edu/files/synergy_h1_user_manual_sd-xb000426.pdf) for installation instructions.


```python
%load_ext autoreload
%autoreload 2
```


```python
import matplotlib.pyplot as plt
from pylabrobot.plate_reading import PlateReader
from pylabrobot.plate_reading import SynergyH1Backend
```


```python
pr = PlateReader(name="PR", size_x=0,size_y=0,size_z=0, backend=SynergyH1Backend())
await pr.setup()
```


```python
await pr.backend.get_firmware_version()
```




    '1320200  Version 2.07'




```python
await pr.open()
```

Before closing, assign a plate to the plate reader. This determines the spacing of the loading tray in the machine, as well as the positioning of wells where spectrophotometric measurements and pictures will be taken.


```python
from pylabrobot.resources import CellVis_24_wellplate_3600uL_Fb
plate = CellVis_24_wellplate_3600uL_Fb(name="plate")
pr.assign_child_resource(plate)
```


```python
await pr.close()
```

## Plate reading

Note: these measurements were taken with a 96 well plate.


```python
data = await pr.read_absorbance(wavelength=434)
plt.imshow(data)
```




    <matplotlib.image.AxesImage at 0x1353cc790>




    
![png](synergyh1.ipynb_files/synergyh1.ipynb_10_1.png)
    



```python
data = await pr.read_fluorescence(
  excitation_wavelength=485, emission_wavelength=528, focal_height=7.5
)
plt.imshow(data)
```




    <matplotlib.image.AxesImage at 0x16e144850>




    
![png](synergyh1.ipynb_files/synergyh1.ipynb_11_1.png)
    



```python
data = await pr.read_luminescence(focal_height=4.5)
plt.imshow(data)
```




    <matplotlib.image.AxesImage at 0x16e1a83d0>




    
![png](synergyh1.ipynb_files/synergyh1.ipynb_12_1.png)
    


## Shaking


```python
await pr.backend.shake(
  shake_type=SynergyH1Backend.ShakeType.LINEAR,
  frequency=4  # linear frequency in mm, 1 <= frequency <= 6
)
```


```python
await pr.backend.stop_shaking()
```

## Heating

Synergy H1 supports heating but does not support active cooling.


```python
await pr.backend.set_temperature(temperature=37) # Temperature in degrees C
```


```python
await pr.backend.get_current_temperature() # Returns temperature in degrees C
```


```python
await pr.backend.stop_heating_or_cooling() # Stop temperature control
```



# Byonoy Absorbance 96 Automate

- [OEM Link](https://byonoy.com/absorbance-automate/)
- **Communication Protocol / Hardware:** HID / USB-A/C
- **Communication Level:** Firmware
- VID:PID `16d0:1199`
- Takes a single SLAS-format 96-wellplate on the detection unit, enables movement of the cap/illumination unit over it, and reads all 96 wells simultaneously.
- Up to 6 configurable absorbance wavelengths (dependent on specifications during purchase).

---
## Setup Instructions (Physical)

The Byonoy Absorbance 96 Automate (A96A) is a an absorbance plate reader consisting of...
1. a `detection_unit` containing the liqht sensors,
2. a `illumination_unit` containing the light source,
3. a `parking_unit` representing a simple resource_holder for the `illumination_unit`, and
4. an `sbs_adapter` which is an optional holder for the `detection_unit` or `parking_unit`, enabling placement of this machine onto a standard SLAS/SBS-format plate holder.

### Communication
It requires only one cable connections to be operational:
1. USB cable (USB-C at `base` end; USB-A at control PC end)

---
## Setup Instructions (Programmatic)

If used with a liquid handler, first setup the liquid handler:
import logging
from pylabrobot.io import LOG_LEVEL_IO
from datetime import datetime

current_date = datetime.today().strftime('%Y-%m-%d')
protocol_mode = "execution"

# Create the shared file handler once
fh = logging.FileHandler(f"{current_date}_testing_{protocol_mode}.log", mode="a")
fh.setLevel(LOG_LEVEL_IO)
formatter = logging.Formatter(
    "%(asctime)s [%(levelname)s] %(name)s - %(message)s"
)
fh.setFormatter(formatter)

# Configure the main pylabrobot logger
logger_plr = logging.getLogger("pylabrobot")
logger_plr.setLevel(LOG_LEVEL_IO)
if not any(isinstance(h, logging.FileHandler) and h.baseFilename == fh.baseFilename
           for h in logger_plr.handlers):
    logger_plr.addHandler(fh)

# Other loggers can reuse the same file handler
logger_manager = logging.getLogger("manager")
logger_device = logging.getLogger("device")

for logger in [logger_manager, logger_device]:
    logger.setLevel(logging.DEBUG)  # or logging.INFO
    if not any(isinstance(h, logging.FileHandler) and h.baseFilename == fh.baseFilename
               for h in logger.handlers):
        logger.addHandler(fh)

# START LOGGING
logger_manager.info("START AUTOMATED PROTOCOL")


```python

```


```python
from pylabrobot.liquid_handling import LiquidHandler, LiquidHandlerChatterboxBackend
from pylabrobot.resources import STARDeck

lh = LiquidHandler(deck=STARDeck(), backend=LiquidHandlerChatterboxBackend())
```


```python
from pylabrobot.resources import (
    hamilton_mfx_carrier_L5_base, MFX_CAR_L4_SHAKER , # MFX CARRIERS
    MFX_DWP_rackbased_module, hamilton_mfx_plateholder_DWP_metal_tapped,
)
```


```python
# 

mfx_carrier_2_plateholders = hamilton_mfx_carrier_L5_base(
  name="mfx_carrier_2_plateholders",
  modules={
      4: hamilton_mfx_plateholder_DWP_metal_tapped(name=f"mfx_plateholder_1"),
      2: hamilton_mfx_plateholder_DWP_metal_tapped(name=f"mfx_plateholder_parking_unit"),
      0: hamilton_mfx_plateholder_DWP_metal_tapped(name=f"mfx_plateholder_detection_unit")
  }
)

lh.deck.assign_child_resource(mfx_carrier_2_plateholders, rails=12)

```


```python
await lh.setup()
```

    Setting up the liquid handler.


Then generate a plate definition for the plate you want to read:


```python
from pylabrobot.resources.coordinate import Coordinate
from pylabrobot.resources.cellvis.plates import CellVis_96_wellplate_350uL_Fb


demo_plate = CellVis_96_wellplate_350uL_Fb(name='demo_plate')

mfx_carrier_2_plateholders[4] = demo_plate
```


```python
from pylabrobot.plate_reading.byonoy import (
    byonoy_sbs_adapter,
    byonoy_a96a_detection_unit, 
    byonoy_a96a_illumination_unit,
    byonoy_a96a_parking_unit
)
```


```python
# Detection Unit
a96a_sbs_adapter_DU = byonoy_sbs_adapter(name="a96a_sbs_adapter_DU")
a96a_detection_unit = byonoy_a96a_detection_unit(name="a96a_detection_unit")
a96a_sbs_adapter_DU.assign_child_resource(a96a_detection_unit)

mfx_carrier_2_plateholders[0] = a96a_sbs_adapter_DU

# Parking Unit
a96a_sbs_adapter_PU = byonoy_sbs_adapter(name="a96a_sbs_adapter_PU")
a96a_parking_unit = byonoy_a96a_parking_unit(name="a96a_parking_unit")
a96a_sbs_adapter_PU.assign_child_resource(a96a_parking_unit)

mfx_carrier_2_plateholders[2] = a96a_sbs_adapter_PU


a96a_illumination_unit = byonoy_a96a_illumination_unit(name="a96a_illumination_unit")

```


```python
a96a_detection_unit.assign_child_resource(a96a_illumination_unit)
```

    Resource 'a96a_illumination_unit' is very high on the deck: 257.948 mm. Be careful when traversing the deck.



```python
a96a_detection_unit.get_location_wrt(lh.deck)
```




    Coordinate(x=337.75, y=67.0, z=200.95)




```python
lh.summary()
```

    Rail  Resource                          Type                 Coordinates (mm)
    ===========================================================================================
    (-6)  ├── trash_core96                  Trash                (-58.200, 106.000, 216.400)
          │
    (12)  ├── mfx_carrier_2_plateholders    MFXCarrier           (347.500, 063.000, 100.000)
          │   ├── demo_plate                Plate                (351.500, 456.000, 182.050)
          │   ├── a96a_sbs_adapter_PU       ResourceHolder       (351.500, 264.000, 183.950)
          │   │   ├── a96a_parking_unit     ByonoyBaseUnit       (337.750, 259.000, 200.950)
          │   ├── a96a_sbs_adapter_DU       ResourceHolder       (351.500, 072.000, 183.950)
          │   │   ├── a96a_detection_unit   ByonoyBaseUnit       (337.750, 067.000, 200.950)
          │
    (55)  ├── waste_block                   Resource             (1315.000, 115.000, 100.000)
          │   ├── teaching_tip_rack         TipRack              (1320.900, 461.100, 100.000)
          │   ├── core_grippers             HamiltonCoreGrippers (1337.500, 125.000, 205.000)
          │
    (56)  ├── trash                         Trash                (1340.000, 190.600, 137.100)
    



```python
lh.summary()
```

    Rail  Resource                              Type                 Coordinates (mm)
    ===============================================================================================
    (-6)  ├── trash_core96                      Trash                (-58.200, 106.000, 216.400)
          │
    (12)  ├── mfx_carrier_2_plateholders        MFXCarrier           (347.500, 063.000, 100.000)
          │   ├── demo_plate                    Plate                (351.500, 456.000, 182.050)
          │   ├── a96a_sbs_adapter_PU           ResourceHolder       (351.500, 264.000, 183.950)
          │   │   ├── a96a_parking_unit         ByonoyBaseUnit       (337.750, 259.000, 200.950)
          │   ├── a96a_sbs_adapter_DU           ResourceHolder       (351.500, 072.000, 183.950)
          │   │   ├── a96a_detection_unit       ByonoyBaseUnit       (337.750, 067.000, 200.950)
          │   │   │   ├── a96a_illumination_unitResource             (337.750, 067.000, 215.050)
          │
    (55)  ├── waste_block                       Resource             (1315.000, 115.000, 100.000)
          │   ├── teaching_tip_rack             TipRack              (1320.900, 461.100, 100.000)
          │   ├── core_grippers                 HamiltonCoreGrippers (1337.500, 125.000, 205.000)
          │
    (56)  ├── trash                             Trash                (1340.000, 190.600, 137.100)
    



```python
await lh.move_resource(a96a_illumination_unit, a96a_parking_unit, pickup_distance_from_top=13.5)
```

    Resource 'a96a_illumination_unit' is very high on the deck: 257.948 mm. Be careful when traversing the deck.


    Picking up resource: ResourcePickup(resource=Resource(name='a96a_illumination_unit', location=Coordinate(000.000, 000.000, 014.100), size_x=155.26, size_y=95.48, size_z=42.898, category=None), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=13.5, direction=<GripDirection.FRONT: 1>)
    Dropping resource: ResourceDrop(resource=Resource(name='a96a_illumination_unit', location=Coordinate(000.000, 000.000, 014.100), size_x=155.26, size_y=95.48, size_z=42.898, category=None), destination=Coordinate(x=337.75, y=259.0, z=200.95), destination_absolute_rotation=Rotation(x=0, y=0, z=0), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=13.5, pickup_direction=<GripDirection.FRONT: 1>, direction=<GripDirection.FRONT: 1>, rotation=0)



```python
lh.summary()
```

    Rail  Resource                              Type                 Coordinates (mm)
    ===============================================================================================
    (-6)  ├── trash_core96                      Trash                (-58.200, 106.000, 216.400)
          │
    (12)  ├── mfx_carrier_2_plateholders        MFXCarrier           (347.500, 063.000, 100.000)
          │   ├── <empty>
          │   ├── a96a_sbs_adapter_PU           ResourceHolder       (351.500, 264.000, 183.950)
          │   │   ├── a96a_parking_unit         ByonoyBaseUnit       (337.750, 259.000, 200.950)
          │   │   │   ├── a96a_illumination_unitResource             (337.750, 259.000, 215.050)
          │   ├── a96a_sbs_adapter_DU           ResourceHolder       (351.500, 072.000, 183.950)
          │   │   ├── a96a_detection_unit       ByonoyBaseUnit       (337.750, 067.000, 200.950)
          │
    (55)  ├── waste_block                       Resource             (1315.000, 115.000, 100.000)
          │   ├── teaching_tip_rack             TipRack              (1320.900, 461.100, 100.000)
          │   ├── core_grippers                 HamiltonCoreGrippers (1337.500, 125.000, 205.000)
          │
    (56)  ├── trash                             Trash                (1340.000, 190.600, 137.100)
    



```python

```


```python

```
a96a_detection_unit.assign_child_resource(demo_plate)

```python
await lh.move_plate(demo_plate, a96a_detection_unit)
```

    Picking up resource: ResourcePickup(resource=Plate(name='demo_plate', size_x=127.6, size_y=85.75, size_z=13.83, location=None), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=9.87, direction=<GripDirection.FRONT: 1>)
    Dropping resource: ResourceDrop(resource=Plate(name='demo_plate', size_x=127.6, size_y=85.75, size_z=13.83, location=None), destination=Coordinate(x=337.75, y=67.0, z=200.95), destination_absolute_rotation=Rotation(x=0, y=0, z=0), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=9.87, pickup_direction=<GripDirection.FRONT: 1>, direction=<GripDirection.FRONT: 1>, rotation=0)



```python
lh.summary()
```

    Rail  Resource                              Type                 Coordinates (mm)
    ===============================================================================================
    (-6)  ├── trash_core96                      Trash                (-58.200, 106.000, 216.400)
          │
    (12)  ├── mfx_carrier_2_plateholders        MFXCarrier           (347.500, 063.000, 100.000)
          │   ├── <empty>
          │   ├── a96a_sbs_adapter_PU           ResourceHolder       (351.500, 264.000, 183.950)
          │   │   ├── a96a_parking_unit         ByonoyBaseUnit       (337.750, 259.000, 200.950)
          │   │   │   ├── a96a_illumination_unitResource             (337.750, 259.000, 215.050)
          │   ├── a96a_sbs_adapter_DU           ResourceHolder       (351.500, 072.000, 183.950)
          │   │   ├── a96a_detection_unit       ByonoyBaseUnit       (337.750, 067.000, 200.950)
          │   │   │   ├── demo_plate            Plate                (360.250, 072.000, 216.950)
          │
    (55)  ├── waste_block                       Resource             (1315.000, 115.000, 100.000)
          │   ├── teaching_tip_rack             TipRack              (1320.900, 461.100, 100.000)
          │   ├── core_grippers                 HamiltonCoreGrippers (1337.500, 125.000, 205.000)
          │
    (56)  ├── trash                             Trash                (1340.000, 190.600, 137.100)
    



```python

```


```python
await lh.move_resource(a96a_illumination_unit, a96a_detection_unit, pickup_distance_from_top=13.5)
```

    Resource 'a96a_illumination_unit' is very high on the deck: 257.948 mm. Be careful when traversing the deck.


    Picking up resource: ResourcePickup(resource=Resource(name='a96a_illumination_unit', location=Coordinate(000.000, 000.000, 014.100), size_x=155.26, size_y=95.48, size_z=42.898, category=None), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=13.5, direction=<GripDirection.FRONT: 1>)
    Dropping resource: ResourceDrop(resource=Resource(name='a96a_illumination_unit', location=Coordinate(000.000, 000.000, 014.100), size_x=155.26, size_y=95.48, size_z=42.898, category=None), destination=Coordinate(x=337.75, y=67.0, z=200.95), destination_absolute_rotation=Rotation(x=0, y=0, z=0), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=13.5, pickup_direction=<GripDirection.FRONT: 1>, direction=<GripDirection.FRONT: 1>, rotation=0)



```python

```


```python

```


```python
lh.summary()
```

    Rail  Resource                              Type                 Coordinates (mm)
    ===============================================================================================
    (-6)  ├── trash_core96                      Trash                (-58.200, 106.000, 216.400)
          │
    (12)  ├── mfx_carrier_2_plateholders        MFXCarrier           (347.500, 063.000, 100.000)
          │   ├── <empty>
          │   ├── a96a_sbs_adapter_PU           ResourceHolder       (351.500, 264.000, 183.950)
          │   │   ├── a96a_parking_unit         ByonoyBaseUnit       (337.750, 259.000, 200.950)
          │   ├── a96a_sbs_adapter_DU           ResourceHolder       (351.500, 072.000, 183.950)
          │   │   ├── a96a_detection_unit       ByonoyBaseUnit       (337.750, 067.000, 200.950)
          │   │   │   ├── demo_plate            Plate                (360.250, 072.000, 216.950)
          │   │   │   ├── a96a_illumination_unitResource             (337.750, 067.000, 215.050)
          │
    (55)  ├── waste_block                       Resource             (1315.000, 115.000, 100.000)
          │   ├── teaching_tip_rack             TipRack              (1320.900, 461.100, 100.000)
          │   ├── core_grippers                 HamiltonCoreGrippers (1337.500, 125.000, 205.000)
          │
    (56)  ├── trash                             Trash                (1340.000, 190.600, 137.100)
    



```python

```


```python
await lh.move_resource(demo_plate, mfx_carrier_2_plateholders[4], pickup_distance_from_top=13.5)
```

    Picking up resource: ResourcePickup(resource=Plate(name='demo_plate', size_x=127.6, size_y=85.75, size_z=13.83, location=Coordinate(022.500, 005.000, 016.000)), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=13.5, direction=<GripDirection.FRONT: 1>)
    Dropping resource: ResourceDrop(resource=Plate(name='demo_plate', size_x=127.6, size_y=85.75, size_z=13.83, location=Coordinate(022.500, 005.000, 016.000)), destination=Coordinate(x=351.5, y=456.0, z=182.05), destination_absolute_rotation=Rotation(x=0, y=0, z=0), offset=Coordinate(x=0, y=0, z=0), pickup_distance_from_top=13.5, pickup_direction=<GripDirection.FRONT: 1>, direction=<GripDirection.FRONT: 1>, rotation=0)



```python

```


```python
demo_plate.get_location_wrt(lh.deck)
```




    Coordinate(x=360.25, y=72.0, z=216.95)




```python
a96a_detection_unit.get_location_wrt(lh.deck)
```




    Coordinate(x=337.75, y=67.0, z=200.95)




```python
a96a_detection_unit.get_location_wrt(lh.deck)+ a96a_detection_unit.child_location
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    Cell In[16], line 1
    ----> 1 a96a_detection_unit.get_location_wrt(lh.deck)+ a96a_detection_unit.child_location


    AttributeError: 'ByonoyBaseUnit' object has no attribute 'child_location'



```python
a96a_detection_unit.assign_child_resource(a96a_illumination_unit)
```


```python
lh.summary()
```


```python
[print(x) for x in a96a_sbs_adapter.children]
```

    ByonoyA96ABaseUnit(name='a96a_detection_unit', location=Coordinate(-13.750, -05.000, 017.000), size_x=155.26, size_y=95.48, size_z=18.5, category=resource_holder)





    [None]




```python
[print(x) for x in a96a_detection_unit.children]
```

    Plate(name='demo_plate', size_x=127.6, size_y=85.75, size_z=13.83, location=Coordinate(022.500, 005.000, 016.000))
    Resource(name='a96a_illumination_unit', location=Coordinate(000.000, 000.000, 014.100), size_x=155.26, size_y=95.48, size_z=42.898, category=None)





    [None, None]



Now instantiate the Byonoy absorbance plate reader:


```python
from pylabrobot.plate_reading.byonoy import (
    byonoy_absorbance_adapter,
    byonoy_absorbance96_base_and_reader
)

cap_adapter = byonoy_absorbance_adapter(name='cap_adapter')

base, reader_cap = byonoy_absorbance96_base_and_reader(name='base', assign=True)

lh.deck.assign_child_resource(cap_adapter, location=Coordinate(400, 0, 0))
```


```python
await reader_cap.setup(verbose=True)

reader_cap.setup_finished
```

    Connected to Bynoy Absorbance 96 Automate (via HID with VID=5840:PID=4505) on b'DevSrvsID:4308410804'
    Identified available wavelengths: [420, 600] nm





    True




```python
reader_cap.backend.io.device_info
```




    {'path': b'DevSrvsID:4308410804',
     'vendor_id': 5840,
     'product_id': 4505,
     'serial_number': 'BYOMAA00058',
     'release_number': 512,
     'manufacturer_string': 'Byonoy GmbH',
     'product_string': 'Absorbance 96 Automate',
     'usage_page': 65280,
     'usage': 1,
     'interface_number': 0,
     'bus_type': <BusType.USB: 1>}




```python
reader_cap.backend.available_wavelengths
```




    [420, 600]



## Test Movement for Plate Reading
# move the reader off the base
await lh.move_resource(reader_cap, Coordinate(200, 0, 0))await lh.move_resource(plate, base.plate_holder)await lh.move_resource(reader_cap, base.reader_holder)adapter.assign_child_resource(base)

```python
cap_adapter, base, reader_cap
```




    (ResourceHolder(name='cap_adapter', location=Coordinate(400.000, 000.000, 000.000), size_x=127.76, size_y=85.59, size_z=14.07, category=resource_holder),
     ByonoyBase(name='base_base', location=None, size_x=138, size_y=95.7, size_z=27.7, category=None),
     PlateReader(name='base_reader', location=Coordinate(000.000, 000.000, 010.660), size_x=138, size_y=95.7, size_z=0, category=None))



---

## Usage / Machine Features

### Query Machine Configuration


```python
await reader_cap.backend.get_available_absorbance_wavelengths()
```




    [420, 600]



### Measure Absorbance


```python
readings_420_nested_list = await reader_cap.backend.read_absorbance(
    wells=plate.children[:55],
    wavelength = 420, # units: nm
    output_nested_list=True
)

import pandas as pd

pd.DataFrame(readings_420_nested_list)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>10</th>
      <th>11</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.000002</td>
      <td>-0.000002</td>
      <td>0.000083</td>
      <td>0.000038</td>
      <td>0.000048</td>
      <td>2.975314e-05</td>
      <td>0.000075</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.000062</td>
      <td>0.000051</td>
      <td>0.000040</td>
      <td>0.000018</td>
      <td>0.000064</td>
      <td>3.082320e-05</td>
      <td>0.000044</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.000088</td>
      <td>0.000055</td>
      <td>0.000069</td>
      <td>0.000009</td>
      <td>0.000079</td>
      <td>7.937726e-05</td>
      <td>0.000078</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.000080</td>
      <td>0.000050</td>
      <td>0.000009</td>
      <td>0.000069</td>
      <td>0.000067</td>
      <td>3.182423e-05</td>
      <td>0.000070</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.000042</td>
      <td>0.000003</td>
      <td>0.000110</td>
      <td>0.000005</td>
      <td>-0.000005</td>
      <td>-1.815412e-05</td>
      <td>0.000070</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.000055</td>
      <td>0.000054</td>
      <td>-0.000023</td>
      <td>0.000041</td>
      <td>0.000036</td>
      <td>9.664112e-07</td>
      <td>0.000039</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0.000046</td>
      <td>0.000025</td>
      <td>0.000019</td>
      <td>0.000017</td>
      <td>0.000039</td>
      <td>3.658781e-05</td>
      <td>0.000066</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0.000038</td>
      <td>0.000018</td>
      <td>0.000055</td>
      <td>0.000041</td>
      <td>0.000034</td>
      <td>-3.216584e-05</td>
      <td>NaN</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
      <td>None</td>
    </tr>
  </tbody>
</table>
</div>




```python
import time
```


```python
start_time = time.time()

readings_600_nested_list = await reader_cap.backend.read_absorbance(
    wells=plate.children[:],
    wavelength = 600, # units: nm
    output_nested_list=True
)
display(pd.DataFrame(readings_600_nested_list))


time.time() - start_time
```


<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
      <th>8</th>
      <th>9</th>
      <th>10</th>
      <th>11</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.000097</td>
      <td>0.000079</td>
      <td>0.000087</td>
      <td>0.000092</td>
      <td>0.000085</td>
      <td>0.000097</td>
      <td>0.000086</td>
      <td>0.000088</td>
      <td>0.000074</td>
      <td>0.000111</td>
      <td>0.000066</td>
      <td>0.000076</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.000050</td>
      <td>0.000074</td>
      <td>0.000063</td>
      <td>0.000054</td>
      <td>0.000073</td>
      <td>0.000066</td>
      <td>0.000050</td>
      <td>0.000061</td>
      <td>0.000082</td>
      <td>0.000095</td>
      <td>0.000051</td>
      <td>0.000059</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.000093</td>
      <td>0.000049</td>
      <td>0.000031</td>
      <td>0.000081</td>
      <td>0.000067</td>
      <td>0.000083</td>
      <td>0.000066</td>
      <td>0.000104</td>
      <td>0.000074</td>
      <td>0.000064</td>
      <td>0.000040</td>
      <td>0.000069</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.000096</td>
      <td>0.000074</td>
      <td>0.000023</td>
      <td>0.000075</td>
      <td>0.000100</td>
      <td>0.000053</td>
      <td>0.000064</td>
      <td>0.000087</td>
      <td>0.000070</td>
      <td>0.000073</td>
      <td>0.000050</td>
      <td>0.000054</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.000087</td>
      <td>0.000074</td>
      <td>0.000161</td>
      <td>0.000070</td>
      <td>0.000080</td>
      <td>0.000069</td>
      <td>0.000101</td>
      <td>0.000106</td>
      <td>0.000112</td>
      <td>0.000103</td>
      <td>0.000059</td>
      <td>0.000062</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.000058</td>
      <td>0.000067</td>
      <td>0.000023</td>
      <td>0.000068</td>
      <td>0.000036</td>
      <td>0.000053</td>
      <td>0.000035</td>
      <td>0.000044</td>
      <td>0.000045</td>
      <td>0.000097</td>
      <td>0.000039</td>
      <td>0.000033</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0.000080</td>
      <td>0.000036</td>
      <td>0.000012</td>
      <td>0.000079</td>
      <td>0.000062</td>
      <td>0.000061</td>
      <td>0.000046</td>
      <td>0.000084</td>
      <td>0.000043</td>
      <td>0.000050</td>
      <td>0.000026</td>
      <td>0.000064</td>
    </tr>
    <tr>
      <th>7</th>
      <td>0.000087</td>
      <td>0.000053</td>
      <td>0.000072</td>
      <td>0.000060</td>
      <td>0.000076</td>
      <td>0.000031</td>
      <td>0.000034</td>
      <td>0.000084</td>
      <td>0.000086</td>
      <td>0.000054</td>
      <td>0.000032</td>
      <td>0.000079</td>
    </tr>
  </tbody>
</table>
</div>





    1.5100939273834229




```python
start_time = time.time()

readings_600_nested_list = await reader_cap.backend.read_absorbance(
    wells=plate.children[:],
    wavelength = 600, # units: nm
    output_nested_list=True
)
display(pd.DataFrame(readings_600_nested_list))

time.time() - start_time
```


```python

```


```python
first_n_columns = 8

readings_420 = await reader_cap.backend.read_absorbance(
    wells=plate.children[:8*first_n_columns],
    wavelength = 420 # units: nm
)
readings_600 = await reader_cap.backend.read_absorbance(
    wells=plate.children[:8*first_n_columns],
    wavelength = 600 # units: nm
)

well_indexed_df = pd.DataFrame([readings_420, readings_600], index=["420nm", "600nm"]).T
well_indexed_df
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>420nm</th>
      <th>600nm</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A1</th>
      <td>0.000064</td>
      <td>0.000100</td>
    </tr>
    <tr>
      <th>B1</th>
      <td>0.000097</td>
      <td>0.000033</td>
    </tr>
    <tr>
      <th>C1</th>
      <td>0.000165</td>
      <td>0.000086</td>
    </tr>
    <tr>
      <th>D1</th>
      <td>0.000105</td>
      <td>0.000082</td>
    </tr>
    <tr>
      <th>E1</th>
      <td>0.000106</td>
      <td>0.000132</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>D8</th>
      <td>0.000073</td>
      <td>0.000117</td>
    </tr>
    <tr>
      <th>E8</th>
      <td>0.000085</td>
      <td>0.000107</td>
    </tr>
    <tr>
      <th>F8</th>
      <td>0.000057</td>
      <td>0.000053</td>
    </tr>
    <tr>
      <th>G8</th>
      <td>0.000124</td>
      <td>0.000102</td>
    </tr>
    <tr>
      <th>H8</th>
      <td>0.000079</td>
      <td>0.000128</td>
    </tr>
  </tbody>
</table>
<p>64 rows × 2 columns</p>
</div>



## Disconnect from Reader


```python
await reader_cap.stop()
```


```python

```



# Plate reading

PyLabRobot supports the following plate readers:

```{toctree}
:maxdepth: 1

bmg-clariostar
byonoy/absorbance
byonoy/luminescence
byonoy
cytation
synergyh1
```

This example uses the `PlateReaderChatterboxBackend`. When using a real machine, use the corresponding backend.


```python
from pylabrobot.plate_reading import PlateReader, PlateReaderChatterboxBackend
pr = PlateReader(name="plate reader", backend=PlateReaderChatterboxBackend(), size_x=0, size_y=0, size_z=0)
await pr.setup()
```

    Setting up the plate reader.


## Basic plate reading

First you need to assign a plate to the plate reader.


```python
from pylabrobot.resources import Cor_96_wellplate_360ul_Fb
plate = Cor_96_wellplate_360ul_Fb(name="plate")
pr.assign_child_resource(plate)
```

### Luminescence

![Cytation{1,5} supported](https://img.shields.io/badge/Cytation-supported-blue)
![ClarioSTAR supported](https://img.shields.io/badge/ClarioSTAR-supported-blue)
![Synergy H1 supported](https://img.shields.io/badge/SynergyH1-supported-blue)


```python
data = await pr.read_luminescence(focal_height=4.5)
```

    Reading luminescence at focal height 4.5.
    Read the following wells:
      |      1|      2|      3|      4|      5|      6|      7|      8|      9|     10|     11|     12|
    ---------------------------------------------------------------------------------------------------
    A |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    B |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    C |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    D |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    E |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    F |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    G |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    H |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|


Data is a 2d array of optional floats.


```python
data
```




    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]



### Absorbance

![Cytation{1,5} supported](https://img.shields.io/badge/Cytation-supported-blue)
![ClarioSTAR supported](https://img.shields.io/badge/ClarioSTAR-supported-blue)
![Synergy H1 supported](https://img.shields.io/badge/SynergyH1-supported-blue)


```python
await pr.read_absorbance(wavelength=450)
```

    Reading absorbance at wavelength 450.
    Read the following wells:
      |      1|      2|      3|      4|      5|      6|      7|      8|      9|     10|     11|     12|
    ---------------------------------------------------------------------------------------------------
    A |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    B |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    C |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    D |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    E |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    F |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    G |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    H |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|





    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]



Data is a 2d array of optional floats.


```python
data
```




    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]



### Fluorescence

![Cytation{1,5} supported](https://img.shields.io/badge/Cytation-supported-blue)
![ClarioSTAR not support](https://img.shields.io/badge/ClarioSTAR-not%20supported-red)
![Synergy H1 supported](https://img.shields.io/badge/SynergyH1-supported-blue)


```python
await pr.read_fluorescence(excitation_wavelength=485, emission_wavelength=520, focal_height=4.5)
```

    Reading fluorescence at excitation wavelength 485, emission wavelength 520, and focal height 4.5.
    Read the following wells:
      |      1|      2|      3|      4|      5|      6|      7|      8|      9|     10|     11|     12|
    ---------------------------------------------------------------------------------------------------
    A |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    B |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    C |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    D |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    E |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    F |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    G |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|
    H |  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|  0.000|





    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]



Data is a 2d array of optional floats.


```python
data
```




    [[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]]



## Reading parts of plates

![Cytation{1,5} supported](https://img.shields.io/badge/Cytation-supported-blue)
![ClarioSTAR not support](https://img.shields.io/badge/ClarioSTAR-not%20supported-red)
![Synergy H1 supported](https://img.shields.io/badge/SynergyH1-supported-blue)

The example below shows luminescence, but the API is the same for luminescence, absorbance and fluorescence.


```python
data = await pr.read_luminescence(focal_height=4.5, wells=plate["A1:C5"])
```

    Reading luminescence at focal height 4.5.
    Read the following wells:
      |      1|      2|      3|      4|      5|      6|      7|      8|      9|     10|     11|     12|
    ---------------------------------------------------------------------------------------------------
    A |  0.000|  0.000|  0.000|  0.000|  0.000|       |       |       |       |       |       |       |
    B |  0.000|  0.000|  0.000|  0.000|  0.000|       |       |       |       |       |       |       |
    C |  0.000|  0.000|  0.000|  0.000|  0.000|       |       |       |       |       |       |       |
    D |       |       |       |       |       |       |       |       |       |       |       |       |
    E |       |       |       |       |       |       |       |       |       |       |       |       |
    F |       |       |       |       |       |       |       |       |       |       |       |       |
    G |       |       |       |       |       |       |       |       |       |       |       |       |
    H |       |       |       |       |       |       |       |       |       |       |       |       |



```python
data
```




    [[0.0, 0.0, 0.0, 0.0, 0.0, None, None, None, None, None, None, None],
     [0.0, 0.0, 0.0, 0.0, 0.0, None, None, None, None, None, None, None],
     [0.0, 0.0, 0.0, 0.0, 0.0, None, None, None, None, None, None, None],
     [None, None, None, None, None, None, None, None, None, None, None, None],
     [None, None, None, None, None, None, None, None, None, None, None, None],
     [None, None, None, None, None, None, None, None, None, None, None, None],
     [None, None, None, None, None, None, None, None, None, None, None, None],
     [None, None, None, None, None, None, None, None, None, None, None, None]]





# Mettler Toledo Precision Scales

| Summary | Image |
|------------|--------|
| <ul style="font-size:15px; line-height:1.6; margin-top:0;"> <li><a href="https://www.mt.com/gb/en/home/products/Industrial_Weighing_Solutions/high-precision-weigh-sensors/weigh-module-wxs205sdu-15-11121008.html" target="_blank"><b>OEM Link</b></a></li> <li><b>Communication Protocol / Hardware:</b> Serial / RS-232</li> <li><b>Communication Level:</b> Firmware (documentation shared by OEM)</li> <li><b>Compatibility:</b> This backend has been extensively tested on the WXS205SDU (but according to firmware documentation is applicable to other Mettler Toledo "Automated Precision Weigh Modules", including the WX and WMS series)</li> <li><b>VID:PID:</b> <code>0x0403:0x6001</code></li> <li><b>Description:</b> High-precision fine balance with various adapters available.</li> <li><b>Load range:</b> 0 - 220 g</li> <li><b>Readability:</b> 0.1 mg</li> </ul> | <div style="width:320px; text-align:center;"> ![shaker](img/mettler_toledo_wx_scale.png) <br><i>Figure: Mettler Toledo WXS205SDU used for gravimetric liquid transfer verification</i> </div> |

---
## Setup (Physical)

The WXS205SDU scale system consists of 2 required units and 1 optional unit:

### Machine Components

|  | **1. Load Cell** | **2. Electronic Unit** | **3. Terminal/Display** |
|-----------|-------|-------------|-------------|
| **Image** | <div style="height:200px"> ![load_cell](img/mt_load_cell.png) | <div style="height:200px"> ![electronic_unit](img/mt_electronic_unit.png) | <div style="height:200px"> ![terminal](img/mt_terminal.png) |
| **Description** | The weighing platform where samples are placed | The control and communication module | Optional: For manual reading of measurements |

### Mettler Toledo Terminology

| Configuration Name | Has Load Cell | Has Electronics Unit | Has Terminal/Display |
|---------------|---------------|-----------------|---------------------|
| **Balance** | ✓ | ✓ | ✓ |
| **Weigh Module** (or "Bridge") | ✓ | ✓ | ✗ |

**Note:** When used with PyLabRobot, the terminal/display is optional since all control is done programmatically.

### Connection

The scale communicates via an RS-232 serial port.

To connect it to your computer, you'll likely need a USB-to-serial adapter.
Any generic adapter using an FTDI chipset (typically ~$10) should work fine.

---
## Setup (Programmatic)

Import the necessary classes:


```python
from pylabrobot.scales import Scale
from pylabrobot.scales.mettler_toledo_backend import MettlerToledoWXS205SDUBackend

```

Initialize the scale backend and create a scale instance.
You'll need to specify the serial port where your scale is connected:


```python
backend = MettlerToledoWXS205SDUBackend(port="/dev/cu.usbserial-110")
scale = Scale(name="scale", backend=backend, size_x=0, size_y=0, size_z=0)

await scale.setup()

```




    0.00148



```{Warning}
### Warm-up Time Required

This scale requires a **warm-up period** after being powered on. Mettler Toledo documentation specifies 60-90 minutes, though in practice 30 minutes is often sufficient.

If you attempt measurements before the scale has warmed up, you'll likely encounter an error: *"Command understood but currently not executable (balance is currently executing another command)"*.

**Tip**: Sometimes power-cycling the scale (unplugging and replugging the power cord) can help resolve initialization issues.
```


```{Note}
This scale is the same model used in the Hamilton Liquid Verification Kit (LVK).
```

---
## Usage

The scale implements the three core methods required for all PyLabRobot scales.

They are presented here in typical workflow order:

### `.zero()`

Calibrates the scale to read zero when the platform is empty.
Unlike taring, this establishes the baseline "empty" reading without accounting for any container weight.
Use this at the start of a workflow or after removing all items from the platform.


```python
await scale.zero(timeout=5)

```

```{note}
See the [Scales documentation](./scales.rst) for details on the ``timeout`` parameter and when to use different timeout modes.
```

### `.tare()`

Resets the scale reading to zero while accounting for the weight of a container already on the platform. Use this when you want to measure only the weight of material being added to a container.

**Example workflow**:
Place an empty beaker on the scale → tare → dispense liquid → read only the liquid's weight.


```python
await scale.tare(timeout=5)

```

The difference between load at `scale.zero()` and load at `scale.tare()` is stored in and can be retrieved from the scales's memory:


```python
await scale.request_tare_weight()

```


### `read_weight()`

Retrieves the current weight measurement from the scale **in grams**.


```python
await scale.read_weight(timeout=0)

```




    0.00148



---
### Typical Workflow

Here's a common pattern for gravimetric liquid transfer (i.e. aspiration AND dispensation) verification:


```python
import asyncio

# 1. Zero the scale
await scale.zero(timeout="stable")

# 2. Place container with liquid on scale

# 3. Aspirate liquid from container (on scale)
# (your liquid handling code here)

# 4. Tare the scale (ignore weight loss from aspiration)
await scale.tare(timeout=5)

# 5. Dispense liquid back into same container (on scale)
# (your liquid handling code here)

# 6. Brief pause to allow scale to settle
await asyncio.sleep(1)  # Allow 1 second for settling after dispense

# 7. Read the weight of dispensed liquid
weight_g = await scale.read_weight(timeout=5)

# 8. Convert weight to volume
weight_mg = weight_g * 1000
liquid_density = 1.06  # mg/µL for 50% v/v glycerol at ~25°C, 1 atm
volume_uL = weight_mg / liquid_density

print(f"Dispensed {weight_mg:.2f} mg or ({volume_uL:.2f} µL)")

```

---
### Performance Characterization

#### Example: Measuring Read Time

You can easily benchmark the scale's performance using standard Python timing:


```python
import time
import numpy as np

times = []
for i in range(10):
  t0 = time.monotonic_ns()
  await scale.read_weight(timeout="stable")
  t1 = time.monotonic_ns()
  times.append((t1 - t0) / 1e6)

print(f"{np.mean(times):.2f} ms ± {np.std(times):.2f} ms")

```

    100.44 ms ± 6.78 ms




# Using the Visualizer

The Visualizer is a tool that allows you to visualize the a Resource (like LiquidHandler) including its state to easily see what is going on, for example when executing a protocol on a robot or when developing a new protocol.

When using a backend that does not require access to a physical robot, such as the {class}`~pylabrobot.liquid_handling.backends.chatterbox.ChatterboxBackend`, the Visualizer can be used to simulate a robot's behavior. Of course, you may also use the Visualizer when working with a real robot to see what is happening in the PLR resource and state trackers.

## Setting up a connection with the robot

As described in the [basic liquid handling tutorial](../00_liquid-handling/hamilton-star/basic), we will use the {class}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler` class to control the robot. This time, however, instead of using the Hamilton {class}`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STAR` backend, we are using the software-only {class}`~pylabrobot.liquid_handling.backends.chatterbox.ChatterboxBackend` backend. This means that liquid handling will work exactly the same, but commands are simply printed out to the console instead of being sent to a physical robot. We are still using the same deck.


```python
from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.liquid_handling.backends import LiquidHandlerChatterboxBackend
from pylabrobot.visualizer.visualizer import Visualizer
```


```python
from pylabrobot.resources.hamilton import STARLetDeck
```


```python
lh = LiquidHandler(backend=LiquidHandlerChatterboxBackend(), deck=STARLetDeck())
```

Calling {func}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.setup` will print out "Setting up the robot" and also that two resources were assigned: the deck and the trash. Other than that, the chatter box backend has no setup to do.


```python
await lh.setup()
```

    Setting up the liquid handler.


Next, we will create a {class}`~pylabrobot.visualizer.visualizer.Visualizer` object. The Visualizer expects a Resource, and we will pass the {class}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler` object to it. This will allow us to visualize the robot's state and actions.


```python
vis = Visualizer(resource=lh)
await vis.setup()
```

    Websocket server started at http://127.0.0.1:2121
    File server started at http://127.0.0.1:1337 . Open this URL in your browser.


![The empty simulator](./img/visualizer/empty.png)

## Build the deck layout: Assigning plates and tips

When resources are assigned to the root resource of the Visualizer, in this case `lh`, they will automatically appear in the visualization.


```python
from pylabrobot.resources import (
    TIP_CAR_480_A00,
    PLT_CAR_L5AC_A00,
    Cor_96_wellplate_360ul_Fb,
    hamilton_96_tiprack_1000uL_filter
)
```


```python
tip_car = TIP_CAR_480_A00(name='tip carrier')
tip_car[0] = tip_rack1 = hamilton_96_tiprack_1000uL_filter(name='tips_01', with_tips=False)
tip_car[1] = tip_rack2 = hamilton_96_tiprack_1000uL_filter(name='tips_02', with_tips=False)
tip_car[2] = tip_rack3 = hamilton_96_tiprack_1000uL_filter(name='tips_03', with_tips=False)
tip_car[3] = tip_rack4 = hamilton_96_tiprack_1000uL_filter(name='tips_04', with_tips=False)
tip_car[4] = tip_rack5 = hamilton_96_tiprack_1000uL_filter(name='tips_05', with_tips=False)
```


```python
lh.deck.assign_child_resource(tip_car, rails=15)
```


```python
plt_car = PLT_CAR_L5AC_A00(name='plate carrier')
plt_car[0] = plate_1 = Cor_96_wellplate_360ul_Fb(name='plate_01')
plt_car[1] = plate_2 = Cor_96_wellplate_360ul_Fb(name='plate_02')
plt_car[2] = plate_3 = Cor_96_wellplate_360ul_Fb(name='plate_03')
```


```python
lh.deck.assign_child_resource(plt_car, rails=8)
```

![The simulator after the resources have been assigned](./img/visualizer/assignment.png)

### Configuring the state of the deck

As with every PyLabRobot script, you have the option of updating the state of the deck before you actually start your method. This will allow PyLabRobot to keep track of what is going on, enabling features like {func}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.return_tips` and catching errors (like missed tips) before a command would be executed on the robot. With the visualizer, this state has the additional effect of updating the visualization.

### Tips

Let's use {func}`~pylabrobot.resources.tip_rack.fill` to place tips at all spots in the tip rack in location `0`.


```python
tip_rack1.fill()
```


You can precisely control the presence of tips using {func}`~pylabrobot.resources.tip_rack.set_tip_state`. This function allows you to set whether there is a tip in each {class}`~pylabrobot.resources.tip_rack.TipSpot`.


```python
tip_rack4 = lh.deck.get_resource("tips_04")
tip_rack4.set_tip_state([True]*48 + [False]*48)
```


```python
tip_rack3.set_tip_state(([True]*8 +[False]*8)*6)
```


```python
tip_rack2.set_tip_state(([True]*16 +[False]*16)*3)
```

### Liquids

Adding liquid to wells works similarly. You can use {func}`~pylabrobot.resources.plate.set_well_liquids` to set the liquid in each well of a plate. Each liquid is represented by a tuple where the first element corresponds to the type of liquid and the second to the volume in uL. Here, `None` is used to designate an unknown liquid.


```python
plate_1.set_well_volumes([500]*96)
```


```python
plate_2.set_well_volumes([100, 500]*(96//2))
```

In the visualizer, you can see that the opacity of the well is proportional to how full the well is relative to its maximum volume.

![Simulator after the tips have been placed and the volumes adjusted](./img/visualizer/resources.png)

## Liquid handling

Once the layout is complete, you can run the same commands as described in the [basic liquid handling tutorial](../00_liquid-handling/hamilton-star/basic).

It is important that both tip tracking and volume tracking are enabled globally, so that the visualizer can keep track of the state of the tips and the volumes of the liquids.


```python
from pylabrobot.resources import set_tip_tracking, set_volume_tracking
set_tip_tracking(True), set_volume_tracking(True)
```




    (None, None)



### Picking up tips

Note that since we are using the {class}`~pylabrobot.liquid_handling.backends.chatterbox.ChatterboxBackend`, we just print out "Picking up tips" instead of actually performing an operation. The visualizer will show the tips being picked up.


```python
await lh.pick_up_tips(tip_rack1["A1", "B2", "C3", "D4"])
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tips_01_tipspot_A1   0,0,0            HamiltonTip  1065             8                    95.1             Yes       
      p1: tips_01_tipspot_B2   0,0,0            HamiltonTip  1065             8                    95.1             Yes       
      p2: tips_01_tipspot_C3   0,0,0            HamiltonTip  1065             8                    95.1             Yes       
      p3: tips_01_tipspot_D4   0,0,0            HamiltonTip  1065             8                    95.1             Yes       



```python
await lh.drop_tips(tip_rack1["A1", "B2", "C3", "D4"])
```

    Dropping tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tips_01_tipspot_A1   0,0,0            HamiltonTip  1065             8                    95.1             Yes       
      p1: tips_01_tipspot_B2   0,0,0            HamiltonTip  1065             8                    95.1             Yes       
      p2: tips_01_tipspot_C3   0,0,0            HamiltonTip  1065             8                    95.1             Yes       
      p3: tips_01_tipspot_D4   0,0,0            HamiltonTip  1065             8                    95.1             Yes       


### Aspirating and dispensing


```python
await lh.pick_up_tips(tip_rack1["A1"])
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tips_01_tipspot_A1   0,0,0            HamiltonTip  1065             8                    95.1             Yes       



```python
await lh.aspirate(plate_1["A2"], vols=[200])
```

    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 200.0    plate_01_well_A2     0,0,0            None       None       None       



```python
await lh.dispense(plate_2["A1"], vols=[200])
```

    Dispensing:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 200.0    plate_02_well_A1     0,0,0            None       None       None       



```python
await lh.return_tips()
```

    Dropping tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tips_01_tipspot_A1   0,0,0            HamiltonTip  1065             8                    95.1             Yes       


### Aspirating using CoRe 96

The CoRe 96 head supports liquid handling operations for 96 channels at once. Here's how to use:

- {func}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.pick_up_tips96` for picking up 96 tips;
- {func}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.aspirate96` for aspirating liquid from an entire plate at once;
- {func}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.dispense96` for dispensing liquid to an entire plate at once;
- {func}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.drop_tips96` for dropping tips to the tip rack.



```python
await lh.pick_up_tips96(tip_rack1)
```

    Picking up tips from tips_01.



```python
await lh.aspirate96(plate_1, volume=100)
```

    Aspirating 100.0 from Plate(name='plate_01', size_x=127.76, size_y=85.48, size_z=14.2, location=Coordinate(000.000, 000.000, -03.030)).



```python
await lh.dispense96(plate_3, volume=100)
```

    Dispensing 100.0 to Plate(name='plate_03', size_x=127.76, size_y=85.48, size_z=14.2, location=Coordinate(000.000, 000.000, -03.030)).



```python
await lh.drop_tips96(tip_rack1)
```

    Dropping tips to tips_01.


![The simulator after the liquid handling operations completed](./img/visualizer/after_lh.png)

## Shutting down

When you're done, you can stop the visualizer by calling {func}`~pylabrobot.visualizer.visualizer.Visualizer.stop`. This will stop the visualization.


```python
await vis.stop()
```



# aP Validation Against Log File Example

All communication between PLR and the outside world (the hardware) happens through the io layer. This is a layer below backends, and is responsible for sending and receiving messages to and from the hardware. Schematically,

```
Frontends <-> backends <-> io <-> hardware
```

PLR supports capturing all communication in the io layer, both write and read commands. This can later be played back to validate that a protocol has not changed. The key here is that if we send the same commands to the hardware, the hardware will do the same thing. "Reading" data (from the capture file) is useful because some protocols are dynamic and depend on responses from the hardware.

In this notebook, we will run a simple protocol on a robot while capturing all data passing through the io layer. We will then replay the capture file while executing the protocol again to demonstrate how validation works. Finally, we slightly modify the protocol and show that the validation fails.

## Defining a simple protocol


```python
import pylabrobot
from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.liquid_handling.backends import STARBackend
from pylabrobot.resources.hamilton import STARDeck

backend = STARBackend()
lh = LiquidHandler(backend=backend, deck=STARDeck())
```


```python
from pylabrobot.resources import TIP_CAR_480_A00, hamilton_96_tiprack_1000ul
tip_car = TIP_CAR_480_A00(name="tip_car")
tip_car[0] = tr = hamilton_96_tiprack_1000ul(name="ht")
lh.deck.assign_child_resource(tip_car, rails=1)
```


```python
async def simple_protocol(tips):
  await lh.setup()
  await lh.pick_up_tips(tips)
  await lh.return_tips()
  await lh.stop()
```

## Capturing data during protocol execution

Do a real run first, without validating against a capture file. This will generate the capture file you can later compare against.

While it might seem cumbersome, this actually ensures you have a real working protocol before doing validation. The benefit of using capture files is whenever you change your protocol and have seen it run, you can just grab the capture file and use it for validation. No need to manually write tests.


```python
validation_file = "./validation.json"
pylabrobot.start_capture(validation_file)
await simple_protocol(tr["A1:H1"])
pylabrobot.stop_capture()
```

    Validation file written to validation.json


The validation file is just json:


```python
!head -n15 validation.json
```

    {
      "version": "0.1.6",
      "commands": [
        {
          "module": "usb",
          "device_id": "[0x8af:0x8000][][]",
          "action": "write",
          "data": "C0RTid0001"
        },
        {
          "module": "usb",
          "device_id": "[0x8af:0x8000][][]",
          "action": "read",
          "data": "C0RTid0001er00/00rt0 0 0 0 0 0 0 0"
        },


## Replaying the capture file for validation

On validation, before calling setup, run `pylabrobot.validate` to enable the validation. Pass a capture file that contains the commands we should check against.

Call `pylabrobot.end_validation` at the end to make sure there are no remaining commands in the capture file. This marks the end of the validation.


```python
pylabrobot.validate(validation_file)
await simple_protocol(tr["A1:H1"])
pylabrobot.end_validation()
```

    Validation successful!


## Failing validation

When validation is not successful, we use the Needleman-Wunsch algorithm to find the difference between the expected and the actual output.


```python
pylabrobot.validate(validation_file)
await simple_protocol(tr["A2:H2"])
pylabrobot.end_validation()
```

    expected: C0TPid0009xp01179 01179 01179 01179 01179 01179 01179 01179yp1458 1368 1278 1188 1098 1008 0918 0828tm1 1 1 1 1 1 1 1tt01tp2266tz2166th2450td0
    actual:   C0TPid0009xp01269 01269 01269 01269 01269 01269 01269 01269yp1458 1368 1278 1188 1098 1008 0918 0828tm1 1 1 1 1 1 1 1tt01tp2266tz2166th2450td0
                            ^^    ^^    ^^    ^^    ^^    ^^    ^^    ^^                                                                                    



    ---------------------------------------------------------------------------

    ValidationError                           Traceback (most recent call last)

    Cell In[7], line 2
          1 pylabrobot.validate(validation_file)
    ----> 2 await simple_protocol(tr["A2:H2"])
          3 pylabrobot.end_validation()


    Cell In[3], line 3, in simple_protocol(tips)
          1 async def simple_protocol(tips):
          2   await lh.setup()
    ----> 3   await lh.pick_up_tips(tips)
          4   await lh.return_tips()
          5   await lh.stop()


    File ~/retro/pylabrobot/pylabrobot/machines/machine.py:35, in need_setup_finished.<locals>.wrapper(*args, **kwargs)
         33 if not self.setup_finished:
         34   raise RuntimeError("The setup has not finished. See `setup`.")
    ---> 35 return await func(*args, **kwargs)


    File ~/retro/pylabrobot/pylabrobot/liquid_handling/liquid_handler.py:467, in LiquidHandler.pick_up_tips(self, tip_spots, use_channels, offsets, **backend_kwargs)
        464   (self.head[channel].commit if success else self.head[channel].rollback)()
        466 # trigger callback
    --> 467 self._trigger_callback(
        468   "pick_up_tips",
        469   liquid_handler=self,
        470   operations=pickups,
        471   use_channels=use_channels,
        472   error=error,
        473   **backend_kwargs,
        474 )


    File ~/retro/pylabrobot/pylabrobot/liquid_handling/liquid_handler.py:2204, in LiquidHandler._trigger_callback(self, method_name, error, *args, **kwargs)
       2202   callback(self, *args, error=error, **kwargs)
       2203 elif error is not None:
    -> 2204   raise error


    File ~/retro/pylabrobot/pylabrobot/liquid_handling/liquid_handler.py:451, in LiquidHandler.pick_up_tips(self, tip_spots, use_channels, offsets, **backend_kwargs)
        449 error: Optional[Exception] = None
        450 try:
    --> 451   await self.backend.pick_up_tips(ops=pickups, use_channels=use_channels, **backend_kwargs)
        452 except Exception as e:
        453   error = e


    File ~/retro/pylabrobot/pylabrobot/liquid_handling/backends/hamilton/STAR.py:1484, in STAR.pick_up_tips(self, ops, use_channels, begin_tip_pick_up_process, end_tip_pick_up_process, minimum_traverse_height_at_beginning_of_a_command, pickup_method)
       1481 pickup_method = pickup_method or tip.pickup_method
       1483 try:
    -> 1484   return await self.pick_up_tip(
       1485     x_positions=x_positions,
       1486     y_positions=y_positions,
       1487     tip_pattern=channels_involved,
       1488     tip_type_idx=ttti,
       1489     begin_tip_pick_up_process=begin_tip_pick_up_process,
       1490     end_tip_pick_up_process=end_tip_pick_up_process,
       1491     minimum_traverse_height_at_beginning_of_a_command=minimum_traverse_height_at_beginning_of_a_command,
       1492     pickup_method=pickup_method,
       1493   )
       1494 except STARFirmwareError as e:
       1495   if plr_e := convert_star_firmware_error_to_plr_error(e):


    File ~/retro/pylabrobot/pylabrobot/liquid_handling/backends/hamilton/STAR.py:98, in need_iswap_parked.<locals>.wrapper(self, *args, **kwargs)
         93 if self.iswap_installed and not self.iswap_parked:
         94   await self.park_iswap(
         95     minimum_traverse_height_at_beginning_of_a_command=int(self._iswap_traversal_height * 10)
         96   )
    ---> 98 result = await method(self, *args, **kwargs)
        100 return result


    File ~/retro/pylabrobot/pylabrobot/liquid_handling/backends/hamilton/STAR.py:4062, in STAR.pick_up_tip(self, x_positions, y_positions, tip_pattern, tip_type_idx, begin_tip_pick_up_process, end_tip_pick_up_process, minimum_traverse_height_at_beginning_of_a_command, pickup_method)
       4055 assert (
       4056   0 <= end_tip_pick_up_process <= 3600
       4057 ), "end_tip_pick_up_process must be between 0 and 3600"
       4058 assert (
       4059   0 <= minimum_traverse_height_at_beginning_of_a_command <= 3600
       4060 ), "minimum_traverse_height_at_beginning_of_a_command must be between 0 and 3600"
    -> 4062 return await self.send_command(
       4063   module="C0",
       4064   command="TP",
       4065   tip_pattern=tip_pattern,
       4066   read_timeout=60,
       4067   xp=[f"{x:05}" for x in x_positions],
       4068   yp=[f"{y:04}" for y in y_positions],
       4069   tm=tip_pattern,
       4070   tt=f"{tip_type_idx:02}",
       4071   tp=f"{begin_tip_pick_up_process:04}",
       4072   tz=f"{end_tip_pick_up_process:04}",
       4073   th=f"{minimum_traverse_height_at_beginning_of_a_command:04}",
       4074   td=pickup_method.value,
       4075 )


    File ~/retro/pylabrobot/pylabrobot/liquid_handling/backends/hamilton/base.py:247, in HamiltonLiquidHandler.send_command(self, module, command, auto_id, tip_pattern, write_timeout, read_timeout, wait, fmt, **kwargs)
        222 """Send a firmware command to the Hamilton machine.
        223 
        224 Args:
       (...)
        237   A dictionary containing the parsed response, or None if no response was read within `timeout`.
        238 """
        240 cmd, id_ = self._assemble_command(
        241   module=module,
        242   command=command,
       (...)
        245   **kwargs,
        246 )
    --> 247 resp = await self._write_and_read_command(
        248   id_=id_,
        249   cmd=cmd,
        250   write_timeout=write_timeout,
        251   read_timeout=read_timeout,
        252   wait=wait,
        253 )
        254 if resp is not None and fmt is not None:
        255   return self._parse_response(resp, fmt)


    File ~/retro/pylabrobot/pylabrobot/liquid_handling/backends/hamilton/base.py:267, in HamiltonLiquidHandler._write_and_read_command(self, id_, cmd, write_timeout, read_timeout, wait)
        258 async def _write_and_read_command(
        259   self,
        260   id_: Optional[int],
       (...)
        264   wait: bool = True,
        265 ) -> Optional[str]:
        266   """Write a command to the Hamilton machine and read the response."""
    --> 267   self.io.write(cmd.encode(), timeout=write_timeout)
        269   if not wait:
        270     return None


    File ~/retro/pylabrobot/pylabrobot/io/usb.py:325, in USBValidator.write(self, data, timeout)
        323 if not next_command.data == data.decode("unicode_escape"):
        324   align_sequences(expected=next_command.data, actual=data.decode("unicode_escape"))
    --> 325   raise ValidationError("Data mismatch: difference was written to stdout.")


    ValidationError: Data mismatch: difference was written to stdout.




# Using Trackers

Trackers in PyLabRobot are objects that keep track of the state of the deck throughout a protocol. Two types of trackers currently exist: tip trackers (tracking the presence of tips in tip racks and on the pipetting channels) and volume trackers (tracking the volume in pipetting tips and wells).


```python
from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.liquid_handling.backends.chatterbox import LiquidHandlerChatterboxBackend
from pylabrobot.resources import (
  TIP_CAR_480_A00,
  hamilton_96_tiprack_1000uL_filter,
  PLT_CAR_L5AC_A00,
  Cor_96_wellplate_360ul_Fb,
  set_tip_tracking,
  set_volume_tracking
)
from pylabrobot.resources.hamilton import STARLetDeck

lh = LiquidHandler(backend=LiquidHandlerChatterboxBackend(num_channels=8), deck=STARLetDeck())
await lh.setup()
```

    Setting up the liquid handler.



```python
tip_carrier = TIP_CAR_480_A00(name="tip carrier") # initialize a tip carrier
```


```python
plt_carrier = PLT_CAR_L5AC_A00(name="plate carrier") # initialize a plate carrier
```

We enable tip and volume tracking globally using the `set_volume_tracking` and `set_tip_tracking` methods.


```python
set_volume_tracking(enabled=True)
set_tip_tracking(enabled=True)
```

## Tip trackers

The tip tracker is a simple class that keeps track of the current tip, and the previous operations that have been performed on an object. This enables features like {meth}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler.return_tips` and automated tip type detection.

### Initializing tip racks

Whether or not tip tracking is turned on, spots on a tip rack initialize with a tip tracker that defaults to having a tip. The tip tracker only comes into play with performing operations.


```python
tip_carrier[0] = tip_rack = hamilton_96_tiprack_1000uL_filter(name="tip rack")
```


```python
tip_rack.get_item("A1").tracker.has_tip
```




    True



To initialize a tip rack without tips, pass `with_tips=False`:


```python
tip_carrier[1] = empty_tip_rack = hamilton_96_tiprack_1000uL_filter(name="empty tip rack", with_tips=False)
```


```python
empty_tip_rack.get_item("A1").tracker.has_tip
```




    False



To "empty" a tip rack after initialization, use the {meth}`~pylabrobot.resources.TipRack.empty()` method. To "fill" a tip rack after initialization, use the {meth}`~pylabrobot.resources.TipRack.fill()` method.


```python
empty_tip_rack.fill()
empty_tip_rack.get_item("A1").tracker.has_tip
```




    True




```python
empty_tip_rack.empty()
empty_tip_rack.get_item("A1").tracker.has_tip
```




    False




```python
lh.deck.assign_child_resource(tip_carrier, rails=3)
```

### Tip tracker errors

The tip tracker is most useful for catching hardware errors before they happen. With tip tracking turned on, the following errors can be raised:


```python
from pylabrobot.resources.errors import HasTipError, NoTipError
```

#### `NoTipError` when picking up a tip

This error is raised when the tip tracker is trying to access a spot that has no tip.


```python
await lh.pick_up_tips(tip_rack[0])
await lh.drop_tips(empty_tip_rack[0])

try:
  await lh.pick_up_tips(tip_rack[0])
except NoTipError as e:
  print("As expected:", e)
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_A1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       
    Dropping tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: empty tip rack_tipspot_A1 0,0,0            HamiltonTip  1065             8                    95.1             Yes       
    As expected: Tip spot does not have a tip.


#### `HasTipError` when dropping a tip

This error is raised when the tip tracker is trying to access a spot that has a tip.


```python
await lh.pick_up_tips(tip_rack[1])

try:
  await lh.drop_tips(empty_tip_rack[0])
except HasTipError as e:
  print("As expected:", e)
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_B1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       
    As expected: Tip spot already has a tip.



```python
await lh.drop_tips(empty_tip_rack[1])
```

    Dropping tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: empty tip rack_tipspot_B1 0,0,0            HamiltonTip  1065             8                    95.1             Yes       


#### `NoTipError` when dropping a tip

This error is raised when the tip tracker is trying to use a channel that has no tip.


```python
try:
  await lh.drop_tips(empty_tip_rack[2])
except NoTipError as e:
  print("As expected:", e)
```

    As expected: Channel 0 does not have a tip.


#### `HasTipError` when picking up a tip

This error is raised when the tip tracker is trying to use a channel that has a tip.


```python
await lh.pick_up_tips(tip_rack[2])

try:
  await lh.pick_up_tips(tip_rack[3])
except HasTipError as e:
  print("As expected:", e)
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_C1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       
    As expected: Channel has tip


### Disabling the tip tracker

The tip tracker can be disabled in three different ways, depending on the desired behavior.

#### Using a context manager

The {meth}`pylabrobot.resources.no_tip_tracking` context manager can be used to disable the tip tracker for a set of operations.

Note that we use the {meth}`pylabrobot.liquid_handling.liquid_handler.LiquidHandler.clear_head_state` method to forget the tips that are currently mounted on the channels. This is needed because even though the tip tracker is disabled, the channels still keep track of the tips that are mounted on them.


```python
lh.clear_head_state()
```


```python
from pylabrobot.resources import no_tip_tracking

with no_tip_tracking():
  await lh.pick_up_tips(tip_rack[4])
  await lh.pick_up_tips(tip_rack[4], use_channels=[1]) # no error
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_E1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       
    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p1: tip rack_tipspot_E1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       


#### For a single tip spot

The tip tracker can be disabled for a single object by calling {meth}`pylabrobot.resources.tip_tracker.TipTracker.disable()` on the tracker object.


```python
lh.clear_head_state()
```


```python
tip_rack.get_item(5).tracker.disable()

await lh.pick_up_tips(tip_rack[5])
await lh.pick_up_tips(tip_rack[5], use_channels=[1]) # no error

tip_rack.get_item(5).tracker.enable()
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_F1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       
    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p1: tip rack_tipspot_F1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       


### For a single tip rack

Disable the tip tracker for a single tip rack by calling {meth}`pylabrobot.resources.TipRack.disable_tip_trackers()` and {meth}`pylabrobot.resources.TipRack.enable_tip_trackers()` on the tip rack object.


```python
lh.clear_head_state()
```


```python
tip_rack.disable_tip_trackers()

await lh.pick_up_tips(tip_rack[5])
await lh.pick_up_tips(tip_rack[5], use_channels=[1]) # no error

tip_rack.enable_tip_trackers()
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_F1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       
    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p1: tip rack_tipspot_F1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       


#### Globally

The tip tracker can be disabled globally by using {meth}`pylabrobot.resources.set_tip_tracking`.


```python
lh.clear_head_state()
```


```python
from pylabrobot.resources import set_tip_tracking

set_tip_tracking(enabled=False)

await lh.pick_up_tips(tip_rack[6])
await lh.pick_up_tips(tip_rack[6], use_channels=[1]) # no error

set_tip_tracking(enabled=True)
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_G1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       
    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p1: tip rack_tipspot_G1  0,0,0            HamiltonTip  1065             8                    95.1             Yes       


## Volume trackers

The volume tracker is a simple class that keeps track of the current volume, and the previous operations that have been performed on an object. This enables features like automated liquid class selection in STAR, and raises errors before they happen on the robot.

### Initializing wells

Wells automatically initialize with a volume tracker that defaults to having no volume.


```python
plt_carrier[0] = plate = Cor_96_wellplate_360ul_Fb(name="plate")
```


```python
plate.get_item("A1").tracker.get_used_volume()
```




    0




```python
plate.get_item("A1").tracker.get_free_volume()
```




    360




```python
plate.get_item("A1").tracker.set_volume(10)
plate.get_item("A1").tracker.get_used_volume(), plate.get_item("A1").tracker.get_free_volume()
```




    (10, 350)




```python
lh.deck.assign_child_resource(plt_carrier, rails=9)
```

### Inspecting volume tracker operation history


```python
await lh.aspirate(plate["A1"], vols=[10])
plate.get_item("A1").tracker.get_used_volume(), plate.get_item("A1").tracker.get_free_volume()
```

    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 10.0     plate_well_A1        0,0,0            None       None       None       





    (0.0, 360.0)




```python
await lh.dispense(plate["A1"], vols=[10])
plate.get_item("A1").tracker.get_used_volume(), plate.get_item("A1").tracker.get_free_volume()
```

    Dispensing:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 10.0     plate_well_A1        0,0,0            None       None       None       





    (10.0, 350.0)



### Volume tracker errors


```python
from pylabrobot.resources.volume_tracker import TooLittleLiquidError, TooLittleVolumeError
```

#### `TooLittleLiquidError` when dispensing

This error is raised when the volume tracker is trying to dispense from a tip that has less liquid than the requested volume.


```python
try:
  await lh.dispense(plate["A1"], vols=[100]) # this is less liquid than is currently in the tip
except TooLittleLiquidError as e:
  print("As expected:", e)
```

    As expected: Not enough liquid in container: 100.0uL > 0.0uL.


#### `TooLittleVolumeError` when aspirating

This error is raised when the volume tracker is trying to aspirate from a tip that has less free volume than the requested volume.


```python
lh.clear_head_state()
await lh.pick_up_tips(tip_rack[8])
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_A2  0,0,0            HamiltonTip  1065             8                    95.1             Yes       



```python
# fill the first two columns
for i in range(16):
  plate.get_item(i).tracker.set_volume(100)

try:
  # aspirate from the first two columns - this is more liquid than the tip can hold
  for i in range(16):
    await lh.aspirate(plate[i], vols=[100])
except TooLittleVolumeError as e:
  print("As expected:", e)
```

    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_A1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_B1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_C1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_D1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_E1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_F1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_G1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_H1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_A2        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_B2        0,0,0            None       None       None       
    As expected: Not enough space in container: 100.0uL > 65.0uL.


#### `TooLittleLiquidError` when aspirating

This error is raised when trying to dispense into a well that has less free volume than the requested volume.


```python
try:
  await lh.aspirate(plate["A1"], vols=[100]) # this is less liquid than is currently in the well
except TooLittleLiquidError as e:
  print("As expected:", e)
```

    As expected: Not enough liquid in container: 100.0uL > 0.0uL.


#### `TooLittleVolumeError` when dispensing

This error is raised when trying to aspirate from a well that has less liquid than the requested volume.


```python
lh.clear_head_state()
await lh.pick_up_tips(tip_rack[9])
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tip rack_tipspot_B2  0,0,0            HamiltonTip  1065             8                    95.1             Yes       



```python
# fill the first column
for i in range(8):
  plate.get_item(i).tracker.set_volume(100)

try:
  # aspirate liquid from the first column into the first well
  for i in range(1, 8):
    await lh.aspirate(plate[i], vols=[100])
    await lh.dispense(plate["A1"], vols=[100])
except TooLittleVolumeError as e:
  print("As expected:", e)
```

    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_B1        0,0,0            None       None       None       
    Dispensing:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_A1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_C1        0,0,0            None       None       None       
    Dispensing:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_A1        0,0,0            None       None       None       
    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_well_D1        0,0,0            None       None       None       
    As expected: Not enough space in container: 100.0uL > 60.0uL.




# Use of Iterators & Generators

In the `pylabrobot.resources.functional` module, we have utilities for looping through tip spots in one or more tip racks. They support caching to disk, so that you can resume where you left off if your script is interrupted.


```python
# instantiate some hamilton tip racks as an example
from pylabrobot.resources.hamilton import hamilton_96_tiprack_1000uL # an example tip rack
tip_rack_0 = hamilton_96_tiprack_1000uL(name='tip_rack_0')
tip_rack_1 = hamilton_96_tiprack_1000uL(name='tip_rack_1')
tip_racks = [tip_rack_0, tip_rack_1]
```

Tip spot generators take a list of tip spots (`list[TipSpot]`) as an argument. With `F.get_all_tip_spots`, you can get all tip spots in one or more tip racks. The tip spots will be column-first, i.e. the first tip spot is the top left corner, the second tip spot is the one below it, and so on.


```python
import pylabrobot.resources.functional as F
tip_spots = F.get_all_tip_spots(tip_racks)
tip_spots[0]
```




    TipSpot(name='tip_rack_0_tipspot_0_0', location=Coordinate(007.200, 068.300, -83.500), size_x=9.0, size_y=9.0, size_z=0, category=tip_spot)



## Basic linear generator 

The linear generator will loop through all tip spots in the order they are given, with the option to repeat.


```python
linear_generator = F.linear_tip_spot_generator(
  tip_spots=tip_spots,                      # the list of tip spots to use
  cache_file_path="./linear_cache.json",    # load/save tip spot cache for state in between runs
  repeat=False,                             # don't repeat the tip spots if they run out
)
```

Tip spot generators are asynchronous, so use `await` and `__anext__` to get the next tip spot.


```python
await linear_generator.__anext__()
```




    TipSpot(name='tip_rack_0_tipspot_1_4', location=Coordinate(016.200, 032.300, -83.500), size_x=9.0, size_y=9.0, size_z=0, category=tip_spot)



Get multiple tips at once by using `get`:


```python
[ts.name for ts in await linear_generator.get(5)]
```




    ['tip_rack_0_tipspot_1_5',
     'tip_rack_0_tipspot_1_6',
     'tip_rack_0_tipspot_1_7',
     'tip_rack_0_tipspot_2_0',
     'tip_rack_0_tipspot_2_1']



Get the number of tip spots left by calling `get_num_tips_left`.


```python
linear_generator.get_num_tips_left()
```




    174



Save the state of the generator at an arbitrary point by calling `save_state`. This method will be called automatically when the program crashes or is interrupted.


```python
linear_generator.save_state()
```

Override the index by calling `set_index`.


```python
linear_generator.set_index(12)
await linear_generator.__anext__()
```




    TipSpot(name='tip_rack_0_tipspot_1_4', location=Coordinate(016.200, 032.300, -83.500), size_x=9.0, size_y=9.0, size_z=0, category=tip_spot)



## Randomized generator

The randomized generator will loop through all tip spots in a random order, with the option to repeat. If repeating, set the parameter `K` to not sample a tip spot that has been sampled in the last `K` samples.


```python
random_generator = F.randomized_tip_spot_generator(
  tip_spots=tip_spots,                      # the list of tip spots to use
  cache_file_path="./random_cache.json",    # load/save tip spot cache for state in between runs
  K=10,                                     # don't sample tip spots that have been used in the last K samples
)
```


```python
await random_generator.__anext__()
```




    TipSpot(name='tip_rack_0_tipspot_3_2', location=Coordinate(034.200, 050.300, -83.500), size_x=9.0, size_y=9.0, size_z=0, category=tip_spot)



Get multiple tips at once by using `get`:


```python
[ts.name for ts in await random_generator.get(5)]
```




    ['tip_rack_0_tipspot_0_3',
     'tip_rack_0_tipspot_5_0',
     'tip_rack_1_tipspot_6_6',
     'tip_rack_0_tipspot_9_3',
     'tip_rack_0_tipspot_0_5']





# SiLA Device Discovery

[SiLA](https://sila-standard.com/) is a communication standard used by many lab instruments. PyLabRobot can discover both SiLA 1 and SiLA 2 devices on the local network:

- **SiLA 1** devices are found via NetBIOS broadcast + SOAP `GetDeviceIdentification`
- **SiLA 2** devices advertise via mDNS (`_sila._tcp.local.`)

## Requirements

SiLA 1 discovery works out of the box (no extra dependencies). SiLA 1 devices typically use link-local addresses (169.254.x.x).

For SiLA 2 discovery (mDNS):

```bash
pip install zeroconf
```

Your computer must be on the same network (or VLAN) as the instruments you want to discover.

## Usage


```python
from pylabrobot.io.sila.discovery import discover

devices = await discover(timeout=5.0)
print(f"Found {len(devices)} device(s)")
for device in devices:
  print(device)
```

`discover()` runs SiLA 1 (NetBIOS + SOAP) and SiLA 2 (mDNS) probes in parallel, listening for `timeout` seconds. It returns a list of `SiLADevice` objects:

| Attribute          | Type            | Description                           |
|--------------------|-----------------|---------------------------------------|
| `host`             | `str`           | IP address (e.g. `192.168.1.42`)      |
| `port`             | `int`           | Service port (e.g. `8080` or `8091`)  |
| `name`             | `str`           | Device name                           |
| `serial_number`    | `Optional[str]` | Serial number (SiLA 1 only, else `None`) |
| `firmware_version` | `Optional[str]` | Firmware version (SiLA 1 only, else `None`) |
| `sila_version`     | `int`           | `1` or `2`                            |

## Example: connecting to the first device found

You can use the discovered host and port directly when creating a backend:

```python
from pylabrobot.io.sila.discovery import discover

devices = await discover()
assert len(devices) > 0, "No SiLA devices found"
device = devices[0]

# Pass device.host and device.port to your backend
backend = SomeBackend(host=device.host, port=device.port)
```

## Command-line tool

You can also discover devices from the terminal:

```bash
python -m pylabrobot.io.sila.discovery
```

Use `-t` to change the timeout (default 5 seconds):

```bash
python -m pylabrobot.io.sila.discovery -t 10
```

For SiLA 1 devices on a specific link-local interface:

```bash
python -m pylabrobot.io.sila.discovery --interface 169.254.183.87
```

Output is tab-delimited, one device per line:

```
169.254.151.99	8080	ODTC_1A3C93	SiLA 1	S/N:12345
192.168.1.42	8091	ImageXpress-Pico	SiLA 2
```



# Agilent VSpin

The VSpin centrifuge is controlled by the {class}`~pylabrobot.centrifuge.vspin_backend.VSpinBackend` class.


```python
from pylabrobot.centrifuge import Centrifuge, VSpinBackend
vspin_backend = VSpinBackend()  # VSpinBackend(device_id="YOUR_FTDI_ID_HERE")
cf = Centrifuge(name = "centrifuge", backend = vspin_backend, size_x= 1, size_y=1, size_z=1)
await cf.setup()
```

Before you can use the "go to bucket" commands, you need to calibrate the bucket positions. See [below](#calibrating-bucket-1-position) for instructions.


```python
await cf.go_to_bucket1()
```


```python
await cf.go_to_bucket2()
```


```python
await cf.spin(
  g=800,
  duration=60,   # seconds
  acceleration=1.0,  # 0-1
  deceleration=1.0,  # 0-1
)
```

Status commands


```python
await vspin_backend.get_door_locked()
```


```python
await vspin_backend.get_door_open()
```


```python
await vspin_backend.get_bucket_locked()
```

## Calibrating bucket 1 position

You need to calibrate the bucket 1 position for every vspin once. There are two ways to do this:
1. Manually: Move bucket 1 to the correct position using the physical controls on the centrifuge.
2. Programmatically: Use the `go_to_position` command to move bucket 1 to the correct position.

With bucket 1 in the correct position, save it with `cf.backend.set_bucket_1_position_to_current()`. This will save the calibration for the current centrifuge to disk at `~/.pylabrobot/vspin_bucket_calibrations.json` (based on the usb serial number).

### Moving using code

Use `vspin_backend.go_to_position` to move the buckets to the correct position. A full rotation is 8000 ticks, so 4.5 degrees per 100 ticks.


```python
await vspin_backend.go_to_position(100)
```


```python
await vspin_backend.set_bucket_1_position_to_current()
```

### Manually rotating

You can open the door unlock the bucket and manually rotate the buckets to the desired position.

```{warning}
High risk / high reward! The vspin has a safety mechanism that will close the door when it detects movement.
This means the door will close when you rotate the buckets manually too fast.
Be careful or it will eat your fingers!
It will save time compared to using code though.
```


```python
await cf.open_door()
await vspin_backend.unlock_bucket()
```

Manually rotate buckets to align bucket 1 with door


```python
await vspin_backend.set_bucket_1_position_to_current()
```

## Loader

The VSpin can optionally be used with a loader (called Access2). The loader is optional because you can also use a robotic arm like an iSWAP to move a plate directly into the centrifuge.

When using the loader, you must specify the FTDI device ids for both devices because both use FTDI and are otherwise indistinguishable. See [below](#2-finding-the-ftdi-id) for how to find the device ids.

Here's how to use the loader:


```python
import asyncio

from pylabrobot.centrifuge import Access2, VSpinBackend
vspin_backend = VSpinBackend(device_id="YOUR_VSPIN_FTDI_ID_HERE")
centrifuge, loader = Access2(name="name", vspin=vspin_backend, device_id="YOUR_LOADER_FTDI_ID_HERE")

# initialize the centrifuge and loader in parallel
await asyncio.gather(
  centrifuge.setup(),
  loader.setup()
)

# go to a bucket and open the door before loading
await centrifuge.go_to_bucket1()
await centrifuge.open_door()

# assign a plate to the loader before loading. This can also be done implicitly by for example
# lh.move_plate(plate, loader)
from pylabrobot.resources import Cor_96_wellplate_360ul_Fb
plate = Cor_96_wellplate_360ul_Fb(name="plate")
loader.assign_child_resource(plate)

# load and unload the plate
await loader.load()
await loader.unload()
```

## Installation

The VSpin centrifuge connects to your system via a COM port. Integrating it with `pylabrobot` library requires some setup. Follow this guide to get started.

### 1. Installing libftdi

#### macOS

Install libftdi using [Homebrew](https://brew.sh/):

```bash
brew install libftdi
```

#### Linux

Debian (rpi) / Ubuntu etc:

```bash
sudo apt-get install libftdi-dev
```

Other distros have similar packages.

#### Windows

**Find Your Python Directory**

To use the necessary FTDI `.dll` files, you need to locate your Python environment:

1. Open Python in your terminal:
   ```python
   python
   >>> import sys
   >>> sys.executable
   ```
2. This will print a path, e.g., `C:\Python39\python.exe`.
3. Navigate to the `Scripts` folder in the same directory as `python.exe`.

**Download FTDI DLLs**

Download the required `.dll` files from the following link:
[FTDI Development Kit](https://sourceforge.net/projects/picusb/files/libftdi1-1.5_devkit_x86_x64_19July2020.zip/download) (link will start download).

1. Extract the downloaded zip file.
2. Locate the `bin64` folder.
3. Copy the files named:
   - `libftdi1.dll`
   - `libusb-1.0.dll`

**Place DLLs in Python Scripts Folder**

Paste the copied `.dll` files into the `Scripts` folder of your Python environment. This enables Python to communicate with FTDI devices.

**Configuring the Driver with Zadig**

Use Zadig to replace the default driver of the VSpin device with `libusbk`:

1. **Identify the VSpin Device**

   - Open Zadig.
   - To confirm the VSpin device, disconnect the RS232 port from the centrifuge while monitoring the Zadig device list.
   - The device that disappears is your VSpin, likely titled "USB Serial Converter."

2. **Replace the Driver**
   - Select the identified VSpin device in Zadig.
   - Replace its driver with `libusbk`.
   - Optionally, rename the device to "VSpin" for easy identification.

> **Note:** If you need to revert to the original driver for tools like the Agilent Centrifuge Config Tool, go to **Device Manager** and uninstall the `libusbk` driver. The default driver will reinstall automatically.

### 2. Finding the FTDI ID

To interact with the centrifuge programmatically, you need its FTDI device ID. Use the following steps to find it:

1. Open a terminal and run:
   ```bash
   python -m pylibftdi.examples.list_devices
   ```
2. This will output something like:
   ```
   FTDI:USB Serial Converter:FTE0RJ5T
   ```
3. Copy the ID (`FTE0RJ5T` or your equivalent).

You’re now ready to use your VSpin centrifuge with `pylabrobot`!



# Hamilton HEPA Fan

| Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Photo                                            |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| - OEM Link (none exists?)<br>- **Communication Protocol / Hardware**: Serial (FTDI)/ USB-A<br>- **Communication Level**: Firmware<br>- Old HEPA CAP discontinued in 2020, replaced with Clean Air Protection (CAP) Fan (Hamilton cat. no.: 92173-22)<br>- Old HEPA CAP VID:PID 0856:ac11 "USOPTL4"<br>- Adds 321 mm to height of STAR(let)<br>- Takes in ambient air, filters it and supplies it to the inside of the STAR(let) | ![quadrants](img/hamilton-old-hepa-cap.png) |



---
## Setup Instructions (Physical)

The Hamilton HEPA Fan for a STAR or STARlet liquid handling workstation has to be placed on top of the machines chassis.

It requires two cable connections to be operational:
1. Power cord (standard IEC C13); if you are using an older HEPA Fan model ensure that the voltage switch is set to your country's mains voltage!
2. USB cable (USB-B with at fan end; USB-A at control PC end)

---
## Setup Instructions (Programmatic)


```python
from pylabrobot.only_fans import Fan
from pylabrobot.only_fans import HamiltonHepaFanBackend
```


```python
fan = Fan(backend=HamiltonHepaFanBackend()) 
# NB.: fans are only machines, they are not modelled as resources -> require no str name

await fan.setup()
```

---

## Usage / Machine Features

Running for 60 seconds:


```python
await fan.turn_on(intensity=100, duration=30)
```

Running until stop:


```python
await fan.turn_on(intensity=100)
```


```python
await fan.turn_off()
```



# Hamilton Heater Shaker

The Hamilton Heater Shaker is a `HeaterShaker` machine that enables:
- heating, 
- locking & unlocking, and
- (orbital) shaking

...of plates (active cooling is not possible with this machine).

- [manufacturer_link](https://www.hamiltoncompany.com/automated-liquid-handling/small-devices/hamilton-heater-shaker?srsltid=AfmBOooBVzRaBrPj4UYumvbcbECIxj4lk_0jpJDjMrLksnFJPOgNURm6)
- Temperature control = RT+5°C to 105°C (all variants)
- Variants:
    - Cat. no.: 199027  
        - shaking orbit = 1.5 mm  
        - shaking speed = 100 - 1800 rpm
    - Cat. no.: 199033  
        - shaking orbit = 2.0 mm  
        - shaking speed = 100 - 2500 rpm
    - Cat. no.: 199034  
        - shaking orbit = 3.0 mm  
        - shaking speed = 100 - 2400 rpm  
        - max. loading = 500 grams  

- Footprint: size_x = 146.2, size_y = 103.8, size_z=74.11

---
## Setup Instructions (Physical)

A Hamilton Heater Shaker (hhs) can be used through two different **control interfaces**:
- a **control box**, called the `HamiltonHeaterShakerBox`: this supports connection of up to **8 heater shakers** per control box, OR
- **directly plugging** the hhs **into a Hamilton STAR liquid handler**: STAR liquid handlers have 2 RS232 ports on their left side, and can therefore support up to **2 heater shakers** simultaneously.

When using the **heater shaker box control interface** a USB-B cable is plugged into one of the heater shakers and connected to the host computer.
This heater shaker is connected via a serial port to the control box. Other heater shakers are also plugged into the control box using serial cables, but not plugged into the computer.
The first heater shakers serves as a gateway.

When using the **Hamilton STAR interface**, the Heater Shaker is connected via a serial interface:
- Connection: STAR (RS232) ⇄ Host computer (USB-A)

The heater shaker is then controlled through the STAR Liquid Handler.

---
## Setup Instructions (Programmatic)

In either case, `HamiltonHeaterShakerBackend` will be the backend and `HeaterShaker` will be the frontend.
Depending on the interface you use, pass a different argument to `HamiltonHeaterShakerBackend`.

**hs_box_control**:
As multiple heater shakers can be controlled through one USB connection to the computer (a cable to HHS 0 when using the control box), the `index` of a specific heater shaker needs to be specified. It needs to be set to 0 for the HHS that is connected via a USB cable to the computer.
Note that this also requires turing a DIP switch on the bottom of the HHS module.

**star_control**:
Each heater shaker is connected via a separate cable to the STAR liquid handler.
The back RS232 port corresponds to `index=1` and the front RS232 port corresponds to `index=2`.


```python
interface_choice = "star_control" # hs_box_control VS star_control
```


```python
if interface_choice == "hs_box_control":
    
    # Setting up a backend with the HamiltonHeaterShakerBox
    from pylabrobot.heating_shaking import HamiltonHeaterShakerBackend, HamiltonHeaterShakerBox
    
    control_interface = hhs_box = HamiltonHeaterShakerBox()

elif interface_choice == "star_control":
    
    # Alternative: setting up a backend with a STAR
    from pylabrobot.liquid_handling import LiquidHandler, STARBackend
    from pylabrobot.resources import STARDeck
    from pylabrobot.heating_shaking import HamiltonHeaterShakerBackend
    
    control_interface = star_backend = STARBackend()

    # Control via a STAR requires instantiation of the STAR liquid handler
    lh = LiquidHandler(backend=star_backend, deck=STARDeck())

else:
    raise ValueError(f"Interface choice invalid: {interface_choice}")

backend = HamiltonHeaterShakerBackend(
    index=0,
    interface=control_interface
)
```


```python
from pylabrobot.heating_shaking import HeaterShaker
from pylabrobot.resources.coordinate import Coordinate

hs = HeaterShaker(
  name="Hamilton HeaterShaker",
  backend=backend,
  size_x=146.2,
  size_y=103.8,
  size_z=74.11,
  child_location=Coordinate(x=9.66, y=9.22, z=74.11),
)
```

Note that you will need to call `hhs_box.setup()` before calling `HeaterShaker.setup()`.
When using a `STAR`, just use `star.setup()` or, more likely, `lh.setup()`.
This is opening the USB connection to the device you are using as an interface.

Note that setup should only be called ONCE:
- when using a STAR as a liquid handler, just call `lh.setup()`.
(Do not call it again when using the heater shaker.)
- when using multiple heater shakers with the control box, call `.setup()` once for the control box, and then call `HeaterShaker.setup()` for each heater shaker.
(Do not call `setup` again for the control box.)


```python
if interface_choice == "hs_box_control":
    
    # When using the HamiltonHeaterShakerBox, you need to call setup() on the box
    await hhs_box.setup()

elif interface_choice == "star_control":

    # Alternative: when using the STAR, you need to call setup() on lh
    await lh.setup()
```

After calling `setup` on your interface, call `HeaterShaker.setup()` for each heater shaker machine.
This will initialize the `HeaterShaker` machine itself.


```python
await hs.setup()
```

### Assigning a Hamilton Heater Shaker to the deck

Before you can use the Hamilton Heater Shaker in combination with a Hamilton STAR liquid handler, you need to assign it to the deck. This is needed when, for example, you want to use the iSWAP or CoRe grippers to move a plate to or from the heater shaker. This is also required to get the heater shaker to show up in the Visualizer.

Here's one example of assigning a Hamilton Heater Shaker to the deck using a `MFX_CAR_P3_SHAKER`. Note that you can use any carrier, or even directly place heater shakers on the deck if you like. See the [Hamilton STAR resources page](/resources/library/hamilton) for carriers.


```python
from pylabrobot.resources.hamilton.mfx_carriers import MFX_CAR_P3_SHAKER
shaker_carrier = MFX_CAR_P3_SHAKER(name="shaker_carrier", modules={0: hs2, 1: hs1, 2: hs0})
lh.deck.assign_child_resource(shaker_carrier, rails=5)
```

---
## Usage

### Heating Control


```python
await hs.get_temperature() # Temperature of sensor in the middle of the heater shaker in C
```




    25.6



The HHS also supports reading the temperature at the edge of the heater shaker:


```python
await hs.backend.get_edge_temperature()
```




    25.7




```python
await hs.set_temperature(37) # Temperature in degrees C
```




    'T1TAid0004er00'




```python
await hs.wait_for_temperature()  # Wait for the temperature to stabilize
```

### Shaking Control


```python
await hs.lock_plate()
```


```python
await hs.shake(
  speed=100, # rpm
  direction=0, # seconds
  acceleration=1000, # rpm/sec
) 
```


```python
await hs.stop_shaking()
```


```python
await hs.unlock_plate()
```

### Closing Connection to Machine


```python
await hs.stop()
```

---
## Using Multiple Hamilton Heater Shakers

### 1x hs_box - Multiple HHS

When using multiple heater shakers, you can use the `HamiltonHeaterShakerBackend` class to control them. This class will automatically handle the communication with the control box and the individual heater shakers.

As above, initialize the `HamiltonHeaterShakerBox` class. Then, initialize as many `HamiltonHeaterShakerBackend` classes as you want to control, specifying the index for each. Note that each `HamiltonHeaterShakerBackend` gets the same instance of the `HamiltonHeaterShakerBox`: this is because there is a single USB connection, managed by that instance.


```python
control_interface = hhs_box = HamiltonHeaterShakerBox()

# HS1
backend1 = HamiltonHeaterShakerBackend(index=1, interface=control_interface)
hs1 = HeaterShaker(
  name="Hamilton HeaterShaker",
  backend=backend1,
  size_x=146.2,
  size_y=103.8,
  size_z=74.11,
  child_location=Coordinate(x=9.66, y=9.22, z=74.11),
)

# HS2
backend2 = HamiltonHeaterShakerBackend(index=2, interface=control_interface)
hs2 = HeaterShaker(
  name="Hamilton HeaterShaker",
  backend=backend2,
  size_x=146.2,
  size_y=103.8,
  size_z=74.11,
  child_location=Coordinate(x=9.66, y=9.22, z=74.11),
)
```

For setup, call `setup` on the `HamiltonHeaterShakerBox` instance. This will setup the USB connection to the control box. Then, call `setup` on each `HamiltonHeaterShakerBackend` instance. This will setup the individual heater shakers.


```python
await hhs_box.setup()

for hs in [hs1, hs2]:
  await hs.setup()
```

### 1x STAR - 2x hhs



```python
control_interface = star_backend = STARBackend()

# Control via a STAR requires instantiation of the STAR liquid handler
lh = LiquidHandler(backend=star_backend, deck=STARDeck())

# HS1
backend1 = HamiltonHeaterShakerBackend(index=1, interface=control_interface)

hs1 = HeaterShaker(
  name="Hamilton HeaterShaker",
  backend=backend1,
  size_x=146.2,
  size_y=103.8,
  size_z=74.11,
  child_location=Coordinate(x=9.66, y=9.22, z=74.11),
)

# HS2
backend2 = HamiltonHeaterShakerBackend(index=2, interface=control_interface)

hs2 = HeaterShaker(
  name="Hamilton HeaterShaker",
  backend=backend2,
  size_x=146.2,
  size_y=103.8,
  size_z=74.11,
  child_location=Coordinate(x=9.66, y=9.22, z=74.11),
)
```


```python
await lh.setup()

for hs in [hs1, hs2]:
  await hs.setup()
```



# Hello World, Inheco ThermoShake!

The Inheco Thermoshake is a heater-cooler-shaker machine that enables:
- heating & cooling,
- locking & unlocking, and
- (orbital) shaking

...of plates.

- Temperature control = 4°C to 105°C (all variants, max. 25°C difference to RT in cooling mode)
- Variants:
  - **Inheco ThermoShake RM** ([manufacturer link](https://www.inheco.com/thermoshake-classic.html))
    - PLR name: `inheco_thermoshake_rm`
    - Cat. no.: 7100144
    - status: PLR-tested
    - shaking orbit = 2.0 mm  
    - shaking speed = 100 - 2000 rpm
    - footprint: size_x=147 mm, size_y=104 mm, size_z=116 mm
  - **Inheco ThermoShake** ([manufacturer link](https://www.inheco.com/thermoshake-classic.html))
    - PLR name: `inheco_thermoshake`
    - Cat. no.: 7100146
    - status: PLR-untested (should have the same API as RM)
    - shaking orbit = 2.0 mm  
    - shaking speed = 100 - 2000 rpm
    - footprint: size_x=147 mm, size_y=104 mm, size_z=118 mm
  - **Inheco ThermoShake AC** ([manufacturer link](https://www.inheco.com/thermoshake-ac.html))
    - PLR name: `inheco_thermoshake_ac`
    - Cat. no.: 7100160 & 7100161
    - status: PLR-untested (should have the same API as RM)
    - shaking orbit = 2.0 mm  
    - shaking speed = 300 - 3000 rpm
    - footprint: size_x=147 mm, size_y=104 mm, size_z=115.9 mm

Check out the [Thermoshake User and installation manual](https://www.inheco.com/data/pdf/thermoshake-manual-1013-1049-33.pdf) for more information.

---

## Setup Instructions (Physical)

See the [Inheco TemperatureController user guide](../temperature-controllers/inheco.ipynb#setup-instructions-physical) for instructions on using multiple ThermoShakes with one control box. The instructions are the same as for the Inheco CPAC.

---
## Usage


```python
from pylabrobot.heating_shaking import HeaterShaker
from pylabrobot.temperature_controlling import InhecoTECControlBox

control_box = InhecoTECControlBox()
await control_box.setup()
```


```python
from pylabrobot.heating_shaking import inheco_thermoshake
hs = inheco_thermoshake(
  name="Inheco Thermoshake",
  control_box=control_box,
  index=1,
)
await hs.setup()
type(hs)  # pylabrobot.heating_shaking.HeaterShaker
```




    pylabrobot.heating_shaking.heater_shaker.HeaterShaker



### Temperature Control

See the [Inheco TemperatureController user guide](../temperature-controllers/inheco.ipynb#temperature-control) for temperature control instructions. They are the same for ThermoShake as they are for the Inheco CPAC.

### Shaking Control

The {meth}`~pylabrobot.heating_shaking.heater_shaker.HeaterShaker.setup` method is used to initialize the machine. This is where the backend will connect to the scale and perform any necessary initialization.

The {class}`~pylabrobot.heating_shaking.heater_shaker.HeaterShaker` class has a number of methods for controlling the temperature and shaking of the sample. These are inherited from the {class}`~pylabrobot.temperature_controllers.temperature_controller.TemperatureController` and {class}`~pylabrobot.shakers.shaker.Shaker` classes.

- {meth}`~pylabrobot.heating_shaking.heater_shaker.HeaterShaker.set_temperature`: Set the temperature of the module.
- {meth}`~pylabrobot.heating_shaking.heater_shaker.HeaterShaker.get_temperature`: Get the current temperature of the module.
- {meth}`~pylabrobot.heating_shaking.heater_shaker.HeaterShaker.shake`: Set the shaking speed of the module.
- {meth}`~pylabrobot.heating_shaking.heater_shaker.HeaterShaker.stop_shaking`: Stop the shaking of the module.

Shake indefinitely:


```python
await hs.shake(speed=100)  # speed in rpm
```


```python
await hs.stop_shaking()  # Stop shaking
```

Shake for 10 seconds:


```python
await hs.shake(
  speed=100,
  duration=10
)  # speed in rpm, duration in seconds
```

### Closing Connection to Machine


```python
await hs.stop()
```

---
## Using Multiple Inheco Devices

See the [Inheco TemperatureController user guide](../temperature-controllers/inheco.ipynb#using-multiple-inheco-devices) for instructions on using multiple ThermoShakes with one control box. The instructions are the same as for the Inheco CPAC.



# QInstruments BioShake

The QInstruments BioShake is a series of heater-cooler-shaker machines that enables:
- heating & cooling,
- locking & unlocking, and
- (orbital) shaking

...of plates, depending on the model.

Because all models share the same firmware, the table below lists every model supported by this backend, as well as what features they support. If a feature is called on a model that doesn't support it (e.g. shaking on a Heatplate), then a 'not supported' error will be rasied.

| Model Name                 | Shaking (rpm) | Plate Lock | Heating | Active Cooling |
|----------------------|---------------|------------|---------|----------------|
| BioShake Q1          | 200-3000      | ✔️         | ✔️       | ✔️              |
| BioShake Q2          | 200-3000      | ✔️         | ✔️       | ✔️              |
| BioShake 3000        | 200-3000      | ❌         | ❌       | ❌              |
| BioShake 3000 elm    | 200-3000      | ✔️         | ❌       | ❌              |
| BioShake 3000 elm DWP| 200-3000      | ✔️         | ❌       | ❌              |
| BioShake D30 elm     | 200-2000      | ✔️         | ❌       | ❌              |
| BioShake 5000 elm    | 200-5000      | ✔️         | ❌       | ❌              |
| BioShake 3000-T      | 200-3000      | ❌         | ✔️       | ❌              |
| BioShake 3000-T elm  | 200-3000      | ✔️         | ✔️       | ❌              |
| BioShake D30-T elm   | 200-2000      | ✔️         | ✔️       | ❌              |
| Heatplate            | none          | ❌         | ✔️       | ❌              |
| ColdPlate            | none          | ❌         | ✔️       | ✔️              |


Check out the [BioShake integration manual](https://www.qinstruments.com/fileadmin/Article/All/integration-manual-en-1-8-0.pdf) for more information (or this [manual](https://www.qinstruments.com/fileadmin/Article/MANUALS/Integration-manual-en.pdf) for the Q1 and Q2 models, specifically.)

---

## Setup Instructions (Physical)

Please refer to the above manuals for instructions on connecting the BioShake devices to the computer. They can be connected via RS232 or USB-A port and must be plugged into a 24 VDC power supply.

---
## Usage


```python
from pylabrobot.heating_shaking import HeaterShaker
from pylabrobot.heating_shaking import BioShake
from pylabrobot.resources.coordinate import Coordinate

str_port = "COM1"  # Replace with the actual port connected to your computer
backend = BioShake(port=str_port)
hs = HeaterShaker(
  name="BioShake",
  size_x=0,  # TODO: physical size
  size_y=0,  # TODO: physical size
  size_z=0,  # TODO: physical size
  child_location=Coordinate(0, 0, 0),  # TODO: physical size
  backend=backend)
```

When calling `setup`, the user has the option to home the device or not. By default, the device will reset (clearing any error it's stuck in) before moving to the home zero position and locks in place. This process should take no longer than 30 seconds.


```python
await hs.setup(skip_home=False) # Or 'True' if you wish to skip the process
```

### Temperature Control

For models that support temperature control, please use the following call functions:


```python
await hs.set_temperature(temperature=37) # Temperature in degrees C
```


```python
await hs.get_temperature() # Returns temperature in degrees C
```


```python
await hs.deactivate() # Stop temperature control
```

### Shaking Control

For models that support shaking and/or plate locking, please use the following call functions:


```python
await hs.lock_plate()
```


```python
await hs.unlock_plate()
```

BioShake supports acceleration for shaking and deceleration for stopping. Acceleration and deceleration correspond to the seconds it takes till it reaches full speed. The default value is 0, where it starts and stops at normal velocity. Any value higher will result in a slow acceleration/deceleration.


```python
await hs.shake(speed=500, acceleration=0)  # speed in rpm
```


```python
await hs.stop_shaking(deceleration=5)  # Stop shaking
```

### Closing Connection to Machine


```python
await hs.stop()
```

---
## Using Multiple BioShake Devices

When using multiple BioShake devices, you may call them in batches.


```python
import asyncio


async def setup_and_shake(hs):
  await hs.setup(skip_home=False)
  await hs.shake(speed=500)

await asyncio.gather(
  setup_and_shake(hs1),
  setup_and_shake(hs2),
  setup_and_shake(hs3),
  setup_and_shake(hs4),
)
```



# PreciseFlex PF400 and PF3400 robots

Connection: ethernet


```python
%load_ext autoreload
%autoreload 2
```


```python
from pylabrobot.arms.scara import ExperimentalSCARA
from pylabrobot.arms.precise_flex.pf_400 import PreciseFlex400Backend

from pylabrobot.arms.precise_flex.coords import PreciseFlexCartesianCoords
from pylabrobot.arms.precise_flex.joints import PFAxis
from pylabrobot.resources import Coordinate, Rotation
```


```python
backend = PreciseFlex400Backend(host="192.168.0.1", port=10100, has_rail=False)
arm = ExperimentalSCARA(backend=backend)
```


```python
await arm.setup(skip_home=False)
```

## Granular Robot control

### Gripper Control

The gripper can be controlled manually as follows:


```python
await arm.close_gripper(gripper_width=80)
```


```python
await arm.open_gripper(gripper_width=120)
```


```python
await backend.is_gripper_closed()
```

### Movement

You can also arbitrarily move the arm to cartesian coordinates as well as joint coordinates:

```{warning}
Depending on the current position, moving to a joint position might actually cause the arm to collide with its base! Be careful when using joint coordinates.
```


```python
location = {
  PFAxis.BASE: 99.981,
  PFAxis.SHOULDER: -36.206,
  PFAxis.ELBOW: 83.063,
  PFAxis.WRIST: -331.7,
  PFAxis.GRIPPER: 126.084,
  PFAxis.RAIL: 0.0,
}
await arm.move_to(location)
```


```python
location = PreciseFlexCartesianCoords(
  location=Coordinate(x=290, y=659, z=100),
  rotation=Rotation(x=-180.0, y=90.0, z=84.804)
)
await arm.move_to(location)
```

## Getting current location

Get the joint angles of the robot's arm, including the rails if applicable and the gripper width:


```python
await arm.get_joint_position()
```

Get the cartesian coordinates of the robot's end effector:


```python
await arm.get_cartesian_position()
```

## Teaching positions using free mode

Use "free mode" to manually move the robot's arm to a desired position, and then read the current cartesian coordinates. You can use the cartesian coordinates to programmatically move the arm to that position later.


```python
await backend.activate_free_mode()
```


```python
await arm.get_cartesian_position()
```


```python
await backend.deactivate_free_mode()
```

## Plate Movement

Below is an example of picking up and placing a plate using cartesian coordinates. You can call `move_to` in between to move to other locations as needed.


```python
location = PreciseFlexCartesianCoords(
  location=Coordinate(x=650.74, y=-345.922, z=5.05),
  rotation=Rotation(x=180.0, y=90.0, z=-9.921)
)
```


```python
await arm.pick_up_resource(
  location,
  plate_width=125,
)
```


```python
await arm.drop_resource(location)
```

## Miscellaneous commands

Move the arm to its predefined home/safe position:


```python
await arm.move_to_safe()
```

Home the arm:


```python
await arm.home()
```

Stop any ongoing movement of the arm:


```python
await arm.halt()
```



# TFS Cytomat Series

The Cytomat series of incubators is used for storing microplates under
controlled environmental conditions. PyLabRobot implements the
{class}`~pylabrobot.storage.cytomat.cytomat.CytomatBackend` which
supports several models such as `C6000`, `C6002`, `C2C_50`, `C2C_425`,
`C2C_450_SHAKE` and `C5C`.

In this tutorial we show how to:
- connect to the incubator
- configure racks
- move plates in and out
- monitor temperature and humidity

```{note}
This notebook uses `await` statements which must be run inside an
asynchronous environment such as `asyncio`.
```


```python
from pylabrobot.storage import CytomatBackend, CytomatType
from pylabrobot.storage.cytomat.racks import cytomat_rack_9mm_51
from pylabrobot.storage.incubator import Incubator
from pylabrobot.resources.corning.plates import Cor_96_wellplate_360ul_Fb
from pylabrobot.resources import Coordinate

# Connect to the incubator via a serial port
backend = CytomatBackend(model=CytomatType.C6000, port="/dev/ttyUSB0")

# Create a rack and assemble an `Incubator` resource
rack = cytomat_rack_9mm_51("rack_A")
incubator = Incubator(
    backend=backend,
    name="cyto",
    size_x=860,
    size_y=550,
    size_z=900,
    racks=[rack],
    loading_tray_location=Coordinate(0, 0, 0),
)
```

## Setup

Setting up the incubator opens the serial connection and initializes the
device.


```python
await incubator.setup()
```

## Storing a plate

To store a plate we first place it on the loading tray and then call
{meth}`~pylabrobot.storage.incubator.Incubator.take_in_plate`.
You can choose a site automatically or specify one explicitly.



```python
plate = Cor_96_wellplate_360ul_Fb("my_plate")
incubator.loading_tray.assign_child_resource(plate)
await incubator.take_in_plate("smallest")  # choose the smallest free site

# other options:
# await incubator.take_in_plate("random")  # random free site
# await incubator.take_in_plate(rack[3])  # store at rack position 3

```

## Retrieving a plate

Use {meth}`~pylabrobot.storage.incubator.Incubator.fetch_plate_to_loading_tray`
to move a plate from storage to the loading tray.


```python
await incubator.fetch_plate_to_loading_tray("my_plate")
retrieved = incubator.loading_tray.resource
```

## Monitoring conditions

The Cytomat provides queries for temperature and humidity.


```python
current_temp = await incubator.get_temperature()
current_humidity = await incubator.backend.get_humidity()
print(current_temp, current_humidity)
```

## Shutdown

Always close the connection when finished.


```python
await incubator.stop()
```



# Inheco SCILA

| Summary | Image |
|------------|--------|
| <ul style="font-size:15px; line-height:1.6; margin-top:0;"> <li>Automated CO&#8322;-controlled incubator with 4 independently accessible drawers for SBS-format plates.</li> <li><a href="https://www.inheco.com/scila.html" target="_blank"><b>OEM Link</b></a></li> <li><b>Communication Protocol / Hardware:</b> SiLA 2 (SOAP/HTTP) / Ethernet</li> <li><b>Communication Level:</b> SiLA 2 interface (documentation shared by OEM)</li> <li><b>4 independent drawers</b> for SBS-format plates</li> <li>Temperature control (single zone, all drawers)</li> <li>CO&#8322; and H&#8322;O valve monitoring</li> <li>Humidification reservoir level monitoring</li> <li>Only one drawer can be open at a time</li> </ul> | <div style="width:320px; text-align:center;"> ![scila](img/inheco_scila.png) <br><i>Figure: Inheco SCILA</i> </div> |

## Setup (Physical)

The SCILA communicates over Ethernet using the SiLA 2 protocol. To connect, you need:
1. The IP address of the SCILA on your network.
2. (Optional) The IP address of your client machine — auto-detected if omitted.

The backend starts a local HTTP server to receive asynchronous responses from the SCILA.

## Setup (Programmatic)


```python
import asyncio
```


```python
from pylabrobot.storage.inheco.scila import SCILABackend

scila = SCILABackend(scila_ip="169.254.1.117")
await scila.setup()
```

## Usage

### Status Requests

Device status (`"standBy"`, `"inError"`, `"startup"`, ...):


```python
await scila.request_status()
```




    'idle'



Water level in the built-in humidification reservoir (e.g. `"High"`, `"Low"`). The SCILA uses this reservoir to maintain humidity inside the drawers:


```python
await scila.request_liquid_level()
```




    'Empty'



Drawer status for all 4 drawers:


```python
await scila.request_drawer_status(1)
```




    'Closed'




```python
await scila.request_drawer_statuses()
```




    {1: 'Closed', 2: 'Closed', 3: 'Closed', 4: 'Closed'}



CO&#8322; and H&#8322;O valve status:


```python
await scila.request_valve_status()
```




    {'H2O': 'Opened', 'CO2 Normal': 'Opened', 'CO2 Boost': 'Closed'}



CO&#8322; flow status:


```python
await scila.request_co2_flow_status()
```




    'NOK'



Status of a single drawer:


```python
await scila.request_drawer_status(3)
```




    'Closed'



### Drawer Control

Only one drawer can be open at a time. Opening a second drawer while one is already open will raise an error.


```python
await scila.open(2)
```


```python
await scila.close(2)
```

### Temperature Control

The SCILA has a single temperature zone shared across all 4 drawers.

Current temperature in °C:


```python
await scila.measure_temperature()
```




    23.65




```python
await scila.start_temperature_control(37.0)
```

Check the target temperature and current temperature after starting:


```python
await scila.request_target_temperature()
```




    37.0




```python
await asyncio.sleep(4)

await scila.measure_temperature()
```




    24.53




```python
await scila.is_temperature_control_enabled()
```




    True



Stop temperature control and verify it is disabled:


```python
await scila.stop_temperature_control()
```


```python
await scila.is_temperature_control_enabled()
```




    False



## Closing Connection

Close the SiLA 2 HTTP server and disconnect from the SCILA.


```python
await scila.stop()
```



# Inheco Incubator (Shaker)

| Summary | Image |
|------------|--------|
| <ul style="font-size:15px; line-height:1.6; margin-top:0;"> <li><a href="https://www.inheco.com/incubator-shaker.html" target="_blank"><b>OEM Link</b></a></li> <li><b>Communication Protocol / Hardware:</b> Serial / USB-A/B</li> <li><b>Communication Level:</b> Firmware (documentation shared by OEM)</li> <li>Same command set for: <ul> <li>Incubator “MP”</li> <li>Incubator “DWP”</li> <li>Incubator Shaker “MP”</li> <li>Incubator Shaker “DWP”</li> </ul></li> <li>VID:PID <code>0403:6001</code></li> <li>Takes in a single plate via a loading tray, heats it to the set temperature, and shakes it to the set RPM.</li> </ul> | <div style="width:320px; text-align:center;"> ![shaker](img/inheco_incubator_shaker_mp_dwp.png) <br><i>Figure: Inheco Incubator Shaker MP & DWP models</i> </div> |


## About the Machine(s)

Inheco incubator shakers are modular machines used for plate storage, temperature control and shaking.
They differentiate themselves:
- **heater shakers** ... heat a material on which a plate is being placed; open-access; non-uniform temperature distribution around the plate; enables shaking of plate.
- **incubator shakers** ... an enclosed chamber that is being heated and houses a plate; plate access is controlled via a loading tray and a door; *highly uniform temperature distribution around the plate*; enables shaking of plate.

The Inheco incubator devices come in 4 versions, dependent on (1) whether they provide a shaking feature & (2) the size of plates they accept:


| **RTS Code** | **Shaking Feature** | **Plate Format** | **Device Identifier** | **Typical Model** |
|:-------------:|:--------------:|:----------------:|:----------------------|:------------------|
| `0` | ❌ No | MP (Microplate) | `incubator_mp` | INHECO Incubator MP | 
| `1` | ✅ Yes | MP (Microplate) | `incubator_shaker_mp` | INHECO Incubator Shaker MP | 
| `2` | ❌ No | DWP (Deepwell Plate) | `incubator_dwp` | INHECO Incubator DWP | 
| `3` | ✅ Yes | DWP (Deepwell Plate) | `incubator_shaker_dwp` | INHECO Incubator Shaker DWP | 


```{note}
Note: All 4 machines can be controlled with the same PyLabRobot Backend, called `InhecoIncubatorShakerBackend`!
```

---
## Setup Instructions (Physical)

![copy-me](img/inheco_incubator_shaker_physical_setup_overview.png)

To facilitate integration, multiple devices can be placed on top of each other to form an Incubator Shaker Stack (see infographic above), but care has to be taken to not overstrain the connections:

Each of the 4 different shaker types requires a different amount of power.
An easier way to identify the configurations possible is to think of "incubator power credits" - **no stack must exceed 5 power credits** (see User and Installation Manual):

1. An "incubator MP" -> 1 "incubator power credits" -> 5 units can be stacked on top of each other.
2. An "incubator DWP" -> 1.25 "incubator power credits" -> 4 units.
3. An "incubator shaker MP" -> 1.6 "incubator power credits" -> 3 units
4. An "incubator shaker DWP" -> 2.5 "incubator power credits" -> 2 units

However, the machines in a single stack can be of any of the 4 types.
This means you could create stacks of: 
- 2x "incubator DWP" (1.25 credits) + 1x "incubator shaker DWP" (2.5 credits)
- 3x "incubator MP" (1 credits) + 1x "incubator shaker MP" (1.6 credits) [shown in the infographic above]

When a stack would exceed more than 5 "incubator power credits", you **must build multiple stacks** (ask your Inheco sales representative if you are unsure before trying this out).

The benefit of this setup is that only **one** power cable and only **one** USB cable have to be plugged into the machine at the very bottom of a machine (i.e. stack index 0).
Machines above the bottom one only need to be connected with the machine below it using the 15-pin SUB-D connectors that come with each machine when bought from Inheco.

```{note}
Note: In PyLabRobot, the stack is the central control element and is controlled via its own instance of the `InhecoIncubatorShakerStackBackend`.
```

| Explanation | Image |
|------------|--------|
| <div style="font-size:15px; line-height:1.6; margin-top:0;"> To connect an <code>InhecoIncubatorShakerStackBackend</code> you must set the <b>DIP switch identifier</b> on the back of the bottom machine: <ul style="margin-left:20px;"> <li>located on the back of the bottom machine,</li> <li>defines the DIP switch configuration for the entire stack.</li> </ul> <h3>Setting the DIP switch to generate a machine address</h3> Each machine has a 4-pin DIP switch. Each pin can be <code>UP</code> (<code>0</code>) or <code>DOWN</code> (<code>1</code>). <br><br> <i>Note:</i> the two pins to the left of the DIP switch are not part of the addressing and should remain in the <code>DOWN</code> position. <br><br> This forms a <i>4-bit binary address</i>: <ul> <li>All pins at <code>0</code> → binary <code>0 0 0 0</code> → decimal <code>0</code></li> <li>All pins at <code>1</code> → binary <code>1 1 1 1</code> → decimal <code>15</code> (<code>2<sup>4</sup>-1</code>)</li> </ul> This address is crucial for generating valid communication commands for your Inheco stack. </div> | <div style="width:320px; text-align:center;"> ![dip switches](img/inheco_incubator_shaker_dip_switch_addressing.png) <br><i>Figure: DIP switch layout to generate different identifiers/addresses</i> </div> |


---
## Setup Instructions (Programmatic)

After the two cables have been connected to the bottom-most Inheco Incubator Shaker, you have to...
1. instantiate the `InhecoIncubatorShakerStackBackend` and give it the correct `dip_switch_id` & `stack_index`, and
2. create a `IncubatorShakerStack` frontend and give it the new backend instance.

The "stack" is the central interface to all units in it.
The stack automatically identifies all units inside it (including their type), and will create both the correct connection and a physical instance for it.

```{note}
Before a connection has been established the incubator shaker's front LED blinks.
After the connection has successfully been made, the LED will continuously be on.
```


```python
from pylabrobot.storage.inheco import IncubatorShakerStack, InhecoIncubatorShakerStackBackend

import asyncio # only needed for examples in this tutorial, optional for your purposes
import time # only needed for examples in this tutorial, optional for your purposes
```


```python
iis_stack_backend = InhecoIncubatorShakerStackBackend(dip_switch_id = 2)

iis_stack = IncubatorShakerStack(backend=iis_stack_backend)

await iis_stack.setup()
```

```{note}
If you are interested in seeing information about the machine you are connecting to, you can set the `.setup()` optional argument `verbose` to `True`:
1. serial port used for connection
2. DIP switch ID used and verified
3. number of units identified in the stack
4. composition (index and type of units) of the stack 
```

## Usage: Controlling Individual Units

### Addressing Units & Sensing Plate Presence

The stack interface enables fast, direct access to any machine in a stack.

Every Inheco incubator (shaker) contains an internal, reflection-based plate sensor.
(This is very useful e.g. when someone has forgotten their plate in the incubator 👀)

Let's use this as an example of how you can address different units in the stack individually:


```python
iis_stack.num_units
```




    2




```python
for idx in range(iis_stack.num_units):
  plate_presence_check = await iis_stack[idx].request_plate_in_incubator()
  print(idx, plate_presence_check)
```

    0 False
    1 False


Option 2: Addressing individual units by calling the stack backend with the correct stack_index


```python
for idx in range(iis_stack.num_units):
  plate_presence_check = await iis_stack.backend.request_plate_in_incubator(
    stack_index=idx
  )
  print(idx, plate_presence_check)
```

    0 False
    1 False


Option 3: Storing each unit as a handy variable


```python
incubator_shaker_0 = iis_stack[0]
plate_presence_check_0 = await incubator_shaker_0.request_plate_in_incubator()

incubator_shaker_1 = iis_stack[1]
plate_presence_check_1 = await incubator_shaker_1.request_plate_in_incubator()

print(plate_presence_check_0, plate_presence_check_1)
```

    False False


We usually use the direct indexing of the frontend method but it is up to you to choose.
e.g.: storing of units in separate variables can be very useful when using many stacks.

### Using Loading Tray


```python
for idx in range(iis_stack.num_units):
  await iis_stack[idx].open()
  await asyncio.sleep(2)
  await iis_stack[idx].close()
```

```{warning}
**On parallelization of commands to machines in the same incubator shaker stack**

Each machine in the same stack communicates via the same USB(-A to -B) cable.
As a result, if you send multiple commands at the same time, they will be queued and executed one after another.

This means you cannot open all incubator shakers in the same stack at the same time.

However, if you arrange your Inheco Incubators into different stacks this should still be possible.
```

### Temperature Control

Show current temperature in °C


```python
for idx in range(iis_stack.num_units):
  current_temp = await iis_stack[idx].get_temperature()
  print(current_temp)
```

    20.1
    23.6


Time how long the machine takes to reach target temperature using standard Python - no need to re-invent the wheel


```python
target_temperature = 37

await iis_stack[0].start_temperature_control(target_temperature)

start_time = time.time()
```

Quick check of how the temperature increases for 5 sec


```python
for x in range(5):
  current_temp = await iis_stack[0].get_temperature(sensor="main")
  print(current_temp)

  time.sleep(1)
```

    20.3
    20.7
    21.6
    22.6
    23.5


| Explanation | Image |
|------------|--------|
| <div style="font-size:15px; line-height:1.7; margin-top:0; padding-right:20px;"> <p>The Inheco Incubator (Shaker) contains three independent temperature sensors:</p> <ol style="margin-top:0; margin-bottom:10px; padding-left:20px;"> <li>main sensor — close to the door/front, inside the machine</li> <li>validation sensor — back, inside the machine</li> <li>boost sensor — on heating foil, inside the machine</li> </ol> <p>By default, <code>iis_stack[0].get_temperature()</code>’s argument is set to <code>sensor="main"</code>.<br> This can be changed to any of the following:</p> <ul style="margin-top:0; padding-left:20px;"> <li><code>"main"</code></li> <li><code>"dif"</code></li> <li><code>"boost"</code></li> <li><code>"mean"</code> — takes all three sensors’ measurements and returns their geometric mean</li> </ul> </div> | <div style="width:280px; text-align:center;"> ![sensor positions](img/inheco_incubator_shaker_t_sensor_positioning.png) <br><i style="font-size:13px; color:#6c757d;">Figure: Inheco Incubator Shaker Temperature Sensor Positioning</i> </div> |


Wait until target temperature has been reached:


```python
temp_reached = await iis_stack[0].wait_for_temperature(
  sensor = "mean",
  tolerance = 0.1, # ℃ - default: 0.2
  interval_s = 0.2, # sec - default: 0.5
  show_progress_bar = True # default: False
)

elapsed_time = time.time() - start_time

print(f"\ntime taken to reach target temperature {target_temperature}°C: {round(elapsed_time, 1)} sec")
```

Simple stopping of temperature control without stopping (i.e. breaking the connection) the machine itself:


```python
await iis_stack[0].stop_temperature_control()
```


```python
await iis_stack[0].is_temperature_control_enabled()
```




    False



### Shaking Control

Only Incubator "Shakers" can use shaking commands.

During `.setup()` the machine will check whether it is an `incubator_shaker` ("MP" or "DWP") and the Python backend only allows shaking commands being sent to the machine if it is an `incubator_shaker`, i.e. the following commands will not work if you have pure incubators.


```python
await iis_stack[0].shake(rpm=800)

await asyncio.sleep(5)

await iis_stack[0].stop_shaking()
```

Inheco incubator shakers support precise, programmable motion in both the **X** and **Y** axes.
The resulting shaking pattern is defined by five parameters:

- **Amplitude in X** (`Aₓ`, 0–3 mm)
- **Amplitude in Y** (`Aᵧ`, 0–3 mm)
- **Frequency in X** (`fₓ`, 6.6–30.0 Hz)
- **Frequency in Y** (`fᵧ`, 6.6–30.0 Hz)
- **Phase shift** (`φ`, the angular offset between X and Y motion, in degrees)

Different combinations of these parameters produce circular, linear, elliptical, or
figure-eight movement paths.

---

#### Predefined Shaking Patterns in PyLabRobot

To simplify configuration, PyLabRobot provides predefined motion presets that map common use cases to specific parameter combinations:

| Pattern | Description | Parameter relationship | Required speed attribute |
|----------|--------------|------------------------|---------------------------|
| `orbital` | Circular shaking | `Aₓ = Aᵧ`, `φ = 90°`, `fₓ = fᵧ` | `rpm` |
| `elliptical` | Elliptical motion | `Aₓ ≠ Aᵧ`, `φ = 90°`, `fₓ = fᵧ` | `rpm` |
| `figure_eight` | Figure-eight (Lissajous) motion | `Aₓ ≈ Aᵧ`, `φ = 90°`, `fᵧ = 2 fₓ` | `rpm` |
| `linear_x` | Linear motion along X | `Aᵧ = 0` | `frequency_hz` |
| `linear_y` | Linear motion along Y | `Aₓ = 0` | `frequency_hz` |

```{note}
The default behaviour of `.shake()` uses...
- an orbital shaking pattern,
- x amplitude = 3 mm,
- y amplitude = 3 mm.

(see “Simplest usage” example above)


Orbital shaking example with modified amplitudes


```python
await iis_stack[0].shake(
    pattern="orbital",
    rpm=800,
    amplitude_x_mm=2.0,
    amplitude_y_mm=2.0
)

await asyncio.sleep(5)

await iis_stack[0].stop_shaking()
```

Elliptical shaking example with modified amplitudes:


```python
await iis_stack[0].shake(
    pattern="elliptical",
    rpm=800,
    amplitude_x_mm=2.5,
    amplitude_y_mm=2.5
)

await asyncio.sleep(5)

await iis_stack[0].stop_shaking()
```

Figure-eight shaking example:


```python
await iis_stack[0].shake(
    pattern="figure_eight",
    rpm=400,
)

await asyncio.sleep(5)

await iis_stack[0].stop_shaking()
```

If you feel adventurous, see the math that goes into the calculation of different shaking patterns here:

<details>
<summary><b>📘 How PyLabRobot Implements Inheco Shaking Patterns (Mathematical Overview)</b></summary>

Inheco incubator shakers move a plate by oscillating the platform in two directions — **X** and **Y** — at programmable amplitudes, frequencies, and phase offsets.

---

**The Core Equations**

The motion of the platform is described by two sinusoidal functions:

\[
\begin{aligned}
x(t) &= Aₓ \sin(2\pi fₓ t) \\
y(t) &= Aᵧ \sin(2\pi fᵧ t + φ)
\end{aligned}
\]

Where:

| Symbol | Meaning | Example |
|:--|:--|:--|
| `Aₓ`, `Aᵧ` | Amplitudes (mm) — how far the plate moves in X and Y | 2.5 mm |
| `fₓ`, `fᵧ` | Frequencies (Hz) — how fast each axis oscillates | 10 Hz, 20 Hz |
| `φ` | Phase shift (°) — timing offset between X and Y | 0°, 90°, 180° |

Each axis moves smoothly back and forth like a spring.  
When these two motions combine, they trace elegant paths such as circles, ellipses, or figure-eights.

---

**Pattern Intuition**

Different shaking patterns are created by adjusting the relationships between these parameters:

| Pattern | Conditions | Description |
|:--|:--|:--|
| **Linear X** | `Aᵧ = 0` | Motion only along X (back-and-forth line) |
| **Linear Y** | `Aₓ = 0` | Motion only along Y |
| **Orbital** | `Aₓ = Aᵧ`, `fₓ = fᵧ`, `φ = 90°` | Perfect circular motion |
| **Elliptical** | `Aₓ ≠ Aᵧ`, `fₓ = fᵧ`, `φ = 90°` | Elongated circle (ellipse) |
| **Figure-Eight (Lissajous)** | `Aₓ ≈ Aᵧ`, `fᵧ = 2 fₓ`, `φ = 90°` | Double-loop path shaped like ∞ |

---

**Example: Figure-Eight Motion**

In firmware terms:

SSP20,20,100,200,90
ASE1


corresponds to:

- `Aₓ = Aᵧ = 2.0 mm`
- `fₓ = 10.0 Hz`
- `fᵧ = 20.0 Hz`
- `φ = 90°`

This combination makes the platform’s Y motion twice as fast as its X motion —  
the resulting path is a **Lissajous figure**, visually resembling a “figure-8”.

---

**Why This Matters**

By controlling these parameters precisely:
- The **mixing efficiency** can be tuned to the liquid’s viscosity.
- The **path geometry** affects shear stress and aeration.
- **Repeatable motion profiles** ensure reproducibility across runs.

Understanding this relationship helps you select the right pattern
(`orbital`, `elliptical`, `figure_eight`, etc.) for your experiment.

</details>



### Empowerment Showcase

With control of multiple single incubator shakers a whole array of complex experimental & optimisation processes is possible.

This PyLabRobot integration aims to make these machine powers as accessible as possible.

One still relatively simple example:
Parallelize shaking of different incubators with different shaking + temperature conditions ... did someone say "Design of Experiments" 👀📊


```python
await iis_stack[0].start_temperature_control(29)
await iis_stack[1].start_temperature_control(37)

await iis_stack[0].wait_for_temperature(sensor="mean", show_progress_bar=True)
await iis_stack[1].wait_for_temperature(sensor="mean", show_progress_bar=True)


await iis_stack[0].shake(
  pattern="orbital",
  rpm=500,
)

await iis_stack[1].shake(
  pattern="figure_eight",
  rpm=800,
)

await asyncio.sleep(10)

await iis_stack[0].stop_temperature_control()
await iis_stack[1].stop_temperature_control()

await iis_stack[0].stop_shaking()
await iis_stack[1].stop_shaking()
```

    Waiting for target temperature 29.00 °C...
    
    [████████████████████████████████████----] 29.20 °C  (Δ=0.20 °C | ETA:    3.0s)
    [OK] Target temperature reached.
    Waiting for target temperature 37.00 °C...
    
    [█████████████---------------------------] 36.87 °C  (Δ=0.13 °C | ETA:    4.3s)
    [OK] Target temperature reached.


### Self Test / Maintenance (PLR beta)

The Inheco firmware provides a "self-test" which checks the drawer, temperature and shaking features.
This test can take up to 5 min.

The test *must be* performed without a plate in the incubator.

It generates a binary code in which each position represents a machine subsystem:
- Bit 0: Drawer
- Bit 1: Homogeneity Sensor 3 versus Sensor 1 (>2 K)
- Bit 2: Homogeneity Sensor 2 versus Sensor 1 (>2 K)
- Bit 3: Sensor 1 doesn’t reach Target Temperature after 130 sec.
- Bit 4: Y-Amplitude Shaker
- Bit 5: X-Amplitude Shaker
- Bit 6: Phase Shift Shaker
- Bit 7: Y-Frequency Shaker
- Bit 8: X-Frequency Shaker
- Bit 9: Line Boost-Heater broken
- Bit 10: Line Main-Heater broken

A `0` means no error has been found for that subsystem, and a `1` means there is a hardware fault.


```python
await iis_stack[0].perform_self_test()
```




    {
      "drawer_error": False,
      "homogeneity_sensor_3_vs_1_error": False,
      "homogeneity_sensor_2_vs_1_error": False,
      "sensor_1_target_temp_error": False,
      "y_amplitude_shaker_error": False,
      "x_amplitude_shaker_error": False,
      "phase_shift_shaker_error": False,
      "y_frequency_shaker_error": False,
      "x_frequency_shaker_error": False,
      "line_boost_heater_broken": False,
      "line_main_heater_broken": False,
    }




This is a beta feature in PyLabRobot and we will verify the interpretation with the PyLabRobot supporting OEM, Inheco - all our machines appear to be fully functional, i.e. we couldn't check whether a faulty machine will correctly be flagged by this self-test.

---
## Usage: Master Control via the Stack Frontend 🦾

Even though loops make setting temperatures fast and efficient, we found it is too much code.

This is why we enabled the frontend to have "master control commands" for all units in a stack.

### Querying Statuses


```python
await iis_stack.request_loading_tray_states()
```




    {0: 'closed', 1: 'closed'}




```python
await iis_stack.request_temperature_control_states()
```




    {0: False, 1: False}




```python
await iis_stack.request_shaking_states()
```




    {0: False, 1: False}



### Master Commands - Loading Trays


```python
await iis_stack.open_all()

await iis_stack.request_loading_tray_states()
```




    {0: 'open', 1: 'open'}




```python
await iis_stack.close_all()

await iis_stack.request_loading_tray_states()
```




    {0: 'closed', 1: 'closed'}



### Master Commands - Temperature Control


```python
await iis_stack.start_all_temperature_control(target_temperature=37)

await asyncio.sleep(10)

await iis_stack.get_all_temperatures()
```




    {0: 37.8, 1: 34.4}




```python
await iis_stack.stop_all_temperature_control()
```

### Master Commands - Shaking Control


```python
await iis_stack.request_shaking_states()
```




    {0: False, 1: False}



## Closing Connection

Standard PyLabRobot way of closing the communication to the machine, i.e. the stack:


```python
await iis_stack.stop()
```

This stops all temperature control, and all shaking before disconnecting from the stack.

```{note}
If you develop a small script that you find yourself re-using and that goes beyond the simple "hello world, inheco incubator shaker"-style examples here, please consider contributing it back to the PyLabRobot community as a Cookbook Recipe.
```

---
## Usage: Multiple Stacks

To connect more than one machine stack:
- instantiate a separate backend and frontend for each,
- you **must** hand the serial port to each stack's backend explicitly

```{note}
When using one stack, PyLabRobot finds the machine's port automatically based on its unique VID:PID,
if multiple machines are found with the same VID:PID there is ambiguity
- e.g. the VSpin & Cytation 5 use the same identifier combo :')
```
- perform a setup for each stack. 

(set on the back of the bottom-most machine):



```python
iis_stack_backend_0 = InhecoIncubatorShakerStackBackend(dip_switch_id = 2, port="/dev/cu.usbserial-130")
iis_stack_0 = IncubatorShakerStack(backend=iis_stack_backend_0)
await iis_stack.setup(verbose=True)

iis_stack_backend_1 = InhecoIncubatorShakerStackBackend(dip_switch_id = 7, port="/dev/cu.usbserial-42")
iis_stack_1 = IncubatorShakerStack(backend=iis_stack_backend_1)
await iis_stack_1.setup(verbose=True)

iis_stack_backend_2 = InhecoIncubatorShakerStackBackend(dip_switch_id = 11, port="/dev/cu.usbserial-123")
iis_stack_2 = IncubatorShakerStack(backend=iis_stack_backend_2)
await iis_stack_2.setup(verbose=True)
```



# Hamilton Heater Cooler (HHC)

| Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Photo                                            |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| - [OEM Link](https://www.hamiltoncompany.com/temperature-control/hamilton-heater-cooler)<br>- **Communication Protocol / Hardware**: ? / ?<br>- **Communication Level**: Firmware <br><br>- **Temperature range**: 0 to 110°C<br> | ![quadrants](img/hamilton_heater_cooler.png) |


---
## Setup Instructions (Physical)

WIP

---
## Setup Instructions (Programmatic)

WIP


```python
%load_ext autoreload
%autoreload 2
```


```python
await hhc.setup()
```

---

## Usage

### Temperature control

WIP


```python
await hhc.set_temperature(70)
```


```python
await hhc.wait_for_temperature()
```


```python
await hhc.get_temperature()
```


```python
await hhc.deactivate()
```



# Opentrons Temperature Module

| Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Photo                                            |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| - [OEM Link](https://opentrons.com/products/temperature-module-gen2?sku=991-00350-0)<br>- **Communication Protocol / Hardware**: ? / USB-A <br>- **Communication Level**: ?<br><br>- **OEM version**: GEN2<br>- **Temperature range**: 4 to 95°C<br> | ![quadrants](img/ot_temperature_module_gen2.webp) |



---
## Setup Instructions (Physical)

Connect with USB to opentrons or to computer running pylabrobot

---
## Setup Instructions (Programmatic)


### Setup with Opentrons


```python
from pylabrobot.temperature_controlling import TemperatureController
from pylabrobot.temperature_controlling.opentrons import OpentronsTemperatureModuleV2
from pylabrobot.temperature_controlling.opentrons_backend import (
  OpentronsTemperatureModuleBackend,
)
```

Using the Opentrons temperature controller currently requires an Opentrons robot. The robot must be connected to the host computer and to the temperature module.


```python
from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.liquid_handling.backends.opentrons_backend import OpentronsBackend
from pylabrobot.resources.opentrons import OTDeck

ot = OpentronsBackend(host="169.254.184.185", port=31950)  # Get the ip from the Opentrons app
lh = LiquidHandler(backend=ot, deck=OTDeck())
await lh.setup()
```

After setting up the robot, use the `OpentronsBackend.list_connected_modules()` to list the connected temperature modules. You are looking for the `'id'` of the module you want to use.


```python
await ot.list_connected_modules()
```




    [{'id': 'fc409cc91770129af8eb0a01724c56cb052b306a',
      'serialNumber': 'TDV21P20201224B13',
      'firmwareVersion': 'v2.1.0',
      'hardwareRevision': 'temp_deck_v21',
      'hasAvailableUpdate': False,
      'moduleType': 'temperatureModuleType',
      'moduleModel': 'temperatureModuleV2',
      'data': {'status': 'idle', 'currentTemperature': 34.0},
      'usbPort': {'port': 1,
       'portGroup': 'main',
       'hub': False,
       'path': '1.0/tty/ttyACM0/dev'}}]



Initialize the OpentronsTemperatureModuleV2 with the `id` of the module you want to use.


```python
t = OpentronsTemperatureModuleV2(name="t", opentrons_id="fc409cc91770129af8eb0a01724c56cb052b306a")
await t.setup()
```

The `OpentronsTemperatureModuleV2` is a subclass of {class}`~pylabrobot.temperature_controlling.temperature_controller.TemperatureController`.


```python
isinstance(t, TemperatureController)
```




    True



Be sure to assign the temperature controller to the robot deck before you use it. This is done with the usual {func}`~pylabrobot.resources.opentrons.deck.assign_child_at_slot` function.


```python
lh.deck.assign_child_at_slot(t, slot=3)
```

---

### Setup with Com Port

To communicate with the temperature module, find the COM port for the USB connection. Use that to replace `COM#` when setting up the temperature module in your code.


```python
from pylabrobot.temperature_controlling.opentrons import OpentronsTemperatureModuleV2

tc = OpentronsTemperatureModuleV2(name='tc', opentrons_id=None, serial_port="OM#")
await tc.setup()
```

---

## Usage

### Temperature control

You can set the temperature in Celsius using {func}`~pylabrobot.temperature_controlling.temperature_controller.TemperatureController.set_temperature`.


```python
await t.set_temperature(37)
```

Use {func}`~pylabrobot.temperature_controlling.temperature_controller.TemperatureController.wait_for_temperature` to wait for the temperature to stabilize at the target temperature.


```python
await t.wait_for_temperature()
```

The temperature can be read using {func}`~pylabrobot.temperature_controlling.temperature_controller.TemperatureController.get_temperature`.


```python
await t.get_temperature()
```




    37.0



If you are done with the temperature controller, you can use {func}`~pylabrobot.temperature_controlling.temperature_controller.TemperatureController.deactivate` to turn it off. The temperature controller will return to ambient temperature.


```python
await t.deactivate()
```

### Pipetting from the OT-2 temperature module

Assign some tips to the deck and pick one up so that we can aspirate:


```python
from pylabrobot.resources.opentrons import opentrons_96_tiprack_300ul

tips300 = opentrons_96_tiprack_300ul(name="tips")
lh.deck.assign_child_at_slot(tips300, slot=11)
```


```python
await lh.pick_up_tips(tips300["A5"])
```

Access the temperature controller's tube rack with the `tube_rack` attribute.


```python
await lh.aspirate(t.tube_rack["A1"], vols=[20])
```


```python
await lh.aspirate(t.tube_rack["A6"], vols=[20])
```

Return the tips to the tip rack when you are done.


```python
await lh.return_tips()
```



# Hello World, Inheco CPAC!

The Inheco CPAC is a `TemperatureController` machine that enables:
- heating & cooling

...of plates.

- Variants:
  - **CPAC Microplate**:
    - Part number: 7000179
    - Temperature: +4°C to +70°C
  - **CPAC Microplate HT 2TEC**:
    - Part number: 7000163
    - Temperature: +4°C to + 110°C
  - **CPAC Ultraflat**:
    - Part number: 7000190, 7000193
    - Temperature: +4°C to +70°C
  - **CPAC Ultraflat HT 2TEC**:
    - Part number: 7000166, 7000165
    - Temperature: +4°C to + 110°C

Check out the [CPAC User and installation manual](https://www.inheco.com/data/pdf/cpac-manual-1019-0826-30.pdf) for more information.

---

## Setup Instructions (Physical)


Connect the ThermoShake to the Inheco TEC Control Box using the provided cable. The Control Box can control up to 6 ThermoShakes. Plug the Control Box into a power outlet and connect it to your computer using a USB B cable.

There are two versions of the TEC Control Box:

- The Inheco Single TEC Control (STC) unit controls one device.
- The Inheco Multi TEC Control (MTC) unit can control up to 6 Inheco devices in parallel.

See [https://www.inheco.com/tec-controller-and-slot-modules.html](https://www.inheco.com/tec-controller-and-slot-modules.html) for more information like slot module variants.

Also check out the [CPAC User and installation manual](https://www.inheco.com/data/pdf/cpac-manual-1019-0826-30.pdf).

---
## Usage


```python
from pylabrobot.temperature_controlling import InhecoTECControlBox

control_box = InhecoTECControlBox()
await control_box.setup()
```


```python
from pylabrobot.temperature_controlling import inheco_cpac_ultraflat

tc = inheco_cpac_ultraflat(
  name="CPAC",
  control_box=control_box,
  index=1,
)
await tc.setup()
type(tc)
```

### Temperature Control


```python
await tc.get_temperature() # Get current temperature in C
```


```python
await tc.set_temperature(37) # Temperature in degrees C
```


```python
await tc.wait_for_temperature() # Wait for the temperature to stabilize
```


```python
await tc.deactivate() # Turn off temperature control
```

### Closing Connection to Machine


```python
await tc.stop()
```

### Closing Connection to Control Box

When all devices are no longer needed, the connection to the control box can be closed using the {meth}`~pylabrobot.temperature_controller.inheco.control_box.InhecoTECControlBox.stop` method. This will close the connection to the control box.


```python
await control_box.stop()
```

---
## Using Multiple Inheco Devices

You can use multiple Inheco ThermoShake machines using one control box if you are using the Inheco MTC (Multi TEC Control) unit. In this case, simply instantiate more than one {class}`~pylabrobot.temperature_controlling.inheco.cpac_backend.InhecoCPACBackend` with the same {class}`~pylabrobot.temperature_controlling.inheco.control_box.InhecoTECControlBox` instance, but different `index` values (1-6).


```python
tc2 = inheco_cpac_ultraflat(
  name="CPAC",
  control_box=control_box,
  index=2,
)
await tc2.setup()
```



# Azenta a4S

| Summary                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Photo                                            |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------|
| - [OEM Link](https://www.azenta.com/products/automated-roll-heat-sealer-formerly-a4s)<br>- **Communication Protocol / Hardware**: Serial / USB-A<br>- **Communication Level**: Firmware (documentation shared by OEM)<br>- **Sealing Method**: Thermal (heat + pressure)<br>- **Compressed Air Required?**: No<br>- **Typical Seal Time**: ~7 seconds<br><br>The a4S has only 2 programmatically-accessible action parameters for sealing:<br>  - temperature<br>  - sealing duration | ![quadrants](img/azenta_a4s.png) |


---
## Setup Instructions (Programmatic)




```python
%load_ext autoreload
%autoreload 2
```

Identify your control PC's port to your a4S sealer and instantiate the `Sealer` frontend called `a4s`:


```python
from pylabrobot.sealing import a4s

s = a4s(port="/dev/tty.usbserial-0001") # This is a predifned Sealer object with the A4SBackend

# You can also use the Sealer class directly, e.g.:
# from pylabrobot.sealing.sealer import Sealer
# from pylabrobot.sealing.a4s_backend import A4SBackend
# s = Sealer(backend=A4SBackend(port="/dev/tty.usbserial-0001"))

type(s)
```


```python
await s.setup()
```

```{note}
When the a4S is first powered on, it will open its loading tray - this means the **machine default state is open**!

If this is the first time you are using the a4S, follow the OEM’s instructions to load a foil/film roll using the required metal film loading tool.
```

---

## Usage

### Sealing

The a4S firmware enables sealing with just one simple command:


```python
await s.seal(
  temperature=180, # degrees Celsius
  duration=5, # sec
)
```

This command will...
1. set the `temperature`
2. wait until temperature is reached (!)
3. move the plate into the machine / close the loading tray
4. cut the film off its roll (!!)
5. perform sealing of film onto the plate for the specified `duration`
6. move the plate out of the machine / open the loading tray

### Pre-set Temperature

To accelerate the sealing step you can pre-set the temperature of the sealer by using the `set_temperature` method.
The temperature is set in degrees Celsius.


```python
await s.set_temperature(170)
```


```python
await s.get_temperature()
```

---
### Close and Open of the Loading Tray

The a4S does empower standalone closing and opening of the loading tray.
However, there is no conceivable reason to do so when one considers the issues this creates:

The default position of the machine's loading tray is open.
If one executes...


```python
await s.close()
```

...this not only closes the loading tray but **also cuts the film/foil that is currently loaded - without performing a sealing action!**

```{warning}
This means a **single leaf of film will fall onto the loading tray** (or on the top of a plate located on the loading tray).
```

(This is a mechanical constraint of the a4S' design:

Without active motors turning the film roll into the opposite direction during an `await s.close()` command the film inside the machine would be pushed inwards and buckle.
This could lead to multiple problems, including potential sticking of the film to hot internals.
As a result, the cutting of the film during close is an inbuilt, mechanical safety feature [to our knowledge])

When executing...


```python
await s.open()
```

...the single leaf of film will then require manual removal.

(Except if you are using some advanced soft-robotics arm that can handle films/foils 🐙👀)

```{note}
It is possible that this cutting of film during a closing procedure disconnects the film roll with the internals.
If this happens you have to manually re-spool the film roll before you can continue.
```

---

### Querying Machine Status

The a4S has advanced features that are available by calling the frontend's (`Sealer`/`a4s`) backend (`A4SBackend`) directly.


```python
status = await s.backend.get_status()
print("current_temperature:        ", status.current_temperature)
print("system_status:              ", status.system_status)
print("heater_block_status:        ", status.heater_block_status)
print("error_code:                 ", status.error_code)
print("warning_code:               ", status.warning_code)
print("sensor_status:              ")
print("  shuttle_middle_sensor:    ", status.sensor_status.shuttle_middle_sensor)
print("  shuttle_open_sensor:      ", status.sensor_status.shuttle_open_sensor)
print("  shuttle_close_sensor:     ", status.sensor_status.shuttle_close_sensor)
print("  clean_door_sensor:        ", status.sensor_status.clean_door_sensor)
print("  seal_roll_sensor:         ", status.sensor_status.seal_roll_sensor)
print("  heater_motor_up_sensor:   ", status.sensor_status.heater_motor_up_sensor)
print("  heater_motor_down_sensor: ", status.sensor_status.heater_motor_down_sensor)
print("remaining_time:             ", status.remaining_time)
```



# OT2

This notebook shows how to use the Opentrons OT2 with Pylabrobot.

```{note}
The 8 channel pipette is not yet supported.
```

## Connecting

There are different ways to find the robot IP address.
- the OT vendor app.
- using its hostname, e.g. `ot2.local`.
- `arp -a` command in terminal to list all devices in the network.
- checking the connected devices in your router admin panel.
- ...


```python
from pylabrobot.liquid_handling import LiquidHandler, OpentronsOT2Backend
from pylabrobot.resources import OTDeck
deck = OTDeck()
robot_ip = "192.168.0.61"
ot2_backend = OpentronsOT2Backend(host=robot_ip)
lh = LiquidHandler(backend=ot2_backend, deck=deck)
```

You can set the traversal height for the robot as follows. This is the height above the deck at which tips will move.


```python
ot2_backend.traversal_height = 120
```

The robot will automatically home on `setup`, unless `skip_home=True` is passed.


```python
await lh.setup(skip_home=False)
```

Homing manually:


```python
await ot2_backend.home()
```

## Deck setup

Loading a tip rack from the OT reosurce library. This requires a network connection the first time to download the labware definition. After that it is cached locally.


```python
from pylabrobot.resources.opentrons.load import load_ot_tip_rack
tr20uL = load_ot_tip_rack(
  ot_name="opentrons_96_filtertiprack_20ul",  # https://labware.opentrons.com
  plr_resource_name="20uL Tip Rack 1"  # name used in Pylabrobot, arbitrary
)
deck.assign_child_at_slot(tr20uL, slot=9)
```

Plates are loaded from [the PLR resource library](https://docs.pylabrobot.org/resources/index.html) as usual.


```python
from pylabrobot.resources import agilent_96_wellplate_150uL_Ub
plate = agilent_96_wellplate_150uL_Ub(name="premixplate")
deck.assign_child_at_slot(plate, slot=6)
```

You can also import tube racks from the OT resource library and use them with normal PLR tubes:


```python
from pylabrobot.resources.opentrons.load import load_ot_tube_rack
from pylabrobot.resources import Eppendorf_DNA_LoBind_1_5ml_Vb
tube_rack = load_ot_tube_rack(
  ot_name="opentrons_24_aluminumblock_nest_1.5ml_snapcap",
  plr_resource_name="tube_rack"
)
tube_rack[0] = tube = Eppendorf_DNA_LoBind_1_5ml_Vb(name="tube_01")
deck.assign_child_at_slot(tube_rack, slot=4)
```

## Liquid handling

OT2 robots often get out of calibration or do not calibrate to the deck correctly.

You can deal with this by passing offsets to specific operations. The offsets are in mm. Below shows 0,0,0 but you might need a mm to make operations work on your robot. Be careful that the offsets will drift over time.


```python
from pylabrobot.resources.coordinate import Coordinate
tip_offset = Coordinate(x=0, y=0, z=0)
await lh.pick_up_tips(tr20uL[95], offsets=[tip_offset])
```

Moving liquid from a plate to a tube:


```python
plate_offset = Coordinate(x=0, y=0, z=0)
await lh.aspirate(plate[0], vols=[20], offsets=[plate_offset])
tube_offset = Coordinate(x=0, y=0, z=0)
await lh.dispense([tube], vols=[20], offsets=[tube_offset])
```

You can put the tips in the trash after use using `await lh.discard_tips()`.


```python
trash_tip = False
if trash_tip:
  await lh.discard_tips()
```

Or return them to the pickup location using `await lh.return_tips()`.


```python
await lh.return_tips(offsets=[tip_offset])
```



# Tip Inventory Consolidation

Enable tip tracking so PLR keeps track of where the tips are.


```python
from pylabrobot.resources import set_tip_tracking
set_tip_tracking(True)
```


```python
use_channels = [0, 1, 2, 3, 4, 5, 6, 7]
```

## Example LH setup

For this notebook, we will use Hamilton STAR as an example but all robots should be supported.


```python
%load_ext autoreload
%autoreload 2
```


```python
from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.liquid_handling import STARBackend
from pylabrobot.resources import STARDeck

backend = STARBackend()
deck = STARDeck()
```


```python
lh = LiquidHandler(backend=backend, deck=deck)
await lh.setup()
```


```python
from pylabrobot.resources import hamilton_96_tiprack_1000uL_filter, TIP_CAR_480_A00
tip_carrier = TIP_CAR_480_A00(name="tip_carrier")
tip_carrier[0] = tr0 = hamilton_96_tiprack_1000uL_filter(name="tr0", with_tips=True)
tip_carrier[1] = tr1 = hamilton_96_tiprack_1000uL_filter(name="tr1", with_tips=False)
deck.assign_child_resource(tip_carrier, rails=10)
```

## Setting up the visualizer

Let's use the visualizer to see the state of the deck.


```python
from pylabrobot.visualizer import Visualizer
visualizer = Visualizer(lh)
await visualizer.setup()
```

It should look like this:

![full](./img/consolidation/start.jpg)

## Randomization

To simulate a deck in the worst scenario, we completely randomize the state of the two tip racks. This serves as a stress test for the tip inventory consolidation algorithm. In more realistic runs, tip access is likely more structured.


```python
import random
random.seed(42)

n = 48  # Number of tips to transfer
batch_size = len(use_channels)

# Randomly select n tip spots from source and target racks
source_tip_spots = [tr0.get_item(i) for i in sorted(random.sample(range(tr0.num_items), n))]
target_tip_spots = [tr1.get_item(i) for i in sorted(random.sample(range(tr1.num_items), n))]

for i in range(0, n, batch_size):
  await lh.pick_up_tips(source_tip_spots[i:i + batch_size], use_channels=use_channels)
  await lh.drop_tips(target_tip_spots[i:i + batch_size], use_channels=use_channels)
```

After randomization, the visualizer should look like this:

![full](./img/consolidation/random.jpg)

## Probing tip presence (optional)

Because we enabled tip tracking, PLR knows exactly where the tips are. In some runs, when tip tracking was not enabled, we would not know where the tips are.

Luckily, we can automatically detect where tips exist on the deck using "pickup probing". This means that we can use the robot to pick up tips and see if it succeeds or fails (error). If it succeeds, we know that the tip is present at that location. If it fails, we know that the tip is not present at that location.

Below we "forget" the state of the tips, by telling it both tip racks are full, and then use probing to detect where the tips are. After that, we update the state of the tips again (back to the original state).


```python
tr0.fill()
tr1.fill()
```

Now the visualizer should look like this:

![full](./img/consolidation/full.jpg)


```python
import pylabrobot.resources.functional as F
result = await lh.probe_tip_inventory(F.get_all_tip_spots([tr0, tr1]), use_channels=use_channels)
```


```python
for ts_name, has_tip in result.items(): 
  tracker = lh.deck.get_resource(ts_name).tracker
  if has_tip and not tracker.has_tip:
    tracker.add_tip(lh.deck.get_resource(ts_name).make_tip(), commit=True)
  elif not has_tip and tracker.has_tip:
    tracker.remove_tip(commit=True)
```

## Consolidating tip racks


```python
await lh.consolidate_tip_inventory([tr0, tr1], use_channels=use_channels)
```

And we're back to neatly sorted tip racks!

![full](./img/consolidation/start.jpg)



# Using the autoload & 1D barcode reader

| Summary | Image |
|--------|--------|
| <ul style="font-size:15px; line-height:1.6; margin-top:0;"><li><b>Feature:</b> Autoload with integrated 1D barcode reader</li><li><b>Operation:</b> Automatically loads carriers and plates from the front-loading tray onto the STAR deck.</li><li><b>Barcode Recognition:</b> Scans 1D barcodes on carriers, plates, tube racks, and tip racks to confirm ID and placement.</li><li><b>Purpose:</b> Reduces manual deck verification by ensuring that physically loaded carriers match the expected layout.</li><li><b>Workflow Benefit:</b> Verification + Speeds up run setup through hands-free loading and automatic identification.</li><li><b>Best For:</b> High-throughput or frequently changing deck configurations.</li></ul> | <div style="width:320px; text-align:center;">![real_autoload](img/autoload/hamilton_star_autoload.png)<br><i>Figure: Hamilton STAR Autoload system</i></div> |


## Background: Architecture of Hamilton STAR(let) Autoload

![hamilton_star_overview](img/autoload/hamilton_autoload_overview.png)

## Setup


```python
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.resources import STARDeck
from pylabrobot.resources import (
  TIP_CAR_480_A00,
  PLT_CAR_L5AC_A00,
  hamilton_96_tiprack_50uL,
  Cor_96_wellplate_360ul_Fb
)

star = STARBackend()
lh = LiquidHandler(backend=star, deck=STARDeck())
await lh.setup()

# assign a tip rack carrier
tip_carrier = TIP_CAR_480_A00(name="tip_carrier")
tip_carrier[1] = tip_rack = hamilton_96_tiprack_50uL(name="tip_rack")
lh.deck.assign_child_resource(tip_carrier, rails=10)

# assign a plate carrier
plt_carrier = PLT_CAR_L5AC_A00(name="plt_carrier")
plt_carrier[0] = plate = Cor_96_wellplate_360ul_Fb(name="plt")
lh.deck.assign_child_resource(plt_carrier, rails=30)

```

```{note}
Two starting points are possible:
1. Carriers have been moved directly on the deck.
2. Carriers have been left on the loading tray.

Here we assume we're starting with (1) Carriers have been moved directly on the deck.
```

## Querying autoload state


```python
star.autoload_installed
```




    True




```python
await star.request_autoload_track()

```




    54




```python
await star.request_autoload_type()

```




    'ML-STAR with 1D Barcode Scanner'



---
## Sensing carriers

The autoload sled has a front-facing proximity sensor.
This sensor can be used to scan the entire loading tray to identify whether there are any carriers currently on the loading tray:


```python
await star.request_presence_of_carriers_on_loading_tray()

```




    []



```{note}
The autoload detects *only* the right-most track occupied by a carrier!
```

Similarly, if you only want to investigate a single position this can be done too. 


```python
await star.request_presence_of_single_carrier_on_loading_tray(
    track=44
    )

```




    False



The counterpart to checking for carriers on the loading tray is checking for presence of carriers on the liquid handler's deck:


```python
await star.request_presence_of_carriers_on_deck()

```




    [15, 35]



Note that we have assigned the carriers based on the left-most track they are occupying but the `request_presence_of_carriers_on_deck()` detects the right-most track of carriers:
- tip_carrier: left-most track = 10, 6 tracks wide, right-most track  15
- plt_carrier: left-most track = 30, 6 tracks wide, right-most track  35

```{note}
`.request_presence_of_carriers_on_deck()` is technically not an 'autoload' command.
It uses the presence sensors at the back of the STAR(let) deck to identify whether a carrier is present.
i.e. there is no autoload movement involved, and it therefore works for STAR(let)s without an integrated barcode sensor too.
```

Together these `STAR` methods enable capturing a full picture of the state of carriers on your liquid handler.

## Moving autoload


```python
# Always ensure the carrier handler is safely tucked away during movement.
await star.move_autoload_to_save_z_position()

```




    'C0IVid0018er00/00'




```python
await star.move_autoload_to_track(30)

```




    'I0XPid0020er00'




```python
await star.park_autoload()

```




    'I0XPid0022er00'



---
## Basic Load & Unload


```python
await star.unload_carrier(tip_carrier, park_autoload_after=False)

```




    'C0CRid0023er00/00'




```python
await star.load_carrier(tip_carrier, park_autoload_after=False)

```




    {'carrier_barcode': Barcode(data='08T0241707', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
     'container_barcodes': None}



### Command Architecture for (Un)Loading & Barcode Reading

From a firmware-perspective a carrier can be in 3 "states":
1. On the deck
2. On the autoload belt
3. On the loading tray

PyLabRobot enables easy transfer between these 3 states with these `STARBackend` methods:

![hamilton_star_overview](img/autoload/hamilton_autoload_state_transfer.png)

```{note}
We could not find a command that enables the movement sequence: deck > autoload_belt > loading_tray yet.
`.unload_carrier_after_carrier_barcode_scanning()` requires `.load_carrier_from_tray_and_scan_carrier_barcode()` to precede it.
```

## 1D Barcode reading

There are 2 main types of 1D barcodes one a classic STAR(let) deck:
1. Carrier barcodes (orientation=vertical; located at the right-back of the carrier)
2. Container barcodes:
    - TipRack barcodes (orientation=horizontal)
    - Plate barcodes (orientation=horizontal)
    - Tube barcodes (orientation=vertical)

### 1D Barcode Symbologies

All barcodes must follow a standard encoding scheme, i.e. a "symbology".
Before reading barcodes it is important to know what barcode symbology you are expecting to read!

The following barcode symbologies can be detected by the system:


```python
list(star.barcode_1d_symbology_dict.keys())

```




    ['ISBT Standard',
     'Code 128 (Subset B and C)',
     'Code 39',
     'Codebar',
     'Code 2of5 Interleaved',
     'UPC A/E',
     'YESN/EAN 8',
     'ANY 1D']



For the highest reading safety Hamilton recommends to use barcode type `Code128 (subset B and C)`.

This is the default symbology chosen in PyLabRobot commands:


```python
star._default_1d_symbology

```




    'Code 128 (Subset B and C)'



However, you can directly set or change the expected barcode symbology:


The fastest way to read your barcode *when* your carriers are already on the deck is to move the carrier out to the identification position:


```python
await star.set_1d_barcode_type("ISBT Standard")

star._default_1d_symbology

```




    'ISBT Standard'




```python
await star.set_1d_barcode_type("Code 128 (Subset B and C)")

star._default_1d_symbology

```




    'Code 128 (Subset B and C)'



### Loading with with Barcode Reading

1D barcode reading via the autoload can only occur during carrier loading actions.
So let's first unload the carrier:


```python
await star.unload_carrier(tip_carrier, park_autoload_after=False)

```




    'C0CRid0029er00/00'



...and this time activate reading both (1) the carrier barcord and (2) the container barcode:


```python
barcode_readings = await star.load_carrier(
    carrier=tip_carrier,
    carrier_barcode_reading=True,
    barcode_reading=True,
    # barcode_symbology="Code 39",
    # barcode_reading_direction="horizontal",
    # no_container_per_carrier=5,
    park_autoload_after=False,
)

```

This returns a dictionary:


```python
barcode_readings
```




    {'carrier_barcode': Barcode(data='08T0241707', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
     'container_barcodes': {0: Barcode(data='18235938752776512151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
      1: Barcode(data='18235938752776527151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
      2: Barcode(data='18235938752776549151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
      3: None,
      4: Barcode(data='18235938752776513151', symbology='Code 128 (Subset B and C)', position_on_resource='right')}}



```{warning}
The default behaviour of the 1D barcode scanner is set to read the standard 5x tip- and plate-carrier positions.
If you are reading barcodes on a different carrier (e.g. tube or trough carrier) you will have to modify the default parameters.
```

![hamilton_star_overview](img/autoload/hamilton_autoload_correct_1d_barcode_height.png)

```{warning}
The 1D barcode scanner uses a (class 2) laser targeted to a fixed height.
This is especially important when reading horizontal barcodes.
The z-height of the laser (during horizonatal) barcode reading is `z=219` or 119 mm above the deck surface.
If your 1D barcode is not precisely positioned at this height, the 1D barcode reader cannot read your barcode.
To facilitate this height, use "DWP" carriers/MFX plate_holders for plates >40 mm in `size_z`, and "MP" carriers/MFX plate_holders for plates ~15 mm in `size_z`.
```

---
## Advanced 1D Barcode Reading


```python
await star.unload_carrier(tip_carrier, park_autoload_after=False)

```




    'C0CRid0035er00/00'



**Loading tray -> Autoload Belt (Carrier Barcode Reading) -> Loading Tray**


```python
await star.load_carrier_from_tray_and_scan_carrier_barcode(
    tip_carrier,
    # barcode_position = 4.3,  # mm
    # barcode_reading_window_width = 38.0,  # mm
    # reading_speed = 128.1,  # mm/sec
    )

```




    Barcode(data='08T0241707', symbology='Code 128 (Subset B and C)', position_on_resource='right')




```python
await star.unload_carrier_after_carrier_barcode_scanning()
```




    'C0CAid0037er00/00'



**Loading tray -> Autoload Belt (Carrier Barcode Reading) -> Deck (Container Barcode Reading)**

-> same as simply `.load_carrier()` but split into separate components


```python
await star.load_carrier_from_tray_and_scan_carrier_barcode(
    tip_carrier
    )
```




    Barcode(data='08T0241707', symbology='Code 128 (Subset B and C)', position_on_resource='right')




```python
reading = await star.load_carrier_from_autoload_belt(
    barcode_reading=True,
    park_autoload_after=False
    # barcode_reading_direction = "horizontal",
    # barcode_symbology = "Code 128 (Subset B and C)"
    # reading_position_of_first_barcode = 63.0,  # mm
    # no_container_per_carrier = 5,
    # distance_between_containers = 96.0,  # mm
    # width_of_reading_window = 38.0,  # mm
    # reading_speed = 128.1,  # mm/secs
    )
reading
```




    {0: Barcode(data='18235938752776512151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
     1: Barcode(data='18235938752776527151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
     2: Barcode(data='18235938752776549151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
     3: None,
     4: Barcode(data='18235938752776513151', symbology='Code 128 (Subset B and C)', position_on_resource='right')}



**Deck -> Autoload Belt -> Deck (with container barcode reading only)**


```python
await star.take_carrier_out_to_autoload_belt(tip_carrier)

```


```python
reading = await star.load_carrier_from_autoload_belt(
    barcode_reading = True,
    park_autoload_after=False,
    )
reading
```




    {0: Barcode(data='18235938752776512151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
     1: Barcode(data='18235938752776527151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
     2: Barcode(data='18235938752776549151', symbology='Code 128 (Subset B and C)', position_on_resource='right'),
     3: None,
     4: Barcode(data='18235938752776513151', symbology='Code 128 (Subset B and C)', position_on_resource='right')}




```python
await star.move_autoload_to_save_z_position()
```




    'C0IVid0045er00/00'




```python
await star.park_autoload()
```




    'I0XPid0047er00'



---
## Close Connection


```python
await lh.stop()
```

```{note}
Someone did not set up the deck according to the definition in the `Setup` section above.
What is different between sensed physical reality and the deck model? ;)
```





# Foil

The :class:`~pylabrobot.liquid_handling.backends.hamilton.STAR_backend.STAR` backend includes special utilities for working with foil-sealed plates, specifically:

1. a function to pierce foil before aspirating from the plate, and
2. a function to keep the plate down while moving the channels up to avoid lifting the plate.

## Example setup

```{note}
While this example uses high volume tips, it _might_ be possible to use other tip types to pierce the foil. However, 50uL tips are very soft and probably can't be used.
```


```python
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.resources import STARLetDeck
from pylabrobot.resources import (
  TIP_CAR_480_A00,
  PLT_CAR_L5AC_A00,
  hamilton_96_tiprack_1000ul,
  AGenBio_4_wellplate_Vb
)

star = STARBackend()
deck = STARLetDeck()
lh = LiquidHandler(backend=star, deck=deck)
await lh.setup()

# assign a tip rack
tip_carrier = TIP_CAR_480_A00(name="tip_carrier")
tip_carrier[1] = tip_rack = hamilton_96_tiprack_1000ul(name="tip_rack")
lh.deck.assign_child_resource(tip_carrier, rails=1)

# assign a plate
plt_carrier = PLT_CAR_L5AC_A00(name="plt_carrier")
plt_carrier[0] = plate = AGenBio_4_wellplate_Vb(name="plate")
lh.deck.assign_child_resource(plt_carrier, rails=10)
```

## Breaking the foil before using a plate

It is important to break the foil before aspirating because tiny foil pieces can stuck in the tip, drastically changing the liquid handling characteristics.

In this example, we will use an 8 channel workcell and use the inner 6 channels for breaking the foil and then aspirating. We will use the outer 2 channels to keep the plate down while the inner channels are moving up.


```python
well = plate.get_well("A1")
await lh.pick_up_tips(tip_rack["A1:H1"])
```


```python
aspiration_channels = [1, 2, 3, 4, 5, 6]
hold_down_channels = [0, 7]
await star.pierce_foil(
  wells=[well],
  piercing_channels=aspiration_channels,
  hold_down_channels=hold_down_channels,
  move_inwards=4,
  one_by_one=False,
)
```


```python
await lh.return_tips()
```

![gif of piercing foil](./img/pierce_foil.gif)

## Holding the plate down

Holding the plate down while moving channels up after aspiration consists of two parts:
1. Making the channels stay down after a liquid handling operation has finished. By default, STAR will move channels up to traversal height.
2. Putting two channels on the edges of the plate to hold it down, while moving the other channels up.


```python
await lh.pick_up_tips(tip_rack["A2:H2"])
```


```python
num_channels = len(aspiration_channels)
await lh.aspirate(
  [well]*num_channels, vols=[100]*num_channels, use_channels=aspiration_channels,

  # aspiration parameters (backend_kwargs)
  min_z_endpos=well.get_location_wrt(deck, z="cavity_bottom").z, # z end position: where channels go after aspiration
  surface_following_distance=0, # no moving in z dimension during aspiration
  pull_out_distance_transport_air=[0] * num_channels # no moving up to aspirate transport air after aspiration
)

await star.step_off_foil(
  well,
  front_channel=7,
  back_channel=0,
  move_inwards=5,
)
```


```python
await lh.return_tips()
```

![gif of holding down foil](./img/step_off_foil.gif)

---

<iframe width="640" height="360" src="https://www.youtube.com/embed/urglg3WimHA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



# Getting started with liquid handling on a Hamilton STAR(let)

In this notebook, you will learn how to use PyLabRobot to move water from one range of wells to another.

**Note: before running this notebook, you should have**:

- Installed PyLabRobot and the USB driver as described in [the installation guide](../../_getting-started/installation).
- Connected the Hamilton to your computer using the USB cable.

Video of what this code does:

<iframe width="640" height="360" src="https://www.youtube.com/embed/NN6ltrRj3bU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Setting up a connection with the robot

Start by importing the {class}`~pylabrobot.liquid_handling.liquid_handler.LiquidHandler` class, which will serve as a front end for all liquid handling operations.

Backends serve as communicators between `LiquidHandler`s and the actual hardware. Since we are using a Hamilton STAR, we also import the {class}`~pylabrobot.liquid_handling.backends.STAR_backend.STARBackend` backend.


```python
%load_ext autoreload
%autoreload 2
```


```python
from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.liquid_handling.backends import STARBackend
```

In addition, import the {class}`~pylabrobot.resources.hamilton.STARLetDeck`, which represents the deck of the Hamilton STAR.


```python
from pylabrobot.resources.hamilton import STARLetDeck
```

Create a new liquid handler using `STARBackend` as its backend.


```python
backend = STARBackend()
lh = LiquidHandler(backend=backend, deck=STARLetDeck())
```

The final step is to open communication with the robot. This is done using the {func}`~pylabrobot.liquid_handling.LiquidHandler.setup` method.


```python
await lh.setup()
```

## Creating the deck layout

Now that we have a `LiquidHandler` instance, we can define the deck layout.

The layout in this tutorial will contain five sets of standard volume tips with filter, 1 set of 96 1mL wells, and tip and plate carriers on which these resources are positioned.

Start by importing the relevant objects and variables from the PyLabRobot package. This notebook uses the following resources:

- {class}`~pylabrobot.resources.hamilton.tip_carriers.TIP_CAR_480_A00` tip carrier
- {class}`~pylabrobot.resources.hamilton.plate_carriers.PLT_CAR_L5AC_A00` plate carrier
- {class}`~pylabrobot.resources.corning_costar.plates.Cor_96_wellplate_360ul_Fb` wells
- {class}`~pylabrobot.resources.hamilton.tip_racks.hamilton_96_tiprack_1000uL_filter` tips


```python
from pylabrobot.resources import (
  TIP_CAR_480_A00,
  PLT_CAR_L5AC_A00,
  Cor_96_wellplate_360ul_Fb,
  hamilton_96_tiprack_1000uL_filter,
)
```

Then create a tip carrier named `tip carrier`, which will contain tip rack at all 5 positions. These positions can be accessed using `tip_car[x]`, and are 0 indexed.


```python
tip_car = TIP_CAR_480_A00(name="tip carrier")
tip_car[0] = hamilton_96_tiprack_1000uL_filter(name="tips_01")
```

Use {func}`~pylabrobot.resources.abstract.assign_child_resources` to assign the tip carrier to the deck of the liquid handler. All resources contained by this carrier will be assigned automatically.

In the `rails` parameter, we can pass the location of the tip carrier. The locations of the tips will automatically be calculated.


```python
lh.deck.assign_child_resource(tip_car, rails=3)
```

Repeat this for the plates.


```python
plt_car = PLT_CAR_L5AC_A00(name="plate carrier")
plt_car[0] = Cor_96_wellplate_360ul_Fb(name="plate_01")
```


```python
lh.deck.assign_child_resource(plt_car, rails=15)
```

Let's look at a summary of the deck layout using {func}`~pylabrobot.liquid_handling.LiquidHandler.summary`.


```python
lh.summary()
```

    Rail     Resource                   Type                Coordinates (mm)
    ===============================================================================================
    (3)  ├── tip carrier                TipCarrier          (145.000, 063.000, 100.000)
         │   ├── tips_01                TipRack             (162.900, 145.800, 131.450)
         │   ├── <empty>
         │   ├── <empty>
         │   ├── <empty>
         │   ├── <empty>
         │
    (15) ├── plate carrier              PlateCarrier        (415.000, 063.000, 100.000)
         │   ├── plate_01               Plate               (433.000, 146.000, 187.150)
         │   ├── <empty>
         │   ├── <empty>
         │   ├── <empty>
         │   ├── <empty>
         │
    (32) ├── trash                      Trash               (800.000, 190.600, 137.100)
    


## Picking up tips

Picking up tips is as easy as querying the tips from the tiprack.


```python
tiprack = lh.deck.get_resource("tips_01")
await lh.pick_up_tips(tiprack["A1:C1"])
```

    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Sent command: C0TTid0004tt01tf1tl0871tv12500tg3tu0
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Received response: C0TTid0004er00/00
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Sent command: C0TPid0005xp01629 01629 01629 00000&yp1458 1368 1278 0000&tm1 1 1 0&tt01tp2244tz2164th2450td0
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Received response: C0TPid0005er00/00


## Aspirating and dispensing

Aspirating and dispensing work similarly to picking up tips: where you use booleans to specify which tips to pick up, with aspiration and dispensing you use floats to specify the volume to aspirate or dispense in $\mu L$.

The cells below move liquid from wells `'A1:C1'` to `'D1:F1'` using channels 1, 2, and 3 using the {func}`~pylabrobot.liquid_handling.LiquidHandler.aspirate` and {func}`~pylabrobot.liquid_handling.LiquidHandler.dispense` methods.


```python
plate = lh.deck.get_resource("plate_01")
await lh.aspirate(plate["A1:C1"], vols=[100.0, 50.0, 200.0])
```

    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Sent command: C0ASid0006at0&tm1 1 1 0&xp04330 04330 04330 00000&yp1460 1370 1280 0000&th2450te2450lp1931 1931 1931&ch000 000 000&zl1881 1881 1881&po0100 0100 0100&zu0032 0032 0032&zr06180 06180 06180&zx1831 1831 1831&ip0000 0000 0000&it0 0 0&fp0000 0000 0000&av01072 00551 02110&as1000 1000 1000&ta000 000 000&ba0000 0000 0000&oa000 000 000&lm0 0 0&ll1 1 1&lv1 1 1&zo000 000 000&ld00 00 00&de0020 0020 0020&wt10 10 10&mv00000 00000 00000&mc00 00 00&mp000 000 000&ms1000 1000 1000&mh0000 0000 0000&gi000 000 000&gj0gk0lk0 0 0&ik0000 0000 0000&sd0500 0500 0500&se0500 0500 0500&sz0300 0300 0300&io0000 0000 0000&il00000 00000 00000&in0000 0000 0000&
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Received response: C0ASid0006er00/00


After the liquid has been aspirated, dispense it in the wells below. Note that while we specify different wells, we are still using the same channels. This is needed because only these channels contain liquid, of course.


```python
await lh.dispense(plate["D1:F1"], vols=[100.0, 50.0, 200.0])
```

    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Sent command: C0DSid0007dm2 2 2&tm1 1 1 0&xp04330 04330 04330 00000&yp1190 1100 1010 0000&zx1871 1871 1871&lp2321 2321 2321&zl1881 1881 1881&po0100 0100 0100&ip0000 0000 0000&it0 0 0&fp0000 0000 0000&zu0032 0032 0032&zr06180 06180 06180&th2450te2450dv01072 00551 02110&ds1200 1200 1200&ss0050 0050 0050&rv000 000 000&ta000 000 000&ba0000 0000 0000&lm0 0 0&dj00zo000 000 000&ll1 1 1&lv1 1 1&de0020 0020 0020&wt00 00 00&mv00000 00000 00000&mc00 00 00&mp000 000 000&ms0010 0010 0010&mh0000 0000 0000&gi000 000 000&gj0gk0
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Received response: C0DSid0007er00/00


Let's move the liquid back to the original wells.


```python
await lh.aspirate(plate["D1:F1"], vols=[100.0, 50.0, 200.0])
await lh.dispense(plate["A1:C1"], vols=[100.0, 50.0, 200.0])
```

    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Sent command: C0ASid0008at0&tm1 1 1 0&xp04330 04330 04330 00000&yp1190 1100 1010 0000&th2450te2450lp1931 1931 1931&ch000 000 000&zl1881 1881 1881&po0100 0100 0100&zu0032 0032 0032&zr06180 06180 06180&zx1831 1831 1831&ip0000 0000 0000&it0 0 0&fp0000 0000 0000&av01072 00551 02110&as1000 1000 1000&ta000 000 000&ba0000 0000 0000&oa000 000 000&lm0 0 0&ll1 1 1&lv1 1 1&zo000 000 000&ld00 00 00&de0020 0020 0020&wt10 10 10&mv00000 00000 00000&mc00 00 00&mp000 000 000&ms1000 1000 1000&mh0000 0000 0000&gi000 000 000&gj0gk0lk0 0 0&ik0000 0000 0000&sd0500 0500 0500&se0500 0500 0500&sz0300 0300 0300&io0000 0000 0000&il00000 00000 00000&in0000 0000 0000&
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Received response: C0ASid0008er00/00
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Sent command: C0DSid0009dm2 2 2&tm1 1 1 0&xp04330 04330 04330 00000&yp1460 1370 1280 0000&zx1871 1871 1871&lp2321 2321 2321&zl1881 1881 1881&po0100 0100 0100&ip0000 0000 0000&it0 0 0&fp0000 0000 0000&zu0032 0032 0032&zr06180 06180 06180&th2450te2450dv01072 00551 02110&ds1200 1200 1200&ss0050 0050 0050&rv000 000 000&ta000 000 000&ba0000 0000 0000&lm0 0 0&dj00zo000 000 000&ll1 1 1&lv1 1 1&de0020 0020 0020&wt00 00 00&mv00000 00000 00000&mc00 00 00&mp000 000 000&ms0010 0010 0010&mh0000 0000 0000&gi000 000 000&gj0gk0
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Received response: C0DSid0009er00/00


## Dropping tips

Finally, you can drop tips anywhere on the deck by using the {func}`~pylabrobot.liquid_handling.LiquidHandler.drop_tips` method.


```python
await lh.drop_tips(tiprack["A1:C1"])
```

    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Sent command: C0TRid0010xp01629 01629 01629 00000&yp1458 1368 1278 0000&tm1 1 1 0&tt01tp1314tz1414th2450ti0
    INFO:pylabrobot.liquid_handling.backends.hamilton.STARBackend:Received response: C0TRid0010er00/00kz381 356 365 000 000 000 000 000vz303 360 368 000 000 000 000 000



```python
await lh.stop()
```

    WARNING:root:Closing connection to USB device.




# Using the 96 head

![star supported](https://img.shields.io/badge/STAR-supported-blue)
![Vantage supported](https://img.shields.io/badge/Vantage-supported-blue)
![OT2 not supported](https://img.shields.io/badge/OT-not%20supported-red)
![EVO not implemented](https://img.shields.io/badge/EVO-not%20implemented-orange)

Some liquid handling robots have a 96 head, which can be used to pipette 96 samples at once. This notebook shows how to use the 96 head in PyLabRobot.

## Example: Hamilton STARLet

Here, we'll use a Hamilton STARLet as an example. For other robots, simply change the deck layout, making sure that you have at least a tip rack and a plate to use.


```python
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.resources import STARLetDeck
from pylabrobot.resources import (
  TIP_CAR_480_A00,
  PLT_CAR_L5AC_A00,
  TIP_50ul,
  Cor_96_wellplate_360ul_Fb
)

lh = LiquidHandler(backend=STARBackend(), deck=STARLetDeck())
await lh.setup()

# assign a tip rack
tip_carrier = TIP_CAR_480_A00(name="tip_carrier")
tip_carrier[1] = tip_rack = TIP_50ul(name="tip_rack")
lh.deck.assign_child_resource(tip_carrier, rails=1)

# assign a plate
plt_carrier = PLT_CAR_L5AC_A00(name="plt_carrier")
plt_carrier[0] = plate = Cor_96_wellplate_360ul_Fb(name="plt")
lh.deck.assign_child_resource(plt_carrier, rails=7)
```

## Liquid handling with the 96 head

Liquid handling with the 96 head is very similar to what you would do with individual channels. The methods have `96` in their names, and they take `TipRack`s and `Plate`s as arguments, as opposed to `TipSpot`s and `Well`s in case of heads with individual pipetting channels.


```python
await lh.pick_up_tips96(tip_rack)
```

For aspirations and dispenses, a single volume is passed.

```{note}
Only single-volume aspirations and dispenses are supported because all robots that are currently implemented only support single-volume operations. When we add support for robots that can do variable-volume, this will be updated.
```


```python
await lh.aspirate96(plate, volume=50)
```


```python
await lh.dispense96(plate, volume=50)
```


```python
await lh.return_tips96()
```

## Quadrants

96 heads can also be used to pipette quadrants of a 384 well plate. Here, we'll show how to do that.

![quadrants](img/96head/quadrants.png)


```python
from pylabrobot.resources import BioRad_384_DWP_50uL_Vb
plt_carrier[1] = plate384 = BioRad_384_DWP_50uL_Vb(name="plt384")
```


```python
await lh.pick_up_tips96(tip_rack)
```


```python
await lh.aspirate96(plate384.get_quadrant(1), volume=10)
```


```python
await lh.dispense96(plate384.get_quadrant(2), volume=10)
```


```python
await lh.aspirate96(plate384.get_quadrant(3), volume=10)
```


```python
await lh.dispense96(plate384.get_quadrant(4), volume=10)
```


```python
await lh.return_tips96()
```

## Manually moving the 96 head around

![star supported](https://img.shields.io/badge/STAR-supported-blue)
![Vantage supported](https://img.shields.io/badge/Vantage-not%20supported-red)


```python
await lh.backend.request_position_of_core_96_head()
```


```python
await lh.backend.move_core_96_head_x(100)
```


```python
await lh.backend.move_core_96_head_y(120)
```


```python
await lh.backend.move_core_96_head_z(300)
```



# Surface following

Surface following is a feature on Hamilton liquid handling robots that makes the pipette tip follow the surface of a liquid when aspirating (going down) or dispensing (going up).

When using surface following, the robot will automatically move the Z position of the pipette tip the user-specified distance. The amount of surface following required can be computed by comparing the liquid level before and after each aspiration or dispense. PyLabRobot can do this automatically when the height<>volume functions for the given containers are defined. You can also specify the liquid surface following distance manually.

It is useful to start the surface following only at the liquid level, so it is recommended to use [liquid level detection](./star_lld) with the surface following feature. (See below for syntax, which differs from the LLD tutorial). VENUS also supports surface following while doing LLD.

In PLR, when we have LLD + automatic surface following, we can go beyond VENUS by computing the surface following amount based on the precise location of liquid inside the container. This is necessary because the surface following amount is not _just_ a function of the volume of liquid aspirated or dispensed, _but also_ of the location of liquid inside the container (see below). By doing liquid level detection first to get the precise liquid level, we can then use that liquid level height to compute the surface following amount based on the requested volume _and_ location of liquid inside the container.

![](./img/surface_following/surface_following_distance.svg)

## Dummy setup


```python
from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.liquid_handling.backends.hamilton.STAR_backend import STARBackend
from pylabrobot.resources.hamilton import STARDeck

backend = STARBackend()
lh = LiquidHandler(backend=backend, deck=STARDeck())

await lh.setup()

from pylabrobot.resources import TIP_CAR_480_A00, hamilton_96_tiprack_1000uL_filter
tip_car = TIP_CAR_480_A00("tip_car")
tip_car[0] = tr0 = hamilton_96_tiprack_1000uL_filter("tr0")
lh.deck.assign_child_resource(tip_car, rails=2)

from pylabrobot.resources import PLT_CAR_L5AC_A00, CellTreat_96_wellplate_350ul_Ub
plt_car = PLT_CAR_L5AC_A00("plt_car")
plt_car[0] = plate = CellTreat_96_wellplate_350ul_Ub("plate")
lh.deck.assign_child_resource(plt_car, rails=14)
```

## Automatic surface following




```python
wells = plate["A1:H1"]
vols = [50] * len(wells)
```

You can probe the liquid height first using liquid level detection (capacitive), and then use automatic surface following for subsequent aspirations and dispenses as follows:


```python
async with lh.use_tips(tr0["A1:H1"], discard=False):
  await lh.aspirate(
    wells,
    vols,

    # Probe the liquid height before aspirating.
    probe_liquid_height=True,

    # Automatically adjust the following distance based on the probed liquid height.
    auto_surface_following_distance=True,
  )

  await lh.dispense(
    wells,
    vols,
    probe_liquid_height=True,
    auto_surface_following_distance=True,
  )
```

You can also pass the liquid height directly to the aspiration and dispense methods, and still use automatic surface following. This can be useful when you cannot use LLD.


```python
async with lh.use_tips(tr0["A1:H1"], discard=False):
  await lh.aspirate(
    wells,
    vols,
    liquid_height=[10] * len(wells),  # in mm above the bottom of the well
    auto_surface_following_distance=True,
  )

  await lh.dispense(
    wells,
    vols,
    liquid_height=[10] * len(wells),  # in mm above the bottom of the well
    auto_surface_following_distance=True,
  )
```

## Manual surface following

To manually specify the surface following amount, you can use the `surface_following_distance` backend kwarg of the aspiration and dispense methods. For example, to aspirate 100 µL with a surface following amount of 2 mm starting at the detected liquid level:


```python
async with lh.use_tips(tr0["A1:H1"], discard=False):
  await lh.aspirate(
    wells,
    vols,
    probe_liquid_height=True,
    surface_following_distance=[2] * len(wells),  # mm down after finding liquid
  )

  await lh.dispense(
    wells,
    vols,
    probe_liquid_height=True,
    surface_following_distance=[2] * len(wells),  # mm up after finding liquid
  )
```



# Z-probing

With PyLabRobot, one can probe the surface of any object on a STAR(let) deck. This effectively makes the STAR act as a [Coordinate-Measurement Machine (CMM)](https://en.wikipedia.org/wiki/Coordinate-measuring_machine). See also [y probing](./y-probing) for doing the same in the y direction.

There are two ways to probe the surface of an object:

- Using capacitive liquid level sensors (cLLD) to map capacitive objects.
- Moving the tip down onto an object until resistance is detected (a "controlled crash"), which works with both capacitive and non-capacitive objects.

## Example setup


```python
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.resources import STARLetDeck
from pylabrobot.resources import (
  TIP_CAR_480_A00,
  PLT_CAR_L5AC_A00,
  hamilton_96_tiprack_50uL,
  Cor_96_wellplate_360ul_Fb
)

star = STARBackend()
lh = LiquidHandler(backend=star, deck=STARLetDeck())
await lh.setup()

# assign a tip rack
tip_carrier = TIP_CAR_480_A00(name="tip_carrier")
tip_carrier[1] = tip_rack = hamilton_96_tiprack_50uL(name="tip_rack")
lh.deck.assign_child_resource(tip_carrier, rails=1)

# assign a plate
plt_carrier = PLT_CAR_L5AC_A00(name="plt_carrier")
plt_carrier[0] = plate = Cor_96_wellplate_360ul_Fb(name="plt")
lh.deck.assign_child_resource(plt_carrier, rails=7)
```

## Capacitive probing using cLLD

If you are mapping a capacitive surface, you can use the cLLD sensor to detect the surface. This is safer and more accurate than the controlled crash method.

```{warning}
For safety purposes, we recommend using Hamilton 50ul tips for mapping surfaces. These are relatively long and soft, acting as 'cushions' in case you try out faster detection speeds (not recommended). Small bends are tolerated well by the 50ul tips.
```

Introduced in [PR #69](https://github.com/PyLabRobot/pylabrobot/pull/69).

### Mapping a single point


```python
await lh.pick_up_tips(tip_rack["A1"])
```

For more information on manually moving channels, see [Manually moving channels around](../moving-channels-around.ipynb).


```python
await star.prepare_for_manual_channel_operation(0)
```


```python
# TODO: change this to a position that works for you
await star.move_channel_x(0, 260)
await star.move_channel_y(0, 190)
```

Use `STARBackend.probe_z_height_using_channel` to probe the z-height of a single point at the current location. This function will slowly lower the channel until the liquid level sensor detects a change in capacitance. The z-height of the point of the tip is then returned.


```python
await star.clld_probe_z_height_using_channel(0, move_channels_to_safe_pos_after=True)
```


```python
await lh.return_tips()
```

(mapping-a-3d-surface)=
### Mapping a 3D surface


```python
await lh.pick_up_tips(tip_rack["A1"])
await star.prepare_for_manual_channel_operation(0)
```


```python
xs = [260 + i * 3 for i in range(13)]  # in mm, absolute coordinates
ys = [190 + i * 3 for i in range(10)]  # in mm, absolute coordinates

data = []

for x in xs:
  await star.move_channel_x(0, x)
  for y in ys:
    await star.move_channel_y(0, y)
    height = await star.clld_probe_z_height_using_channel(0, start_pos_search=25000)
    data.append((x, y, height))
    await lh.move_channel_z(0, 230)  # move up slightly for traversal
```


```python
await lh.return_tips()
```

Plotting requires `matplotlib` and `numpy`. If you don't have them installed, you can install them with `pip install matplotlib numpy`.


```python
import matplotlib.pyplot as plt
import numpy as np

data = np.array(data)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(data[:, 0], data[:, 1], data[:, 2])
ax.set_xlabel('X')
ax.set_ylabel('Y')
plt.show()
```

Check out the following video demo of mapping a 3D surface:

<iframe width="640" height="360" src="https://www.youtube.com/embed/_uPf9hyTBog" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Non-capacitive probing

There are two ways to probe non-capacitive surfaces:

- using the pLLD sensor
- using the force sensor (a "controlled crash")

### Using the force sensor

This uses moves a tip down slowly until resistance is detected (a "controlled crash"), to measure the surface z-height. This technique is similar to what is routinely used for discarding tips into the trash in both VENUS and PLR.

Sensor accuracy for z-height readings needs to be further tested but in initial tests has been at least 0.2 mm.

#### Picking up teaching needles

Most STAR(let)s come with a teaching block that includes 8 teaching needles. These needles are equivalent to standard volume (300uL) pipette tips but are made from metal instead of plastic. This leads to more accurate results when probing surfaces.

```{warning}
When using the teaching needles, be careful not to damage the STAR(let) deck or channels. The needles are made from metal and can bend the pipetting channels more easily than soft plastic tips.
```


```python
teaching_tip_rack = lh.deck.get_resource("teaching_tip_rack")
await lh.pick_up_tips(teaching_tip_rack["A2"])
```

Alternatively, you can use plastic tips for probing surfaces. However, these are softer and therefore less accurate than the metal teaching needles. 50uL tips are the softest and cannot be used with force z-probing.

#### Moving the channel and mapping a point

See above for more information on moving channels.

```{warning}
Make sure the tip is at a safe height above the labware before moving the channel. Use `STARBackend.move_channel_z` to move the channel to a safe height.
```


```python
await star.prepare_for_manual_channel_operation(0)
await star.move_channel_x(0, 260)
await star.move_channel_y(0, 190)
```


```python
await star.ztouch_probe_z_height_using_channel(
  channel_idx=0,
  move_channels_to_save_pos_after=True)
```


```python
await lh.return_tips()
```

Check out [mapping a 3d surface](#mapping-a-3d-surface) for more information on mapping a surface.

### Using pLLD

The pLLD sensor can also be used to probe non-capacitive surfaces. This is done by slowly lowering the tip until a change in pressure is detected by the pLLD sensor.

Do not use teaching needles for pLLD probing!


```python
await lh.pick_up_tips(tip_rack["A1"])
```

#### Moving the channel and mapping a point

See above for more information on moving channels.

```{warning}
Make sure the tip is at a safe height above the labware before moving the channel. Use `STARBackend.move_channel_z` to move the channel to a safe height.
```


```python
await star.prepare_for_manual_channel_operation(0)
```


```python
# TODO: change this to a position that works for you
await star.move_channel_x(0, 260)
await star.move_channel_y(0, 190)
```

Probing:


```python
await star.plld_probe_z_height_using_channel(0, move_channels_to_safe_pos_after=True)
```


```python
await lh.return_tips()
```



# Y-probing

With PyLabRobot, you can probe the y position of any object on a STAR(let) deck. See also [z probing](./z-probing) for doing the same in the z direction.

```{warning}
This example uses the teaching tips. These are metal tips that are not forgiving. Be particularly careful when moving the channels around to avoid collisions.
```

## Example setup


```python
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.resources import STARDeck  # or STARletDeck

star = STARBackend()
lh = LiquidHandler(backend=star, deck=STARDeck())
await lh.setup()
```

## Capacitive y-probing using cLLD

If you are mapping a capacitive surface, you can use the cLLD sensor to detect the surface.

```{warning}
This example uses the teaching tips. These are metal tips that are not forgiving. Be particularly careful when moving the channels around to avoid collisions.
```


```python
teaching_tip = lh.deck.get_resource("teaching_tip_rack")["A1"]
```


```python
await lh.pick_up_tips(teaching_tip)
```


```python
await star.prepare_for_manual_channel_operation(0)
```


```python
# TODO: change this to a position that works for you
await star.move_channel_x(0, 500)
await star.move_channel_y(0, 300)
```

Use `STARBackend.clld_probe_y_position_using_channel` to probe the y-position of a single point at the current xz plane. This function will slowly move the channel until the liquid level sensor detects a change in capacitance. The y-point of the point of the tip is then returned.


```python
await star.clld_probe_y_position_using_channel(
  channel_idx=0,
  probing_direction="forward",
)
```


```python
await star.clld_probe_y_position_using_channel(
  channel_idx=0,
  probing_direction="backward",
)
```


```python
await lh.return_tips()
```



# Using "Hamilton Liquid Classes" with Pylabrobot

This notebook demonstrates how to use the Hamilton liquid classes with Pylabrobot's liquid handling system. "Liquid classes" are essentially a essentially sets of predefined parameters that describe a specific liquid transfer operation (aspirate + dispense). While it is possible to control all parameters explicitly/manually, or to store those in dictionaries of kwargs, using "Hamilton liquid classes" is the historical way many people are used to doing this in Venus. "Hamilton liquid class" refers to the concept of the 'set of parameters' as it is used in VENUS.

PyLabRobot has imported many Hamilton liquid classes from VENUS. In this notebook we will show how to use these classes in PylabRobot.

## Simple example setup


```python
%load_ext autoreload
%autoreload 2
```

Use the `STARChatterboxBackend` to test out the liquid classes without connecting to a real Hamilton STAR robot. Switch out the backend to `STARBackend` to run on a real robot.


```python
from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.liquid_handling.backends.hamilton.STAR_chatterbox import STARChatterboxBackend
# from pylabrobot.liquid_handling.backends.hamilton.STAR_backend import STARBackend

from pylabrobot.resources.hamilton import STARLetDeck

backend = STARChatterboxBackend()
# backend = STARBackend()
lh = LiquidHandler(backend=backend, deck=STARLetDeck())

await lh.setup()
```


```python
from pylabrobot.resources import (
  TIP_CAR_480_A00,
  PLT_CAR_L5AC_A00,
  Cor_96_wellplate_360ul_Fb,
  hamilton_96_tiprack_1000uL_filter,
)

tip_car = TIP_CAR_480_A00(name="tip carrier")
tip_car[0] = tr = hamilton_96_tiprack_1000uL_filter(name="tips_01")
lh.deck.assign_child_resource(tip_car, rails=3)

plt_car = PLT_CAR_L5AC_A00(name="plate carrier")
plt_car[0] = plate = Cor_96_wellplate_360ul_Fb(name="plate_01")
lh.deck.assign_child_resource(plt_car, rails=15)
```

### Picking up tips for the rest of the notebook


```python
await lh.pick_up_tips(tr["A1:C1"])
```

    C0TTid0001tt01tf1tl0871tv10650tg3tu0
    C0TPid0002xp01629 01629 01629 00000&yp1458 1368 1278 0000&tm1 1 1 0&tt01tp2266tz2166th2450td0


## Using a predefined Hamilton liquid class

Pass a predefined Hamilton liquid class to the `lh.aspirate` method using the `hamilton_liquid_classes` parameter. This parameter is a backend kwarg defined by the STARBackend. This will use the parameters defined in the liquid class for the aspirate operation.


```python
from pylabrobot.liquid_handling.liquid_classes.hamilton.star import HighVolumeFilter_Water_DispenseSurface_Part
await lh.aspirate(
  plate["A1:C1"],
  vols=[100.0, 50.0, 200.0],
  hamilton_liquid_classes=[HighVolumeFilter_Water_DispenseSurface_Part]*3,
)
```

    C0ASid0003at0 0 0 0&tm1 1 1 0&xp04333 04333 04333 00000&yp1457 1367 1277 0000&th2450te2450lp2000 2000 2000 2000&ch000 000 000 000&zl1866 1866 1866 1866&po0100 0100 0100 0100&zu0032 0032 0032 0032&zr06180 06180 06180 06180&zx1866 1866 1866 1866&ip0000 0000 0000 0000&it0 0 0 0&fp0000 0000 0000 0000&av01083 00563 02110 01083&as2500 2500 2500 2500&ta000 000 000 000&ba0000 0000 0000 0000&oa000 000 000 000&lm0 0 0 0&ll1 1 1 1&lv1 1 1 1&zo000 000 000 000&ld00 00 00 00&de0020 0020 0020 0020&wt10 10 10 10&mv00000 00000 00000 00000&mc00 00 00 00&mp000 000 000 000&ms1200 1200 1200 1200&mh0000 0000 0000 0000&gi000 000 000 000&gj0gk0lk0 0 0 0&ik0000 0000 0000 0000&sd0500 0500 0500 0500&se0500 0500 0500 0500&sz0300 0300 0300 0300&io0000 0000 0000 0000&il00000 00000 00000 00000&in0000 0000 0000 0000&


## Using a different Hamilton liquid class for each channel

You can easily pass a list of different Hamilton liquid classes. They will correspond to the channels in the order they are specified.


```python
from pylabrobot.liquid_handling.liquid_classes.hamilton.star import HighVolumeFilter_Water_DispenseSurface_Part, HighVolumeFilter_EtOH_DispenseJet, HighVolumeFilter_DMSO_AliquotDispenseJet_Part

await lh.aspirate(
  plate["A1:C1"],
  vols=[100.0, 50.0, 200.0],
  hamilton_liquid_classes=[
    HighVolumeFilter_Water_DispenseSurface_Part,
    HighVolumeFilter_EtOH_DispenseJet,
    HighVolumeFilter_DMSO_AliquotDispenseJet_Part,
  ], 
)
```

    C0ASid0004at0 0 0 0&tm1 1 1 0&xp04333 04333 04333 00000&yp1457 1367 1277 0000&th2450te2450lp2000 2000 2000 2000&ch000 000 000 000&zl1866 1866 1866 1866&po0100 0100 0100 0100&zu0032 0032 0032 0032&zr06180 06180 06180 06180&zx1866 1866 1866 1866&ip0000 0000 0000 0000&it0 0 0 0&fp0000 0000 0000 0000&av01083 00629 02000 01083&as2500 2500 2500 2500&ta000 050 000 000&ba0000 0000 0500 0000&oa000 000 000 000&lm0 0 0 0&ll1 1 1 1&lv1 1 1 1&zo000 000 000 000&ld00 00 00 00&de0020 0020 0020 0020&wt10 10 10 10&mv00000 00000 00000 00000&mc00 00 00 00&mp000 000 000 000&ms1200 2500 2500 1200&mh0000 0000 0000 0000&gi000 000 000 000&gj0gk0lk0 0 0 0&ik0000 0000 0000 0000&sd0500 0500 0500 0500&se0500 0500 0500 0500&sz0300 0300 0300 0300&io0000 0000 0000 0000&il00000 00000 00000 00000&in0000 0000 0000 0000&


## Using custom Hamilton liquid classes

It is also possible to define your own Hamilton liquid classes. This is useful if you want to use a specific set of parameters that are not available in the predefined classes.

The example below is based on the `HighVolumeFilter_Water_DispenseSurface_Part`, but you can easily modify the parameters to suit your needs.


```python
from pylabrobot.liquid_handling.liquid_classes.hamilton import HamiltonLiquidClass

my_custom_hamilton_liquid_class = HamiltonLiquidClass(
  curve={
    500.0: 518.3,
    50.0: 56.3,
    0.0: 0.0,
    100.0: 108.3,
    20.0: 23.9,
    1000.0: 1028.5,
    200.0: 211.0,
    10.0: 12.7,
  },
  aspiration_flow_rate=250.0,
  aspiration_mix_flow_rate=120.0,
  aspiration_air_transport_volume=0.0,
  aspiration_blow_out_volume=0.0,
  aspiration_swap_speed=2.0,
  aspiration_settling_time=1.0,
  aspiration_over_aspirate_volume=5.0,
  aspiration_clot_retract_height=0.0,
  dispense_flow_rate=120.0,
  dispense_mode=4.0,
  dispense_mix_flow_rate=1.0,
  dispense_air_transport_volume=30.0,
  dispense_blow_out_volume=0.0,
  dispense_swap_speed=2.0,
  dispense_settling_time=1.0,
  dispense_stop_flow_rate=5.0,
  dispense_stop_back_volume=0.0,
)

await lh.aspirate(
  plate["A1:C1"],
  vols=[100.0, 50.0, 200.0],
  hamilton_liquid_classes=[my_custom_hamilton_liquid_class]*3, 
)
```

    C0ASid0005at0 0 0 0&tm1 1 1 0&xp04333 04333 04333 00000&yp1457 1367 1277 0000&th2450te2450lp2000 2000 2000 2000&ch000 000 000 000&zl1866 1866 1866 1866&po0100 0100 0100 0100&zu0032 0032 0032 0032&zr06180 06180 06180 06180&zx1866 1866 1866 1866&ip0000 0000 0000 0000&it0 0 0 0&fp0000 0000 0000 0000&av01083 00563 02110 01083&as2500 2500 2500 2500&ta000 000 000 000&ba0000 0000 0000 0000&oa000 000 000 000&lm0 0 0 0&ll1 1 1 1&lv1 1 1 1&zo000 000 000 000&ld00 00 00 00&de0020 0020 0020 0020&wt10 10 10 10&mv00000 00000 00000 00000&mc00 00 00 00&mp000 000 000 000&ms1200 1200 1200 1200&mh0000 0000 0000 0000&gi000 000 000 000&gj0gk0lk0 0 0 0&ik0000 0000 0000 0000&sd0500 0500 0500 0500&se0500 0500 0500 0500&sz0300 0300 0300 0300&io0000 0000 0000 0000&il00000 00000 00000 00000&in0000 0000 0000 0000&




# Co-Re Grippers

This tutorial demonstrates how to use the Co-Re grippers on Hamilton STAR liquid handling robots with PyLabRobot.

The Co-Re grippers mount on pipetting channels and allow for moving labware around the deck.

## Deck setup

There are two different types of core grippers:

![Co-Re gripper types](./img/core-grippers/core-gripper-types.jpg)


```python
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.liquid_handling.backends.hamilton.STAR_chatterbox import STARChatterboxBackend
from pylabrobot.resources import STARDeck  # STARLetDeck
deck = STARDeck(
  core_grippers="1000uL-at-waste"  # or "1000uL-5mL-on-waste"
)  # STARLetDeck()
# star_backend = STARChatterboxBackend()
star_backend = STARBackend()
lh = LiquidHandler(backend=star_backend, deck=deck)  # STARLetDeck())
```

Let's also set up a dummy plate carrier and plate.


```python
from pylabrobot.resources import PLT_CAR_L5AC_A00, CellTreat_96_wellplate_350ul_Ub
plate_carrier = PLT_CAR_L5AC_A00(name="plate_carrier")
plate_carrier[0] = plate = CellTreat_96_wellplate_350ul_Ub(name="plate")
deck.assign_child_resource(plate_carrier, rails=14)
```

Finally call `setup` to initialize the robot:


```python
await lh.setup()
```

## Moving resources

There are two apis:

- `move_resource`: a single call, simple to read. This function calls `pick_up_resource` and `drop_resource` internally.
- `pick_up_resource` and `drop_resource`: two calls, more control over the timing of operations.

## `move_resource` api

This API is the simplest to read:


```python
await lh.move_resource(
  plate,
  plate_carrier[1],
  pickup_distance_from_top=10,

  # Specify to use the core arm.
  use_arm="core",

  # use two channels to pick up the core gripper tools. Channels are 0-indexed.
  # specify only the front channel. In this case the back channel will be 6.
  core_front_channel=7,
)
```

## `pick_up_resource` and `drop_resource` apis

These APIs give more control over the pick up and drop actions:


```python
await lh.pick_up_resource(
  plate,
  pickup_distance_from_top=10,

  # Backend kwargs:

  # Specify to use the core arm.
  use_arm="core",

  # use two channels to pick up the core gripper tools. Channels are 0-indexed.
  # specify only the front channel. In this case the back channel will be 6.
  core_front_channel=7,
)
```


```python
await lh.drop_resource(
  plate_carrier[1],

  # Backend kwargs:
  use_arm="core",
  return_core_gripper=True,
)
```

## Manual control over grippers


```python
await star_backend.pick_up_core_gripper_tools(front_channel=7)
```


```python
await star_backend.return_core_gripper_tools()
```



# Mixing

![star supported](https://img.shields.io/badge/STAR-supported-blue)
![Vantage supported](https://img.shields.io/badge/Vantage-supported-blue)
![OT supported](https://img.shields.io/badge/OT-supported-blue)
![EVO not tested](https://img.shields.io/badge/EVO-not%20supported-red)

Mixing in PLR is hardware agnostic. You can currently mix before an aspiration or after a dispense by passing the `mix` parameter to the corresponding method call.

A standalone mixing operation will be added in the future.


```python
# Example deck setup for STAR. This can be any robot.
from pylabrobot.liquid_handling import LiquidHandler, LiquidHandlerChatterboxBackend
from pylabrobot.resources import STARDeck  # as an example
lh = LiquidHandler(backend=LiquidHandlerChatterboxBackend(), deck=STARDeck())
await lh.setup()

from pylabrobot.resources import TIP_CAR_480_A00, hamilton_96_tiprack_1000uL_filter
tip_carrier = TIP_CAR_480_A00(name="tiprack_1")
tip_carrier[0] = tr0 = hamilton_96_tiprack_1000uL_filter(name="tiprack_1_0")
lh.deck.assign_child_resource(tip_carrier, rails=1)

from pylabrobot.resources import PLT_CAR_L5AC_A00, Cor_96_wellplate_360ul_Fb
plate_carrier = PLT_CAR_L5AC_A00(name="plate_carrier_1")
plate_carrier[0] = plate = Cor_96_wellplate_360ul_Fb(name="plate_1")
lh.deck.assign_child_resource(plate_carrier, rails=10)
```

    Setting up the liquid handler.
    Resource deck was assigned to the liquid handler.
    Resource trash was assigned to the liquid handler.
    Resource trash_core96 was assigned to the liquid handler.
    Resource waste_block was assigned to the liquid handler.
    Resource tiprack_1 was assigned to the liquid handler.
    Resource plate_carrier_1 was assigned to the liquid handler.


## Mixing

Import the `Mix` object, and pass it to the `mix` parameter of LiquidHandler.aspirate and LiquidHandler.dispense as a list, with one object per channel.


```python
await lh.pick_up_tips(tr0["A1"])
```

    Picking up tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tiprack_1_0_tipspot_0_0 0,0,0            HamiltonTip  1065             8                    95.1             Yes       



```python
from pylabrobot.liquid_handling.standard import Mix
await lh.aspirate(plate["A1"], vols=[100], mix=[Mix(volume=50, repetitions=3, flow_rate=100)])
```

    Aspirating:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_1_well_0_0     0,0,0            None       None       None       



```python
await lh.dispense(plate["A1"], vols=[100], mix=[Mix(volume=50, repetitions=3, flow_rate=100)])
```

    Dispensing:
    pip#  vol(ul)  resource             offset           flow rate  blowout    lld_z       
      p0: 100.0    plate_1_well_0_0     0,0,0            None       None       None       



```python
await lh.return_tips()
```

    Dropping tips:
    pip#  resource             offset           tip type     max volume (µL)  fitting depth (mm)   tip length (mm)  filter    
      p0: tiprack_1_0_tipspot_0_0 0,0,0            HamiltonTip  1065             8                    95.1             Yes       



```python
await lh.stop()
```

    Stopping the liquid handler.




# Manually moving channels around

![star supported](https://img.shields.io/badge/STAR-supported-blue)
![Vantage supported](https://img.shields.io/badge/Vantage-supported-blue)
![OT supported](https://img.shields.io/badge/OT-supported-blue)
![EVO not tested](https://img.shields.io/badge/EVO-not%20tested-orange)

With PLR, you can easily move individual channels around. This is useful for calibrating labware locations, calibrating labware sizes, and other things.

```{warning}
Be very careful about collisions! Move channels to a safe z height before traversing.
```

```{note}
With Hamilton robots, when a tip is mounted, the z location will refer to the point of the pipetting tip. With no tip mounted, it will refer to the bottom of the channel.
```

## Example: Hamilton STAR

Here, we'll use a Hamilton STAR as an example. For other robots, simply change the deck layout, making sure that you have at least a tip rack to use.


```python
from pylabrobot.liquid_handling import LiquidHandler, STARBackend
from pylabrobot.resources import STARDeck, TIP_CAR_480_A00, hamilton_96_tiprack_1000uL_filter

lh = LiquidHandler(backend=STARBackend(), deck=STARDeck())
await lh.setup()

# assign a tip rack
tip_carrier = TIP_CAR_480_A00(name="tip_carrier")
tip_carrier[0] = tip_rack = hamilton_96_tiprack_1000uL_filter(name="tip_rack")
lh.deck.assign_child_resource(tip_carrier, rails=0)
```

## Moving channels

All positions are in mm. The movements are to absolute positions. The origin will be near the left front bottom of the deck, but it differs between robots.

* x: left (low) to right (high)
* y: front (low) to back (high)
* z: bottom (low) to top (high)


```python
channel = 1  # the channel to use

# start by picking up a single tip
await lh.pick_up_tips(tip_rack["A1"], use_channels=[channel])

# prepare for manual operation
# this will space the other channels to safe positions
await lh.prepare_for_manual_channel_operation(channel)
```

Since the channel will be above the tip rack, it should be safe to move up. We perform a quick check to make sure the z_safe is at least above the resources we know about.


```python
z_safe = 240  # WARNING: this might NOT be safe for your setup

if z_safe <= lh.deck.get_highest_known_point():
  raise ValueError(f"z_safe position is not safe, it is lower than the highest known point: {lh.deck.get_highest_known_point()}")

await lh.move_channel_z(channel, z_safe)
```

```{warning}
The z position in the code above should be safe for most setups, but we can't guarantee that it will be safe for all setups. Move to a z position that is above all your labware before moving in the xy plane.
```

When the z position of the bottom of the tip is above the labware, you can move the channel around in the xy plane.


```python
# move the channel around
await lh.move_channel_x(channel, 100)
await lh.move_channel_y(channel, 100)
```

After reaching a spot where the channel can move down, you can use `move_channel_z` again.


```python
await lh.move_channel_z(channel, 100)
```

Before returning the tip to the tip rack, make sure to move the channel to a safe z position again.


```python
await lh.move_channel_z(channel, z_safe)
```

You can run the code above as often as you like. When you're done, you can return the channel to the tip rack.


```python
await lh.return_tips()
```



# Moving plate onto Alpaqua magnet using CORE grippers

- tags: #resourcemovement #plateadapter #hamiltonstar
- Last updated: 2025-10-27

## Prerequisites

- Machines used:
  - Hamilton STAR
- Non-PLR dependencies: None 


## Preview of Machine Behvaiour

<video width="640" controls autoplay loop>
  <source src="./assets/star_movement_plate_to_alpaqua_core/animation.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

## Protocol Mode


```python
protocol_mode = "simulation" # "execution" or "simulation"
```

---
## Import Statements

### Non-PLR Dependencies

None

### Machine & Visualizer


```python
%load_ext autoreload
%autoreload 2
       
import random 
import time

from pylabrobot.liquid_handling import LiquidHandler
from pylabrobot.resources.hamilton import STARLetDeck
from pylabrobot.visualizer.visualizer import Visualizer

if protocol_mode == "execution":

  from pylabrobot.liquid_handling.backends import STARBackend

  backend = STARBackend()

elif protocol_mode == "simulation":

  from pylabrobot.liquid_handling.backends.hamilton.STAR_chatterbox import STARChatterboxBackend
    
  backend = STARChatterboxBackend()
```

### Required Resources


```python
from pylabrobot.resources import (
  hamilton_mfx_carrier_L5_base,
  hamilton_mfx_plateholder_DWP_metal_tapped,
  hamilton_mfx_plateholder_DWP_flat,
  alpaqua_96_plateadapter_magnum_flx,
  Azenta4titudeFrameStar_96_wellplate_200ul_Vb,
)
```

Note: if you're unsure whether you have the resources mentioned in a PLR automated Protocol, use Python's inbuild `help` function to check out the resource definition's docstring - they always contain the manufacturer's catalogue/part number (and if available a direct link to the product page):


```python
help(hamilton_mfx_plateholder_DWP_metal_tapped) # for more information visit the docs 'Resource Management' section
```

    Help on function hamilton_mfx_plateholder_DWP_metal_tapped in module pylabrobot.resources.hamilton.mfx_modules:
    
    hamilton_mfx_plateholder_DWP_metal_tapped(name: str) -> pylabrobot.resources.carrier.PlateHolder
        Hamilton MFX DWP Module (cat.-no. 188042 / 188042-00).
        Hamilton name: 'MFX_DWP_rackbased_module'
        It also contains metal clamps at the corners.
        https://www.hamiltoncompany.com/other-robotics/188042
    


## Instantiate Frontend & Connect to Machine


```python
deck = STARLetDeck()
lh = LiquidHandler(backend=backend, deck=deck)

await lh.setup()

vis = Visualizer(resource=lh)
await vis.setup()

await backend.disable_cover_control() # 😈
```

    Websocket server started at http://127.0.0.1:2121
    File server started at http://127.0.0.1:1337 . Open this URL in your browser.
    C0CDid0001


## Configure Deck Layout


```python
# Setup MFX Carrier for Magnetic Bead Resuspension

mfx_plateholder_dwp_0 = hamilton_mfx_plateholder_DWP_metal_tapped(
    name=f"mfx_plateholder_dwp_tapped_dwp_0"
)

mfx_carrier_tapped_plate_holder_example = hamilton_mfx_carrier_L5_base(
  name="mfx_carrier_tapped_plate_holder_example",
  modules={
    0: mfx_plateholder_dwp_0,
  }
)

mfx_carrier_tapped_plate_holder_example[0] = Azenta4titudeFrameStar_96_wellplate_200ul_Vb(
  name="wash_plate_0"
)

deck.assign_child_resource(mfx_carrier_tapped_plate_holder_example, rails=1)

# Setup Magnet-carrying MFX Carrier

plateholder_flat_0 = hamilton_mfx_plateholder_DWP_flat(name=f"plateholder_flat_0")
magnet_0 = alpaqua_96_plateadapter_magnum_flx(name=f"alpaqua_magnet_0")
plateholder_flat_0.assign_child_resource(magnet_0)

mfx_carrier_magnet_example = hamilton_mfx_carrier_L5_base(
  name="mfx_carrier_magnet_example",
  modules={
    0: plateholder_flat_0,
  }
)
magnet_0.plate_z_offset = 0.62  # <===== PLATE-SPECIFIC !
# empirical: distance between Alpaqua magnet hole bottom to
# cavity_bottom of the well that is placed on top of it
# use ztouch_probing to measure both 

deck.assign_child_resource(mfx_carrier_magnet_example, rails=8)
```

---
## Execution

### Move Plate Onto Magnet PlateAdapter


```python
plate_index = 0 # always design for throughput adaptivness ;)

plate_to_move = lh.deck.get_resource(f"wash_plate_{plate_index}")
move_target = lh.deck.get_resource(f"alpaqua_magnet_{plate_index}")


back_channel_idx = random.randint(1, 6)  # Reduce wear & tear on any single channel

if protocol_mode == "simulation":
  time.sleep(2)
    
await lh.move_plate(
  plate=plate_to_move,
  to=move_target,
  use_arm="core",
  channel_1=back_channel_idx,
  channel_2=back_channel_idx + 1,
  pickup_distance_from_top=6,
  core_grip_strength=40,
  return_core_gripper=False,
)

if protocol_mode == "execution":
  # "smart" command, will ask operator for input if it cannot find plate in move_target location
  # place into condition for simulation mode

  # (1) check transfer success, (2) push plate flush
  await backend.core_check_resource_exists_at_location_center(
    location=plate_to_move.get_absolute_location(),
    resource=plate_to_move,
    gripper_y_margin=9,
    enable_recovery=True,
    audio_feedback=False,
  )

print(backend.core_parked)
# >>> False # save time - keep CORE grippers on channels during magnetisation time

if protocol_mode == "simulation":
  time.sleep(2)
```

    C0ZPid0002xs01679xd0yj1147yv0050zj1932zy0500yo0885yg0825yw40th2800te2800
    C0ZRid0003xs03254xd0yj1138zj2162zi000zy0500yo0885th2800te2800
    False


### Move Plate back onto tapped PlateHolder


```python
move_target = lh.deck.get_resource(f"mfx_plateholder_dwp_tapped_dwp_{plate_index}")

await lh.move_plate(
  plate=plate_to_move,
  to=move_target,
  use_arm="core",
  channel_1=back_channel_idx,
  channel_2=back_channel_idx + 1,
  pickup_distance_from_top=6,
  core_grip_strength=40,
  return_core_gripper=False,
)

if protocol_mode == "execution":

  await backend.core_check_resource_exists_at_location_center(
    location=plate_to_move.get_absolute_location(),
    resource=plate_to_move,
    gripper_y_margin=9,
    enable_recovery=True,
    audio_feedback=False,
  )
   
await backend.return_core_gripper_tools()

print(backend.core_parked)
# >>> True
```

    C0ZPid0004xs03254xd0yj1138yv0050zj2162zy0500yo0885yg0825yw40th2800te2800
    C0ZRid0005xs01679xd0yj1147zj1932zi000zy0500yo0885th2800te2800
    C0ZSid0006xs07975xd0ya1250yb1070tp2150tz2050th2800te2800
    True




