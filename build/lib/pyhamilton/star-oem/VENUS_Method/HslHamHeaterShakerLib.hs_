// ======================================================================
// This is a part of the HSLHamHeaterShaker Library.
// Copyright (C) by HAMILTON Bonaduz AG, CH-7402 Bonaduz.
// All rights reserved.
// ======================================================================
//
// Modification History
//   
//	2008-09-11  tbenz >  V1.0 first creation
//
// 2008-12-03  tbenz >  V1.1 check of input parameter removed
//
// 2009-08-13  tbenz >  V1.2 Initialize routine enlarget with close ond open plate lock
//                      changed in function InitializeNode()
//
// 2013-03-06  tbenz >  V4.4 No change in the library.
//						USB driver changed from UsbIoComm.dll to HxUsbComm.dll
//						this driver is trace into the same UsbCom.trc file than the phoenix software.
//						Version is new dependet of the software version.
//
// >>>>> if you change the version update HamHeaterShakerVersion too <<<<
//
//	**********************************************************************
// This library version supports following hardware:
//		- Hamilton Heater Shaker PN 186280/02
//	**********************************************************************


#ifndef __HSLHeaterShakerLibImpl_hsl__
#define __HSLHeaterShakerLibImpl_hsl__	1


static const variable HamHeaterShakerVersion("Version: V4.4");

// ----------------------------------------------------------------------------------------------------
// Includes
// ----------------------------------------------------------------------------------------------------

#ifndef __HSLStrLib_hsl__
	#include "HSLStrLib.hsl"
#endif

#ifndef __HSLSynLib_hsl__
	#include "HSLSynLib.hsl"
#endif

#ifndef __HSLMthLib_hsl__
	#include "HSLMthLib.hsl"
#endif


// ----------------------------------------------------------------------------------------------------
// Device (for development only! Comment out for release version.)
// ----------------------------------------------------------------------------------------------------
//device ML_STAR;

// --------------------------------------------------------------------------------------
// Implementation of Hamilton Heater Shaker library 
// --------------------------------------------------------------------------------------
namespace HSLHamHeaterShaker
{
	#ifndef __HSLStringTableLib_hsl__
	#include "HSLStringTableLib.hs_"
	#endif

	// --------------------------------------------------------------------------------------
	// Debugging and Developing (for development only! Comment out for release version.)
	// --------------------------------------------------------------------------------------
	//#define _DEBUG		1		// specifies the debug version of the HSLHamHeaterShaker library

	// --------------------------------------------------------------------------------------
	// Tracing
	// --------------------------------------------------------------------------------------
   namespace TraceStatus
   {
		static const variable cmd_start(1);					// action status for formated trace and step return
		static const variable cmd_complete(2);				// action status for formated trace and step return
		static const variable cmd_error(3);					// action status for formated trace and step return
		static const variable cmd_progress(4);				// action status for formated trace and step return
		static const variable cmd_errComplete(5);			// action status for formated trace and step return
   }

	// --------------------------------------------------------------------------------------
	// Parameter definitions
	// --------------------------------------------------------------------------------------
   namespace ShakingParam
   {
      static const variable directionLeft(0);         // Shaking direction
      static const variable directionRight(1);        // Shaking direction
      static const variable directionDefault(0);      // Shaking direction
      static const variable speedParamLenght(4);      // Length of firmware parameter string
      static const variable accelParamLenght(5);      // Length of firmware parameter string
      static const variable timeParamLenght(5);       // Length of firmware parameter string
      static const variable rampMin(630);             // Accelerator ramp min
      static const variable rampMax(12500);           // Accelerator ramp max
      static const variable rampDefault(1250);        // Accelerator ramp default
      static const variable rpmMin(30);               // min revolutions per minutes RPM (steps per second (48 steps == 1 revolution)
      static const variable rpmMax(2500);             // max revolutions per minutes RPM
      static const variable rpmDefault(1000);         // Revolutions per minutes RPM
		static const variable rmpStepFactor(1.25);		// Factor to calculate RPM to steps (Steps = RPM / rmpStepFactor)
      static const variable shakingTimeMin(0);        // min shaking time
      static const variable shakingTimeMax(30000);    // max shaking time
      static const variable shakeTolMin(0);    			// min shaking tolerance
      static const variable shakeTolMax(100);    		// max shaking tolerance
		
   }

   namespace TemperateParam
   {
      static const variable startTimeOutDefault(1800);// Time before temperature will be checked
      static const variable startTimeOutMin(1);       // Time before temperature will be checked
      static const variable startTimeOutMax(3600);    // Time before temperature will be checked
      static const variable paramLength(4);           // Length of all temperature step parameter
      static const variable tempStateOk(0);           // Temperature was allways in temperature range
      static const variable tempStateOutOfRange(1);   // Temperature was out of temperature range
      static const variable tempStateOutOfSecurity(2);// Temperature was out of security range
      static const variable tempStateTimeOut(3);		// Temperature timeout
      static const variable tempMin(0.0);             // min temperature
      static const variable tempMax(105.0);           // max temperature
      static const variable tempToleranceDefault(2.0);// Tolerance of incubation time
      static const variable tempToleranceMin(0.0);    // Tolerance of incubation time
      static const variable tempToleranceMax(100.0);  // Tolerance of incubation time
      static const variable tempSecurityDefault(6.0); // Security range of incubation temperature (switch off heater if reached)
      static const variable tempSecurityMin(0.0);     // Security range of incubation temperature (switch off heater if reached)
      static const variable tempSecurityMax(100.0);   // Security range of incubation temperature (switch off heater if reached)
      static const variable tempTempRequestLength(13);// Length of temperature response string
      static const variable tempStateRequestLength(4);// Length of temperature state response string
   }

	// --------------------------------------------------------------------------------------
	// Monitoring
	// --------------------------------------------------------------------------------------
   namespace MonitorStatus
   {
		static const variable monitorOK(0);							// no error
		static const variable monitorErrHeating(1);				// heating out of range
		static const variable monitorErrShaking(2);				// shaking out of range
		static const variable monitorErrHeatingAndShaking(3);	// heating and shaking out of range
   }

   namespace MonitorAction
   {
		static const variable monitorActionMin(0);				// min value
		static const variable monitorActionCont(0);				// Continue
		static const variable monitorActionStop(1);				// Stop Heating, shaking and monitoring
		static const variable monitorActionAbort(2);				// Abort run
		static const variable monitorActionMax(2);				// max value
   }

	// --------------------------------------------------------------------------------------
	// Module local constants/variables
	// --------------------------------------------------------------------------------------
   static const variable m_maxHHS(10);                      // node 0..9
   static const variable m_firstStarNode(1);                // node 1 and 2 for ML_Star
   static const variable m_lastStarNode(2);                 // node 1 and 2 for ML_Star
   static const variable m_firstUsbNode(1);                 // node 1 to 8 for USB (0..7)
   static const variable m_lastUsbNode(8);                  // node 1 to 8 for USB (0..7)
   static const variable m_firstDeviceNumber(1);            // generated deviceNumber range
   static const variable m_lastDeviceNumber(m_maxHHS);      // generated deviceNumber range

   static const variable m_usbMsgTimeout(240);              // timeout for comand which are send to USB
   static const variable m_usbInitTimeout(15);              // timeout for init comands which are send to USB
   static const variable m_OFF(0);
   static const variable m_ON(1);
   static const variable m_firmwareCmdLength(2);            // length of firmware command without node (Tx)
   static const variable m_waitTimeOutSecurity(60);         // Security time which will be added oto wait timeout of function waitShaker()
	static const variable m_starSimulateModeKey(18);			// key for read simulate flag of STAR with GetCfgValueWithKey()
	static const variable m_shakingPropertyHeatAndShake(0);	// HHS is usable for heating and shaking
	static const variable m_shakingPropertyOnlyHeat(1);		// HHS is usable for heating only
	static const variable m_shakingPropertyOnlyShake(2);		// HHS is usable for shaking only
	static const variable m_shakingPropertyNothing(3);			// HHS is defined wrong, no shaking and no heating ????

   // special error definition for direct check in step result string
   static const variable m_fwNoError("er00");               // no error
   static const variable m_fwCanError("er10");              // can error
   static const variable m_fwShNotInitError("er51");        // Shaker not initialized
   static const variable m_fwShStepLostError("er52");       // Shaker step lost
   static const variable m_fwPlNotInitError("er56");        // Plate lock not initialized
   static const variable m_fwPlStepLostError("er57");       // Plate lock step lost
   static const variable m_fwTimeoutError("er98");          // Time out during send of a command
   static const variable m_fwIsInitialized("qw1");          // QW answere, initialize = flag == 1
   static const variable m_noStarConnectionError("er03");   // No connection to star

	// definition for USB component
   static variable   m_hhsUsbObjectName("HamHeaterShakerUSB.USB");   // name of USB component
   // "{BD0DAB87-838B-44c5-A114-1CBA5BE0E45F}", bufferSize(4090), vendorId(2223), productId(32770), serialNumber(00));
   static variable   m_hhsUsbProductNum(32770);             // productId and serialNumber as string
   static variable   m_hhsUsbSerieNum("00");             	// productId and serialNumber as string


	// --------------------------------------------------------------------------------------
	// Module globale constants/variables
	// --------------------------------------------------------------------------------------
	static global variable  m_hhsCriticalSection(0);   // critical section object for library synchronization 
   static global object    m_usbComObject;            // USB device object

	// --------------------------------------------------------------------------------------
	// Module local constants/variables which must be locked during set / get
	// --------------------------------------------------------------------------------------
   static variable m_isStringTableInitialized(hslFalse);   			// flag for init string table
	static global variable m_initializedLib(hslFalse);				   // initialization state of the HSL HamHeaterShaker library
	static global variable m_isSimulate(hslFalse);                 // flag for simulate mode of heater shaker
   static global variable m_usbTrace(hslTrue);							// flag vor trace the send and receive from USB device
	static global variable m_initializedHeater[](m_maxHHS);        // initialization state of the used device
   static global variable m_shakingDirection[](m_maxHHS);         // Shaking direction left/right (0/1)
   static global variable m_shakingAccRamp[](m_maxHHS);           // Acceleration ramp (rpm)
   static global variable m_shakingTimeOut[](m_maxHHS);           // Time out for waiting function after StartTimed 0 = not started
   static global variable m_tempStartTimeOut[](m_maxHHS);         // Time to elapse until the time controlling is satrt
   static global variable m_tempToleranceRange[](m_maxHHS);       // Tolerance of incubation temperature
   static global variable m_tempSecurityRange[](m_maxHHS);        // Security tolerance before the heater is automatic switched off
   static global variable m_userShakingSpeed[](m_maxHHS);         // The given speed from start function
   static global variable m_userTemperature[](m_maxHHS);         	// The given temperature from start function

	// device management
	// note: the assigned deviceNumber correspond with the array index (deviceNumber-1 == arrayIndex)
	static global variable m_deviceName[](m_maxHHS);					// Name of ML_STAR or "USB" on USB
	static global variable m_nodeNumber[](m_maxHHS);					// can node number 1 based
	static global object   m_starDeviceObj[](m_maxHHS);				// object of ML_STAR device, for USB use m_usbComObject
	static global variable m_isStarSimulate[](m_maxHHS);				// ML_STAR is in simulate mode
	static global variable m_hhsSetting[](m_maxHHS);					// 0..2, 0=both, 1=onlyHeat, 2=onlyShake

	static function saveAndCreateDeviceNumber(variable funcId, variable deviceName,
			object& starObject, variable isStarSimulate,	variable usedNode);
   // m_initializedHeater value with data access lock
   static function isUsbConnected(variable funcId);
 	static function isSimulate(variable funcId, variable deviceNumber, variable makeTrace );
   // uses node from 0 to 9
   static function isHeaterInitialized(variable deviceNumber);
   // uses node from 0 to 9
   static function setHeaterInitialized(variable deviceNumber);
   static function isUsbTrace();

	// definitions for Monitoring function
   static const variable m_minSampleInterval(5);
   static const variable m_maxSampleInterval(300);

   // Prepare the globals for the hsl thread.
   static global event	  m_monitorStartEvent;
   static global variable m_monitorDeviceNumber;
   static global variable m_monitorShakerMin;
   static global variable m_monitorShakerMax;
	static global variable m_monitorHeaterMin;
	static global variable m_monitorHeaterMax;
   static global variable m_monitorSampleInterval;
   static global variable m_monitorAction;
   static global event	  m_monitorEvent[](m_maxHHS);
   static global variable m_monitorResult[](m_maxHHS);

	// --------------------------------------------------------------------------------------
	// Firmware Error Ids
	// --------------------------------------------------------------------------------------
	namespace IDE
	{
		static const variable first(0);						            // guard
		static const variable noError(first);								// No error
      static const variable retErr(first + 1);							// fatalError
      static const variable retNotInitErr(first + 2);					// node not initialized
      static const variable retNotConnectErr(first + 3);				// device not connected
		static const variable canError(first + 4);					   // No communication to CAN node
		static const variable eepromError(first + 5);				   // No communication to EEPROM
		static const variable syntaxCmdError(first + 6);			   // Unknown command
		static const variable syntaxParUnkError(first + 7);			// Unknown parameter.
		static const variable syntaxParRangeError(first + 8);			// Parameter out of range.
		static const variable generalVoltError(first + 9);			   // Voltage outside permitted range
		static const variable generalStopError(first + 10);			// Stop received
		static const variable generalAddrError(first + 11);			// Wrong system address
		static const variable parallelError(first + 12);				// Parallel commands are nor allowed
		static const variable shakerInitError(first + 13);          // Shaker initialization failt
		static const variable shakerNotInitError(first + 14);			// Shaker not initialized
		static const variable shakerStepLossError(first + 15);		// Shaker step loss
		static const variable shakerStartModeError(first + 16);     // Shaker is not started with timeout
		static const variable plateLockInitError(first + 17);			// Plate lock initialization failt
		static const variable plateLockNotInitError(first + 18);		// Plate lock not initialized
		static const variable plateLockStepLossError(first + 19);	// Plate lock step loss
		static const variable tempNotStartError(first + 20);		   // Temperature controlling not started
		static const variable tempTimeoutError(first + 21);	      // Timeout of temperature supervision
		static const variable tempSuperRangeError(first + 22);		// Temperature out of supervision range
		static const variable tempSecurRangeError(first + 23);	   // Temperature out of security range
		static const variable tempSensorError(first + 24);	         // Temperature out of security range
		static const variable commandSendTimeout(first + 25);	      // Time out occured on command ='%s'
		static const variable unknowFwError(first + 26);	         // Unknow firmware error = '%s'
      // none firmware errors
		static const variable noStringValue(first + 27);	         // Wrong type of parameter; '%s1(%s2)' must be a sting..
		static const variable noIntegerValue(first + 28);	         // Wrong type of parameter; '%s1(%s2)' must be a whole number.
		static const variable noDoubleValue(first + 29);	         // Wrong type of parameter; '%s1(%s2)' must be a whole or decimal number.
      static const variable neededNodeNotAvailable(first + 30);	// Node '%s1' not found, please set it to 0 on parameter '%s2' at position '%s3'.
      static const variable unknownResultFormat(first + 31);      // Unknown format of firmware result string.\r\nExpected: '%s1'.\r\nReceived: '%s2'.
      static const variable wrongParameterLength(first + 32);     // Wrong length of input parameter.\r\nParameter = '%s1' length (%s2).\r\nExpected lenght (%s3).

		static const variable last(first + 32);							// guard
	}


	// --------------------------------------------------------------------------------------
	// String Ids
	// --------------------------------------------------------------------------------------
	namespace IDS
	{
		static const variable first(IDE::last + 1);					   // guard
		static const variable traceSource(first);						   // Text: "SYSTEM", source for formated trace
		static const variable helpFileName(first + 1);		         // Text: "HSLHAMHEATERSHAKERLIB%s.CHM", language independend language name
		static const variable sendMessageTitle(first + 2);				// Text: "Send message = "
		static const variable receiveMessageTitle(first + 3);		   // Text: "Received answere = "
		static const variable setSimulate(first + 4);					// Text: "Set simulate mode = "
		static const variable starNode(first + 5);					   // Text: "ML_Star node"
		static const variable usbNode(first + 6);					      // Text: "USB node"
		static const variable noUsbConnection(first + 7);	         // Text: "No connection to USB device."
		static const variable parameterOutOfRange(first + 8);	      // Text: "Parameter out of range; '%s1(%s2)' must be between [%s3..%s4]."
      static const variable neededNodeNotInitialized(first + 9);	// Text: "Node '%s1' not initialized'."
      static const variable setTrace(first + 10);						// Text:	"Set USB trace mode = "
		static const variable firmwareVersion(first + 11);				// Text: "%s1 '%s2' firmware version = "
		static const variable cannotCreateUsbPort(first + 12);	   // Text: "USB communication cannot be created."
      static const variable timeoutDuringWaitShaker(first + 13);  // Text: "Time out during wait for end shaking. Shaking will be stop."
      static const variable progressSendTo(first + 14);           // Text: "Send command to %s1 ( %s2 )."
      static const variable startTimeout(first + 15);             // Text: "Start time out = "
      static const variable toleranceRange(first + 16);           // Text: "Temperature range = "
      static const variable securityRange(first + 17);            // Text: "Security range = "
      static const variable shakingDirection(first + 18);         // Text: "Shaking direction = "
      static const variable shakingSpeed(first + 19);             // Text: "Shaking speed = "
      static const variable shakingAccRamp(first + 20);           // Text: "Shaking acceleration ramp = "
      static const variable sendToStar(first + 21);               // Text: "HSLHamHeaterShakerLib::SendToStar"
      static const variable sendToUsb(first + 22);                // Text: "HSLHamHeaterShakerLib::SendToUsb"
      static const variable invalidStarDevice(first + 23);      	// Text: "Parameter 'starDevice' contains an invalid object."
      static const variable invalidDeviceNumber(first + 24);      // Text: "Parameter 'deviceNumber' contains an invalid value! \r\nMust be created with function CreateStarDevice() or CreateUsbDevice()"
      static const variable maxHHSReached(first + 25);      		// Text: "Cannot create the deviceNumber; Maximum count of usable HHS is reached."
      static const variable shakingNotActivated(first + 26);      // Text: "Current HHS module on %s1 '%s2' cannot used as shaker.");
      static const variable heatingNotActivated(first + 27);      // Text: "Current HHS module on %s1 '%s2' cannot used as heater.");
      static const variable monitoringShakingTitle(first + 28);   // Text: "Current speed (RPM) = ");
      static const variable monitoringTempTitle(first + 29);      // Text: "Current temperature = ");
      static const variable monitoringTempHeatUpTitle(first + 30);// Text:	"Current temperature (heating up mode) = ");
      static const variable monitoringStateTitle(first + 31);		// Text:	"Current monitored state = ");
      static const variable monitoringWarning(first + 32);			// Text:	"Warning: ");
      static const variable monitoringShNotStart(first + 33);		// Text:	"Shaking not started, check of speed limit will be disabled!");
      static const variable monitoringHeNotStart(first + 34);		// Text:	"Heating up not started, check of temperature limit will be disabled!");
      static const variable monitoringAbort(first + 35);				// Text:	"Heating or shaking is out of range; Method will be abort!");

		static const variable last(first + 35);						   // guard
	}

	// --------------------------------------------------------------------------------------
	// Function Ids
	// --------------------------------------------------------------------------------------
	namespace IDF
	{
      // do not change the sort of this list of function and his IDs
		static const variable first(IDS::last + 1);					   // guard
		static const variable CreateStarDevice(first);		         // Text: "HSLHamHeaterShakerLib - CreateStarDevice"
		static const variable CreateUsbDevice(first+1);		         // Text: "HSLHamHeaterShakerLib - CreateUsbDevice"
		static const variable Terminate(first + 2);				      // Text: "HSLHamHeaterShakerLib - Terminate"

		static const variable StartShaker(first + 3);				   // Text: "HSLHamHeaterShakerLib - StartShaker"
		static const variable StopShaker(first + 4);		            // Text: "HSLHamHeaterShakerLib - StopShaker"
		static const variable StartShakerTimed(first + 5);		      // Text: "HSLHamHeaterShakerLib - StartShakerTimed"
		static const variable WaitForShaker(first + 6);		         // Text: "HSLHamHeaterShakerLib - WaitForShaker"
		static const variable StartAllShaker(first + 7);		      // Text: "HSLHamHeaterShakerLib - StartAllShaker"
		static const variable StartAllShakerTimed(first + 8);		   // Text: "HSLHamHeaterShakerLib - StartAllShakerTimed"
		static const variable StopAllShaker(first + 9);		         // Text: "HSLHamHeaterShakerLib - StopAllShaker"
		static const variable SetShakerParameter(first + 10);		   // Text: "HSLHamHeaterShakerLib - SetShakerParameter"
		static const variable GetShakerParameter(first + 11);		   // Text: "HSLHamHeaterShakerLib - GetShakerParameter"
		static const variable GetShakerSpeed(first + 12);	   		// Text: "HSLHamHeaterShakerLib - GetShakerSpeed"

		static const variable StartTempCtrl(first + 13);		      // Text: "HSLHamHeaterShakerLib - StartTempCtrl"
		static const variable StopTempCtrl(first + 14);		         // Text: "HSLHamHeaterShakerLib - StopTempCtrl"
		static const variable WaitForTempCtrl(first + 15);		      // Text: "HSLHamHeaterShakerLib - WaitForTempCtrl"
		static const variable GetTemperature(first + 16);		      // Text: "HSLHamHeaterShakerLib - GetTemperature"
		static const variable GetTemperatureState(first + 17);		// Text: "HSLHamHeaterShakerLib - GetTemperatureState"
		static const variable SetTempParameter(first + 18);	      // Text: "HSLHamHeaterShakerLib - SetTempParameter"
		static const variable GetTempParameter(first + 19);	      // Text: "HSLHamHeaterShakerLib - GetTempParameter"

		static const variable SetPlateLock(first + 20);		         // Text: "HSLHamHeaterShakerLib - SetPlateLock"
		static const variable GetFirmwareVersion(first + 21);	      // Text: "HSLHamHeaterShakerLib - GetFirmwareVersion"
		static const variable GetSerialNumber(first + 22);		      // Text: "HSLHamHeaterShakerLib - GetSerialNumber"
		static const variable BeginMonitoring(first + 23);		      // Text: "HSLHamHeaterShakerLib - BeginMonitoring"
		static const variable EndMonitoring(first + 24);		      // Text: "HSLHamHeaterShakerLib - EndMonitoring"

		static const variable SendFirmwareCommand(first + 25);	   // Text: "HSLHamHeaterShakerLib - SendFirmwareCommand"
		static const variable SetSimulation(first + 26);		      // Text: "HSLHamHeaterShakerLib - SetSimulation"
		static const variable SetUSBTrace(first + 27);					// Text: "HSLHamHeaterShakerLib - SetUSBTrace"


		static const variable Monitoring(first + 28);					// Text: "HSLHamHeaterShakerLib - Monitoring"

		static const variable last(first + 28);						   // guard
	}

	// --------------------------------------------------------------------------------------
	// Exception handling
	// --------------------------------------------------------------------------------------

	namespace Error
	{
		static function Raise(												// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber)											// i: line number
		{
			variable description("");
			string hlpFileName;

			// set error description
			if ("" == funcName)
				description = fileName + "(" + lineNumber + ") : " + StringTable::Load(errorId);
			else
				description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + StringTable::Load(errorId);
			err.SetDescription(description);

			hlpFileName = StringTable::Load(IDS::helpFileName);
			StrReplace(hlpFileName, "%s", GetLanguage());
			// raise error
			err.Raise(errorId, err.GetDescription(), hlpFileName);
		}

		static function RaiseEx(											// raises a runtime error
			variable errorId,													// i: error id, one of IDE
			variable errorDesc,												// i: error description
			variable& fileName,												// i: file name
			variable& funcName,												// i: function name
			variable& lineNumber)											// i: line number
		{
			variable description("");
			string hlpFileName;

			// set error description
			if ("" == funcName)
				description = fileName + "(" + lineNumber + ") : " + errorDesc;
			else
				description = fileName + "(" + lineNumber + ") : " + funcName + "()\n" + errorDesc;
			err.SetDescription(description);

			hlpFileName = StringTable::Load(IDS::helpFileName);
			StrReplace(hlpFileName, "%s", GetLanguage());
			// raise error
			err.Raise(errorId, err.GetDescription(), hlpFileName);
		}

		static function RaiseLast()										// re-throws the last runtime error
		{
			// re-raise error
			err.Raise();
		}
	}

	/****************************************************************************************
	*	
	* Internal helper function declaration
	*
	****************************************************************************************/
	static function initHamHeaterShakerLib(variable funcId, variable deviceNumber, variable initShaker);
   static function checkStringInput(variable funcId, variable parameterName, variable input);
   static function checkIntegerInput(variable funcId, variable parameterName, variable input);
   static function checkIntegerInputRange(variable funcId, variable parameterName, variable input, variable min, variable max);
   static function checkDoubleInput(variable funcId, variable parameterName, variable input);
   static function checkDoubleInputRange(variable funcId, variable parameterName, variable input, variable min, variable max);
	static function isStarDevice(variable deviceNumber);
	static function getNodeFromDeviceNumber(variable deviceNumber);
	static function checkDeviceNumber(variable funcId, variable deviceNumber);
	static function setHHSSetting(variable funcId, variable deviceNumber, variable& hhsSetting);
	static function hasHeater(variable funcId, variable deviceNumber, variable throw);
	static function hasShaker(variable funcId, variable deviceNumber, variable throw);
   static function sendMsg(variable deviceNumber, variable command, variable parameter, variable timeOut, variable makeTrace);
   static function sendToUsb(variable deviceNumber, variable command, variable parameter, variable timeOut);
   static function sendToStar(variable deviceNumber, variable cmd, variable param, variable makeTrace);
   static function startTrace(variable funcName) void;
   static function progressTrace(variable funcName, variable progMsgTitle, variable progMsg) void;
   static function errorTrace(variable funcName, variable errMsg) void;
   static function errorCompleteTrace(variable funcName, variable errMsg) void;
   static function endTrace(variable funcName) void;
   static function getSendState(variable funcId, variable deviceNumber, variable isShaker);
   static function isFirmwError(variable funcId, string cmdResult, variable makeTrace);
   static function startPlateLockCmd(variable funcId, variable deviceNumber, variable plateLock);
   static function startShakingCmd(variable funcId, variable deviceNumber, variable command, variable parameter, variable isStart);
   synchronized function monitorHeaterShaker();
	static function wait(variable waitTime);
	static function getCurrentShakerRPM(variable deviceNumber, variable makeTrace);
	static function getCurrentTemp(variable deviceNumber, variable makeTrace);
	static function pollingForRunningShaker(variable deviceNumber, variable maxPollingTime);
	static function pollingForRunningHeater(variable deviceNumber, variable maxPollingTime);
	static function OnAbortHHSLibrary();

   static function versionTrace() void;
	// this function is used in InitializeLibrary() and uses index 0..10
	static function traceFirmwareVersion(variable funcId, variable deviceNumber);
   static function sendToProgressTrace(variable funcName, variable deviceNumber) void;

   // get the given parameter with filled 0 before value
	static function formatParam(variable param, variable strWidth);
   // returns the given parameter normalized (*10) for firmware command as string
	static function normalizeParam(variable param, variable strWidth);

      
	/****************************************************************************************
	*	
	* Interface functions
	*
	****************************************************************************************/

   //====================================================================
	//
	// Application function CreateStarDevice()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Initialize shaker/heater module on ML_Star device.
   //  Only NOT initialized nodes will be initialize, the function will
   //  check first the initialization state before.
   //....................................................................
   // Parameters:
   //  in : starDevice   : Used STAR device for node T1 and T2 of STAR
   //  in : usedNode     : Node which must be create and initialized. (1 or 2)
	//	 out: deviceNumber : generated device number which must be used in all other functions
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
	function CreateStarDevice(
		device& starDevice,						// in:  ML_STAR device
		variable usedNode,						// in:  node ID (1 or 2)
		variable& deviceNumber)					// out: generated deviceNumber
	{
      variable funcRc(IDE::noError);
      variable funcId(IDF::CreateStarDevice);
		variable deviceName;
		variable isSimulate(m_ON);
		variable isStarSimulate(hslFalse);
		variable shakingProperty(0);
		object	starObject;

      versionTrace();
      startTrace(funcId);

		// check input parameter
		checkIntegerInputRange(funcId, "usedNode", usedNode, m_firstStarNode, m_lastStarNode);

		onerror goto DeviceError;
		deviceName = starDevice.GetInstrumentName();
		isSimulate = starDevice.GetCfgValueWithKey(m_starSimulateModeKey);
		starObject = starDevice.GetCommandObject();
		onerror goto 0;

		if(starObject.IsNull())
		{
         string msg;
         variable funcName;
			// "Parameter 'starDevice' contains an invalid object."
         msg = StringTable::Load(IDS::invalidStarDevice);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

      if(GetType(isSimulate) == "i")
      {
         if(isSimulate != m_OFF)
            isStarSimulate = hslTrue;
      }

		// initialize the library variables
		funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

		deviceNumber = saveAndCreateDeviceNumber(funcId, deviceName, starObject, isStarSimulate, usedNode);

		// initialize the shaker
		funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
		return (funcRc);

		DeviceError:
		{
         string msg;
         variable funcName;
			// "Parameter 'starDevice' contains an invalid object."
         msg = StringTable::Load(IDS::invalidStarDevice);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}
	}

   //====================================================================
	//
	// Application function CreateUsbDevice()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Initialize shaker/heater module on USB device.
   //  Only NOT initialized nodes will be initialize, the function will
   //  check first the initialization state before.
   //....................................................................
   // Parameters:
   //  in : usedNode     : Node which must be create and initialized. (1 or 2)
	//	 out: deviceNumber : generated device number which must be used in all other functions
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
	function CreateUsbDevice(
		variable usedNode,						// in:  node ID (1..8)
		variable& deviceNumber)					// out: generated deviceNumber
	{
      variable funcRc(IDE::noError);
      variable funcId(IDF::CreateUsbDevice);
		variable isStarSimulate(hslFalse);
		variable shakingProperty(0);
		object	starObject;

      versionTrace();
      startTrace(funcId);

		// check input parameter
		checkIntegerInputRange(funcId, "usedNode", usedNode, m_firstUsbNode, m_lastUsbNode);

		// initialize the library variables
		funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

		deviceNumber = saveAndCreateDeviceNumber(funcId, m_hhsUsbObjectName, starObject, isStarSimulate, usedNode);

		// initialize the shaker
		funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
		return (funcRc);

	}

   //====================================================================
	//
	// Application function Terminate()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Terminate the USB device connection.
   //....................................................................
   // Parameters:
   //    none
   // ...................................................................
   // return value:
   //    none
   //....................................................................
   // Remarks:
   //   
	//====================================================================
	function Terminate() void
   {
      variable funcId(IDF::Terminate);
      variable nodeIndex(0);

      startTrace(funcId);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);

      for( nodeIndex = 0; nodeIndex < m_maxHHS; nodeIndex++)
      {
         m_initializedHeater[nodeIndex] = hslFalse;
			m_deviceName[nodeIndex] = "";
			m_nodeNumber[nodeIndex] = 0;
			m_hhsSetting[nodeIndex] = 0;
      }

      if(!m_usbComObject.IsNull())
      {
         // release the usb object 
         // run is crash in cae of multi thread and a call of ReleaseObject() while commands are send / receive
        // m_usbComObject.ReleaseObject();
      }
      SynLeaveCriticalSection(m_hhsCriticalSection);

      endTrace(funcId);
      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }

   }


   //====================================================================
	//
	// Application function StartShaker()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Lock plate and start shaking.
   //  
   //....................................................................
   // Parameters:
   //  deviceNumber 	:  device number which was generated on CreateXXDevice() 
   //  shakingSpeed	:	Shaking speed in RPM round per minutes
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StartShaker(variable deviceNumber, variable shakingSpeed)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::StartShaker);
      variable node;
      variable command("SB");
      string   parameter("st%s1sv%s2sr%s3");
      string   cmdResult;
      variable shakingDirection;
      variable shakingAccRamp;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      //tb 2008-12-03 checkIntegerInputRange(funcId, "shakingSpeed", shakingSpeed, ShakingParam::rpmMin, ShakingParam::rpmMax);
      checkIntegerInput(funcId, "shakingSpeed", shakingSpeed);

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

		hasShaker(funcId, deviceNumber, 1);

 		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      shakingDirection = m_shakingDirection.GetAt(deviceNumber-1);
      shakingAccRamp = m_shakingAccRamp.GetAt(deviceNumber-1);
		m_userShakingSpeed[deviceNumber-1] = shakingSpeed;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      sendToProgressTrace(funcId, deviceNumber);

		// change RPM to steps
		shakingSpeed = Floor(MthRound(shakingSpeed / ShakingParam::rmpStepFactor, 0));
		shakingAccRamp = Floor(MthRound(shakingAccRamp / ShakingParam::rmpStepFactor, 0));

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      // add saved parameter
      StrReplace(parameter, "%s1", IStr(shakingDirection));
      StrReplace(parameter, "%s2", formatParam(shakingSpeed, ShakingParam::speedParamLenght));
      StrReplace(parameter, "%s3", formatParam(shakingAccRamp, ShakingParam::accelParamLenght));

      // lock plate
      cmdResult = startPlateLockCmd(funcId, deviceNumber, m_ON);
      funcRc = isFirmwError(funcId, cmdResult, hslFalse);
      if(0 < funcRc)
      {
         // be sure that the plate lock is open
         startPlateLockCmd(funcId, deviceNumber, m_OFF);
         isFirmwError(funcId, cmdResult, hslTrue);
         return (funcRc);
      }

      // start shaker
      cmdResult = startShakingCmd(funcId, deviceNumber, command, parameter, hslTrue);
      funcRc = isFirmwError(funcId, cmdResult, hslFalse);
      if(0 < funcRc)
      {
         // be sure that the plate lock is open
         startPlateLockCmd(funcId, deviceNumber, m_OFF);
         isFirmwError(funcId, cmdResult, hslTrue);
         return (funcRc);
      }

      endTrace(funcId);
      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }

   //====================================================================
	//
	// Application function StopShaker()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Stop shaking and unlock plate.
   //  
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StopShaker(variable deviceNumber)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::StopShaker);
      variable command("SC");
      variable parameter("");
      string   cmdResult;
         
      startTrace(funcId);

  		checkDeviceNumber(funcId, deviceNumber);

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasShaker(funcId, deviceNumber, 1);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      // stop shaking
      cmdResult = startShakingCmd(funcId, deviceNumber, command, parameter, hslFalse);

      // open plate lock
      startPlateLockCmd(funcId, deviceNumber, m_OFF);

      SynEnterCriticalSection(m_hhsCriticalSection);
   	m_userShakingSpeed[deviceNumber-1] = 0;
		m_shakingTimeOut[deviceNumber-1] = m_OFF;
		SynLeaveCriticalSection(m_hhsCriticalSection);

      // check error of stop shaker after open plate lock
      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);
   }

   //====================================================================
	//
	// Application function StartShakerTimed()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Lock plate and start shaking with timed duration.
   //....................................................................
   // Parameters:
   //  deviceNumber 	:  device number which was generated on CreateXXDevice() 
   //  shakingSpeed	:	Shaking speed in RPM round per minutes
   //  shakingTime	:  Shaking time in seconds
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StartShakerTimed(
         variable deviceNumber,
			variable shakingSpeed,
         variable shakingTime)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::StartShakerTimed);
      variable command("ST");
      string   parameter("sd%s1st%s2sv%s3sr%s4");
      string   cmdResult;
      variable shakingDirection;
      variable shakingAccRamp;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      //tb 2008-12-03 checkIntegerInputRange(funcId, "shakingSpeed", shakingSpeed, ShakingParam::rpmMin, ShakingParam::rpmMax);
      checkIntegerInput(funcId, "shakingSpeed", shakingSpeed);
      //tb 2008-12-03 checkIntegerInputRange(funcId, "shakingTime", shakingTime, ShakingParam::shakingTimeMin, ShakingParam::shakingTimeMax);
      checkIntegerInput(funcId, "shakingTime", shakingTime);

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

		hasShaker(funcId, deviceNumber, 1);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      shakingDirection = m_shakingDirection.GetAt(deviceNumber-1);
      shakingAccRamp = m_shakingAccRamp.GetAt(deviceNumber-1);
      m_shakingTimeOut[deviceNumber-1] = shakingTime;
		m_userShakingSpeed[deviceNumber-1] = shakingSpeed;
      SynLeaveCriticalSection(m_hhsCriticalSection);

		// change RPM to steps
		shakingSpeed = Floor(MthRound(shakingSpeed / ShakingParam::rmpStepFactor, 0));
		shakingAccRamp = Floor(MthRound(shakingAccRamp / ShakingParam::rmpStepFactor, 0));


      // add saved parameter
      StrReplace(parameter, "%s1", formatParam(shakingTime, ShakingParam::timeParamLenght));
      StrReplace(parameter, "%s2", IStr(shakingDirection));
      StrReplace(parameter, "%s3", formatParam(shakingSpeed, ShakingParam::speedParamLenght));
      StrReplace(parameter, "%s4", formatParam(shakingAccRamp, ShakingParam::accelParamLenght));

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      // lock plate
      cmdResult = startPlateLockCmd(funcId, deviceNumber, m_ON);
      funcRc = isFirmwError(funcId, cmdResult, hslFalse);
      if(0 < funcRc)
      {
         // be sure that the plate lock is open
         startPlateLockCmd(funcId, deviceNumber, m_OFF);
         isFirmwError(funcId, cmdResult, hslTrue);
         return (funcRc);
      }

      // start shaker timed
      cmdResult = startShakingCmd(funcId, deviceNumber, command, parameter, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslFalse);
      if(0 < funcRc)
      {
         // be sure that the plate lock is open
         startPlateLockCmd(funcId, deviceNumber, m_OFF);
         isFirmwError(funcId, cmdResult, hslTrue);
         return (funcRc);
      }

      endTrace(funcId);
      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }

   //====================================================================
	//
	// Application function WaitForShaker()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Waits until a timed shaking has end.
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function WaitForShaker(variable deviceNumber)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::WaitForShaker);
      variable shakingTime(ShakingParam::shakingTimeMax);
      variable command("SW");
      string   parameter("");
      string   cmdResult;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasShaker(funcId, deviceNumber, 1);

      sendToProgressTrace(funcId, deviceNumber);
		
      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (funcRc);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      shakingTime = m_shakingTimeOut.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

      // add 60 seconds to the started shaking time (secure that the shaking time out is reached before the wait time out)
      shakingTime = shakingTime + m_waitTimeOutSecurity;

      #ifdef _DEBUG
      progressTrace(funcId, "Function timeout = ", IStr(shakingTime));
      #endif

		// pollen 
		pollingForRunningShaker(deviceNumber, shakingTime - m_waitTimeOutSecurity);

      // start wait for shaker
		cmdResult = sendMsg(deviceNumber, command, parameter, shakingTime, hslTrue);

      // shaker was started with StartShaker or StartAllShaker
      if(cmdResult.Find(m_fwNoError) < 0)
      {
         // stop shaker
         sendMsg(deviceNumber, "SC", "", m_usbMsgTimeout, hslTrue);
      }

      // open plate lock
      startPlateLockCmd(funcId, deviceNumber, m_OFF);

      SynEnterCriticalSection(m_hhsCriticalSection);
   	m_userShakingSpeed[deviceNumber-1] = m_OFF;
		m_shakingTimeOut[deviceNumber-1] = m_OFF;
		SynLeaveCriticalSection(m_hhsCriticalSection);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }

   //====================================================================
	//
	// Application function StartAllShaker()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Lock plate and start shaking for all initialized shaker.
   //....................................................................
   // Parameters:
   //  shakingSpeed	:	Shaking speed in RPM round per minutes
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StartAllShaker(variable shakingSpeed)
   {
      variable funcRc(IDE::retNotInitErr);
      variable funcId(IDF::StartAllShaker);
      variable deviceNumber(0);

      startTrace(funcId);

		// parameter are checked in StartShaker() function

      for( deviceNumber = 1; deviceNumber <= m_maxHHS; deviceNumber++)
      {
         if(isHeaterInitialized(deviceNumber))
         {
            // call StartShaker with 1 base node
            funcRc = StartShaker(deviceNumber, shakingSpeed);
				if(0 < funcRc)
				{
					errorCompleteTrace(funcId, "");
					return (funcRc);
				}
            funcRc = IDE::noError;
         }
      }

		if(0 < funcRc)
		{
			errorCompleteTrace(funcId, IDE::retNotInitErr);
			return (funcRc);
		}
      endTrace(funcId);
      return (funcRc);
   }

   //====================================================================
	//
	// Application function StartAllShakerTimed()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Lock plate and start shaking with timed duration for all initialized shaker.
   //....................................................................
   // Parameters:
   //  shakingSpeed	:	Shaking speed in RPM round per minutes
   //  shakingTime	:  Shaking time in seconds
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StartAllShakerTimed(variable shakingSpeed, variable shakingTime)
   {
      variable funcRc(IDE::retNotInitErr);
      variable funcId(IDF::StartAllShakerTimed);
      variable deviceNumber(0);

      startTrace(funcId);

		// parameter are checked in StartShakerTimed() function

      for( deviceNumber = 1; deviceNumber <= m_maxHHS; deviceNumber++)
      {
         if(isHeaterInitialized(deviceNumber))
         {
            // call StartShaker with 1 base node
            funcRc = StartShakerTimed(deviceNumber, shakingSpeed, shakingTime);
				if(0 < funcRc)
				{
					errorCompleteTrace(funcId, "");
					return (funcRc);
				}
            funcRc = IDE::noError;
         }
      }

		if(0 < funcRc)
		{
			errorCompleteTrace(funcId, IDE::retNotInitErr);
			return (funcRc);
		}
      endTrace(funcId);
      return (funcRc);
   }

   //====================================================================
	//
	// Application function StopAllShaker()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Stop shaking and unlock plate for all initialized shaker.
   //  
   //....................................................................
   // Parameters:
   //  none
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StopAllShaker()
   {
      variable funcRc(IDE::retNotInitErr);
      variable funcId(IDF::StopAllShaker);
      variable deviceNumber(0);

      startTrace(funcId);

      for( deviceNumber = 1; deviceNumber <= m_maxHHS; deviceNumber++)
      {
         if(isHeaterInitialized(deviceNumber))
         {
            // call StopShaker with 1 base node
            funcRc = StopShaker(deviceNumber);
				if(0 < funcRc)
				{
					errorCompleteTrace(funcId, "");
					return (funcRc);
				}
            funcRc = IDE::noError;
         }
      }
		if(0 < funcRc)
		{
			errorCompleteTrace(funcId, IDE::retNotInitErr);
			return (funcRc);
		}

      endTrace(funcId);
      return (funcRc);
   }


   //====================================================================
	//
	// Application function SetShakerParameter()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set the parameter for plate shaking
   //....................................................................
   // Parameters:
   //  deviceNumber 		:  device number which was generated on CreateXXDevice() 
   //  shakingDirection :  Shaking direction left/right (0/1)
   //  shakingAccRamp   :  Acceleration ramp (1..4)
   // ...................................................................
   // return value:
   //  Raise      :  Wrong parameter 
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SetShakerParameter(
      variable deviceNumber,
      variable shakingDirection,
      variable shakingAccRamp) void
   {
      variable funcId(IDF::SetShakerParameter);
		variable node;
      string   nodeType;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      checkIntegerInputRange(funcId, "shakingDirection", shakingDirection, m_OFF, m_ON);
      //tb 2008-12-03 checkIntegerInputRange(funcId, "shakingAccRamp", shakingAccRamp, ShakingParam::rampMin, ShakingParam::rampMax);
      checkIntegerInput(funcId, "shakingAccRamp", shakingAccRamp);

      if(isStarDevice(deviceNumber))
         nodeType = StringTable::Load(IDS::starNode);
      else
         nodeType = StringTable::Load(IDS::usbNode);

		node = getNodeFromDeviceNumber(deviceNumber);

      progressTrace(funcId, nodeType, IStr(node));
      progressTrace(funcId, IDS::shakingDirection, IStr(shakingDirection));
      progressTrace(funcId, IDS::shakingAccRamp, IStr(shakingAccRamp));

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasShaker(funcId, deviceNumber, 1);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      m_shakingDirection[deviceNumber-1] = shakingDirection;
      m_shakingAccRamp[deviceNumber-1] = shakingAccRamp;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      endTrace(funcId);
      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }


   //====================================================================
	//
	// Application function GetShakerParameter()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get the parameter for plate shaking
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  shakingDirection :  Shaking direction left/right (0/1)
   //  shakingAccRamp   :  Acceleration ramp (1..4)
   // ...................................................................
   // return value:
   //  Raise      :  Wrong parameter 
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetShakerParameter(
      variable deviceNumber,
      variable& shakingDirection,
      variable& shakingAccRamp) void
   {
      variable funcId(IDF::GetShakerParameter);
      variable node;
      string   nodeType;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      shakingDirection = ShakingParam::directionDefault;
      shakingAccRamp = ShakingParam::rampDefault;

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasShaker(funcId, deviceNumber, 1);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      shakingDirection = m_shakingDirection.GetAt(deviceNumber-1);
      shakingAccRamp = m_shakingAccRamp.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

		node = getNodeFromDeviceNumber(deviceNumber);

      if(isStarDevice(deviceNumber))
         nodeType = StringTable::Load(IDS::starNode);
      else
         nodeType = StringTable::Load(IDS::usbNode);

      progressTrace(funcId, nodeType, IStr(node));
      progressTrace(funcId, IDS::shakingDirection, IStr(shakingDirection));
      progressTrace(funcId, IDS::shakingAccRamp, IStr(shakingAccRamp));

      endTrace(funcId);
      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }

   //====================================================================
	//
	// Application function GetShakerSpeed()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Lock plate and start shaking with timed duration.
   //....................................................................
   // Parameters:
   //  in : deviceNumber 	:  device number which was generated on CreateXXDevice() 
   //  out: shakingSpeed	:	Shaking speed in RPM round per minutes
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetShakerSpeed(
         variable deviceNumber,
			variable& shakingSpeed)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::GetShakerSpeed);

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
		shakingSpeed = 0;

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

		hasShaker(funcId, deviceNumber, 1);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

		shakingSpeed = getCurrentShakerRPM(deviceNumber, hslTrue);

	   endTrace(funcId);
      return (funcRc);
   }

   //====================================================================
	//
	// Application function StartTempCtrl()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set incubation temperature and wait (if set) until temperature is reached
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  temperature         :  Incubation temperature
   //  waitForTempReached  :  Flag for waiting until temperature is reached
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StartTempCtrl(
      variable deviceNumber,
      variable temperature,
      variable waitForTempReached)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::StartTempCtrl);
      variable tempStartTimeOut;
      variable tempToleranceRange;
      variable tempSecurityRange;
      variable command("TA");
      variable parameter("ta%s1tb%s2tc%s3td%s4");
      variable cmdResult;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      //tb 2008-12-03 checkDoubleInputRange(funcId, "temperature", temperature, TemperateParam::tempMin, TemperateParam::tempMax);
      checkDoubleInput(funcId, "temperature", temperature);
      checkIntegerInputRange(funcId, "waitForTempReached", waitForTempReached, m_OFF, m_ON);

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      tempStartTimeOut = m_tempStartTimeOut.GetAt(deviceNumber-1);
      tempToleranceRange = m_tempToleranceRange.GetAt(deviceNumber-1);
      tempSecurityRange = m_tempSecurityRange.GetAt(deviceNumber-1);
		m_userTemperature[deviceNumber-1] = temperature;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      StrReplace(parameter, "%s1", normalizeParam(temperature, TemperateParam::paramLength));
      StrReplace(parameter, "%s2", formatParam(tempStartTimeOut, TemperateParam::paramLength));
      StrReplace(parameter, "%s3", normalizeParam(tempToleranceRange, TemperateParam::paramLength));
      StrReplace(parameter, "%s4", normalizeParam(tempSecurityRange, TemperateParam::paramLength));

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslFalse);
      if(0 < funcRc)
         return (funcRc);

      // add 60 seconds to the started heat up time (secure that the heat up time out is reached before the wait time out)
      tempStartTimeOut = tempStartTimeOut + m_waitTimeOutSecurity;
      if(tempStartTimeOut < m_usbMsgTimeout)
         tempStartTimeOut = m_usbMsgTimeout;


      #ifdef _DEBUG
      progressTrace(funcId, "Function timeout = ", IStr(tempStartTimeOut));
      #endif

      // set temperature
      cmdResult = sendMsg(deviceNumber, command, parameter, tempStartTimeOut, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslFalse);

		// command waits until temperature is in controlling mode
      if(waitForTempReached == m_ON && funcRc == IDE::noError)
		{
			pollingForRunningHeater(deviceNumber, tempStartTimeOut-m_waitTimeOutSecurity);

	      // wait for temperature
	      cmdResult = sendMsg(deviceNumber, "TW", "", m_usbMsgTimeout, hslTrue);
		}

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }

   //====================================================================
	//
	// Application function StopTempCtrl()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set incubation temperature control off
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function StopTempCtrl(
      variable deviceNumber)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::StopTempCtrl);
      variable command("TO");
      variable parameter("");
      variable cmdResult;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslFalse);
      if(0 < funcRc)
         return (funcRc);

      // set temperature
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      SynEnterCriticalSection(m_hhsCriticalSection);
   	m_userTemperature[deviceNumber-1] = 0;
		SynLeaveCriticalSection(m_hhsCriticalSection);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);
   }

   //====================================================================
	//
	// Application function WaitForTempCtrl()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Waits until the on StartTempCtrl() given temperature is reached
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function WaitForTempCtrl(
      variable deviceNumber)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::WaitForTempCtrl);
      variable tempStartTimeOut;
      variable command("TW");
      variable parameter("");
      variable cmdResult;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      tempStartTimeOut = m_tempStartTimeOut.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

      // add 60 seconds to the started heat up time (secure that the heat up time out is reached before the wait time out)
      tempStartTimeOut = tempStartTimeOut + m_waitTimeOutSecurity;
      if(tempStartTimeOut < m_usbMsgTimeout)
         tempStartTimeOut = m_usbMsgTimeout;


      #ifdef _DEBUG
      progressTrace(funcId, "Function timeout = ", IStr(tempStartTimeOut));
      #endif

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslFalse);
      if(0 < funcRc)
         return (funcRc);

		// make a polling until temperature controlling is in controlling mode
		pollingForRunningHeater(deviceNumber, tempStartTimeOut-m_waitTimeOutSecurity);

      // wait for temperature is reached (get heating up errors)
      cmdResult = sendMsg(deviceNumber, command, parameter, tempStartTimeOut, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }


   //====================================================================
	//
	// Application function GetTemperature()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get the current temperatur
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  temperature         :  Actual carrier temperature 
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetTemperature(
      variable deviceNumber,
      variable& temperature)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::GetTemperature);

      startTrace(funcId);

      temperature = 0;

		checkDeviceNumber(funcId, deviceNumber);

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslFalse);
      if(0 < funcRc)
         return (funcRc);

		temperature = getCurrentTemp(deviceNumber, hslTrue);

      endTrace(funcId);
      return (funcRc);
   }


   //====================================================================
	//
	// Application function GetTemperatureState()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get the state of temperatur supervision
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  temperatureState    :  State of temperature supervision 0 = OK, 1 = out of range, 2 = out of security
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetTemperatureState(
      variable deviceNumber,
      variable& temperatureState)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::GetTemperatureState);
      variable command("QE");
      variable parameter("");
      string   cmdResult;
      variable startPos;


      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      temperatureState = TemperateParam::tempStateOk;

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslFalse);
      if(0 < funcRc)
         return (funcRc);

     	// wait for temperature is reached
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      // format: qe##
      startPos = cmdResult.Find("qe");

      if((cmdResult.GetLength() < TemperateParam::tempStateRequestLength) || (startPos < 0))
      {
         variable errMsg;
         // "Unknown format of firmware result string.\r\nExpected: '%s1'.\r\nReceived: '%s2'."
         errMsg = StringTable::Load(IDE::unknownResultFormat);

         StrReplace(errMsg, "%s1", "qe##");
         StrReplace(errMsg, "%s2", cmdResult);

         errorCompleteTrace(funcId, errMsg);
         return (IDE::unknownResultFormat);
      }

      // read both temperature and calculate the average 
      // format: qe## ( 00, 62 or 63 )
      if(cmdResult.Find("qe62") >= 0)
         temperatureState = TemperateParam::tempStateOutOfRange;
      else
      if(cmdResult.Find("qe63") >= 0)
         temperatureState = TemperateParam::tempStateOutOfSecurity;
      else
      if(cmdResult.Find("qe00") < 0)
         temperatureState = TemperateParam::tempStateTimeOut;

      endTrace(funcId);
      return (funcRc);
   }


   //====================================================================
	//
	// Application function SetTempParameter()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set the parameter of temperatur supervision
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  startTimeout        :  Time which must elapse before temperature will be controlled
   //  toleranceRange      :  Range of temperature tolerance
   //  securityRange       :  Range of temperature security, on leave heater will be switched off
   // ...................................................................
   // return value:
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SetTempParameter(
      variable deviceNumber,
      variable startTimeout, variable toleranceRange, variable securityRange) void
   {
      variable funcId(IDF::SetTempParameter);
      variable node;
      string   nodeType;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      //tb 2008-12-03 checkIntegerInputRange(funcId, "startTimeout", startTimeout, TemperateParam::startTimeOutMin, TemperateParam::startTimeOutMax);
      checkIntegerInput(funcId, "startTimeout", startTimeout);
      //tb 2008-12-03 checkDoubleInputRange(funcId, "toleranceRange", toleranceRange, TemperateParam::tempToleranceMin, TemperateParam::tempToleranceMax);
      checkDoubleInput(funcId, "toleranceRange", toleranceRange);
      //tb 2008-12-03 checkDoubleInputRange(funcId, "securityRange", securityRange, TemperateParam::tempSecurityMin, TemperateParam::tempSecurityMax);
      checkDoubleInput(funcId, "securityRange", securityRange);

      if(isStarDevice(deviceNumber))
         nodeType = StringTable::Load(IDS::starNode);
      else
         nodeType = StringTable::Load(IDS::usbNode);

		node = getNodeFromDeviceNumber(deviceNumber);

      progressTrace(funcId, nodeType, IStr(node));
      progressTrace(funcId, IDS::startTimeout, IStr(startTimeout));
      progressTrace(funcId, IDS::toleranceRange, FStr(toleranceRange, hslTrue));
      progressTrace(funcId, IDS::securityRange, FStr(securityRange, hslTrue));

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);
 
 		hasHeater(funcId, deviceNumber, 1);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      m_tempStartTimeOut[deviceNumber-1] = startTimeout;
      m_tempToleranceRange[deviceNumber-1] = toleranceRange;
      m_tempSecurityRange[deviceNumber-1] = securityRange;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      endTrace(funcId);
      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }


   //====================================================================
	//
	// Application function GetTempParameter()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get the parameter of temperatur supervision
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  startTimeout        :  Time which must elapse before temperature will be controlled
   //  toleranceRange      :  Range of temperature tolerance
   //  securityRange       :  Range of temperature security, on leave heater will be switched off
   // ...................................................................
   // return value:
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetTempParameter(
      variable deviceNumber,
      variable& startTimeout, variable& toleranceRange, variable& securityRange) void
   {
      variable funcId(IDF::GetTempParameter);
      variable node;
      string   nodeType;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      // init output parameter
      startTimeout = TemperateParam::startTimeOutDefault;
      toleranceRange = TemperateParam::tempToleranceDefault;
      securityRange = TemperateParam::tempSecurityDefault;

      initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);

		hasHeater(funcId, deviceNumber, 1);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      // set output parameter
      startTimeout = m_tempStartTimeOut.GetAt(deviceNumber-1);
      toleranceRange = m_tempToleranceRange.GetAt(deviceNumber-1);
      securityRange = m_tempSecurityRange.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

      if(isStarDevice(deviceNumber))
         nodeType = StringTable::Load(IDS::starNode);
      else
         nodeType = StringTable::Load(IDS::usbNode);

		node = getNodeFromDeviceNumber(deviceNumber);

      progressTrace(funcId, nodeType, IStr(node));
      progressTrace(funcId, IDS::startTimeout, IStr(startTimeout));
      progressTrace(funcId, IDS::toleranceRange, FStr(toleranceRange, hslTrue));
      progressTrace(funcId, IDS::securityRange, FStr(securityRange, hslTrue));

      endTrace(funcId);
      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }


   //====================================================================
	//
	// Application function SetPlateLock()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set the parameter for plate shaking
   //  
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  plateLock        :  Lock / unlock flag
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SetPlateLock(
            variable deviceNumber,
            variable plateLock)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::SetPlateLock);
      variable cmdResult;
         
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      checkIntegerInputRange(funcId, "plateLock", plateLock, m_OFF, m_ON);

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

		hasShaker(funcId, deviceNumber, 1);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      // start lock command
      cmdResult = startPlateLockCmd(funcId, deviceNumber, plateLock);
      funcRc = isFirmwError(funcId, cmdResult, hslTrue);
      if(0 < funcRc)
         return (funcRc);

      endTrace(funcId);
      return (funcRc);
   }

   //====================================================================
	//
	// Application function GetFirmwareVersion()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get firmware version of current HHS
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 		:  device number which was generated on CreateXXDevice() 
   //  out: firmwareVersion   :  firmware version format: "1.0P 1999-03-10"
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetFirmwareVersion(
			variable deviceNumber,
			variable& firmwareVersion)
	{
      variable funcRc(IDE::noError);
      variable funcId(IDF::GetFirmwareVersion);
		string 	answString;
		variable startPos;
      
      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      firmwareVersion = "0.0S 2008-01-01";

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

		// read the firmware version of current node
		answString = sendMsg(deviceNumber, "RF", "", m_usbInitTimeout, hslTrue);

		startPos = answString.Find("rf");
		if(startPos >= 0)
		{
			firmwareVersion = answString.Right(answString.GetLength()-(startPos+2));
		}

      endTrace(funcId);
      return (funcRc);
	}


   //====================================================================
	//
	// Application function GetSerialNumber()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get serial number of current HHS
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 		:  device number which was generated on CreateXXDevice() 
   //  out: firmwareVersion   :  firmware serial number format: "####"
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function GetSerialNumber(
				variable deviceNumber,
				variable& serialNumber)
	{
      variable funcRc(IDE::noError);
      variable funcId(IDF::GetSerialNumber);
		string 	answString;
		variable startPos;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      serialNumber = "0000";

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

		// read the firmware version of current node
		answString = sendMsg(deviceNumber, "QT", "", m_usbInitTimeout, hslTrue);

		// format: qt######/##/#### part number, revision, serial number
		startPos = answString.Find("qt");
		if(startPos >= 0 && answString.GetLength() > startPos+12)
		{
			serialNumber = answString.Mid((startPos+2+10), 4);
		}

      endTrace(funcId);
      return (funcRc);
	}


   //====================================================================
	//
	// Application function BeginMonitoring()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get serial number of current HHS
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 	:  device number which was generated on CreateXXDevice() 
   //  in : shakerMin   	:  Minimum RPM
   //  in : shakerMax   	:  Maximum RPM
   //  in : sampleInterval :  Interval in sec. for check RPM and temperature
   //  in : action   		:  Continue / Abort (0 / 1)
	// 								Note: Abort will only called on an error after temperature controlling is activated ()
	//											An abort will end only the current heater/shaker.
	// 								Note:	heaterMin and heaterMax uses the parameter toleranceRange of SetTempParameter()
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function BeginMonitoring(
				variable deviceNumber,
				variable shakingToleranceRange,
				variable sampleInterval,
				variable action)
	{
      variable funcRc(IDE::noError);
      variable funcId(IDF::BeginMonitoring);
		string 	answString;
		variable startPos;
		event		startEvent;
		variable sSpeed;
		variable hTemp;
		variable shakerMin(m_OFF);
		variable shakerMax(ShakingParam::rpmMax);
		variable heaterTempTol(m_OFF);
		variable heaterMin(TemperateParam::tempMin);
		variable heaterMax(TemperateParam::tempMax);
		variable node;
      variable nodeType;
		variable funcName;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      checkIntegerInputRange(funcId, "shakingToleranceRange", shakingToleranceRange, ShakingParam::shakeTolMin, ShakingParam::shakeTolMax);
   	checkIntegerInputRange(funcId, "sampleInterval", sampleInterval, m_minSampleInterval, m_maxSampleInterval);
      checkIntegerInputRange(funcId, "action", action, MonitorAction::monitorActionMin, MonitorAction::monitorActionMax);

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
   	sSpeed = m_userShakingSpeed.GetAt(deviceNumber-1);
   	hTemp = m_userTemperature.GetAt(deviceNumber-1);
		heaterTempTol = m_tempToleranceRange.GetAt(deviceNumber-1);
		m_monitorResult.SetAt(deviceNumber-1, -1);
		SynLeaveCriticalSection(m_hhsCriticalSection);
		onerror goto 0;

      if(isStarDevice(deviceNumber))
         nodeType = StringTable::Load(IDS::starNode);
      else
         nodeType = StringTable::Load(IDS::usbNode);
		node = getNodeFromDeviceNumber(deviceNumber);

		// if no shaker is initialized, set the maximum range
		if(hasShaker(funcId, deviceNumber, 0) && sSpeed > m_OFF)
		{
			shakerMin = sSpeed-shakingToleranceRange;
			if(shakerMin < 0)
				shakerMin = 0;
			shakerMax = sSpeed+shakingToleranceRange;
		}
		else if(sSpeed == m_OFF)
		{
			string moniText;
			moniText = StringTable::Load(IDS::monitoringShNotStart);
         StrReplace(moniText, "%s1", nodeType);
         StrReplace(moniText, "%s2", IStr(node));

			// Shaking on %s1 ( %s2 ) not started, check of speed limit will be disabled!
			progressTrace(funcId, IDS::monitoringWarning, moniText);
		}

		if(hasHeater(funcId, deviceNumber, 0) && hTemp > m_OFF)
		{
			heaterMin = hTemp - heaterTempTol;
			if(heaterMin < m_OFF)
				heaterMin = m_OFF;
			heaterMax = hTemp + heaterTempTol;
		}
		else if(hTemp == m_OFF)
		{
			variable moniText;
			moniText = StringTable::Load(IDS::monitoringHeNotStart);
         StrReplace(moniText, "%s1", nodeType);
         StrReplace(moniText, "%s2", IStr(node));

			// Heating up on %s1 ( %s2 ) not started, check of temperature limit will be disabled!
			progressTrace(funcId, IDS::monitoringWarning, moniText);
		}

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);

      // Prepare the globals for the hsl thread.
	   m_monitorDeviceNumber				= deviceNumber;
	   m_monitorShakerMin					= shakerMin;
	   m_monitorShakerMax					= shakerMax;
	   m_monitorSampleInterval				= sampleInterval;
	   m_monitorAction						= action;
	   m_monitorResult[deviceNumber-1] 	= -1;
		m_monitorHeaterMin					= heaterMin;
		m_monitorHeaterMax					= heaterMax;


      Fork( "monitorHeaterShaker" );

		// wait until thread has received the global data (maximum 10 seconds)
		m_monitorStartEvent.WaitEvent(10);

		SynLeaveCriticalSection(m_hhsCriticalSection);

      endTrace(funcId);
      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
	}


   //====================================================================
	//
	// Application function EndMonitoring()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Get serial number of current HHS
   //  
   //....................................................................
   // Parameters:
   //  in : deviceNumber 	:  device number which was generated on CreateXXDevice() 
   //  out: monitorResult  :  -1 = monitoring has not started or is not initialized
	// 								0 = heating and shaking values were within specification
	// 								1 = heating out of range
	// 								2 = shaking out of range
	// 								3 = heating and shaking out of range
   // ...................................................................
   // return value:
   //  noError(0)          :  all nodes are initialized successfull.
   //  retErr(1)           :  initialisation failed 
   //  retNotInitErr(2)    :  needed node not initalized
   //  retNotConnectErr(3) :  device not connected
   //  Raise               :  An exception is throw on wrong parameter or time out 
   //  FirmErr             :  Firmware command error
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function EndMonitoring(
				variable deviceNumber,
				variable& monitorResult)
	{
      variable funcRc(IDE::noError);
      variable funcId(IDF::EndMonitoring);
		event		intervalEvent;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_OFF);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		intervalEvent = m_monitorEvent.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

      intervalEvent.SetEvent();

      SynEnterCriticalSection(m_hhsCriticalSection);
		monitorResult = m_monitorResult.GetAt(deviceNumber-1);
		m_monitorResult.SetAt(deviceNumber-1, -1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

      endTrace(funcId);
		return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
	}


   //====================================================================
	//
	// Application function SetSimulation()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set the internal flag m_isSimulate.
   //  If this flag is set, only parameter checks are made on all exported function
   //  
   //....................................................................
   // Parameters:
   //  simulate   :  Flag for set the simulate mode, must be a number 0/1
   //
   // ...................................................................
   // return value:
   //  Raise      :  Wrong parameter 
   //....................................................................
   // Remarks:
   //   
	//====================================================================
 	function SetSimulation(variable simulate) void
	{
      variable funcId(IDF::SetSimulation);

      startTrace(funcId);

      checkIntegerInputRange(funcId, "simulate", simulate, m_OFF, m_ON);

  		progressTrace(funcId, IDS::setSimulate, IStr(simulate));

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      m_isSimulate = hslFalse;
      if(simulate == m_ON)
		   m_isSimulate = hslTrue;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      endTrace(funcId);
      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
	}


   //====================================================================
	//
	// Application function SendFirmwareCommand()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Send a command to the device
   //  
   //....................................................................
   // Parameters:
   //  deviceNumber :  device number which was generated on CreateXXDevice() 
   //  command				:  Firmware command without node name ( 2 letter )
   //  parameter			:  Parameter dependent of the used command
   // ...................................................................
   // return value:
   //  Raise            :  An exception is throw on wrong parameter or time out 
   //  string           :  Firmware command result data string
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SendFirmwareCommand(
      variable deviceNumber,
      variable command, variable parameter)
   {
      variable funcRc(IDE::noError);
      variable funcId(IDF::SendFirmwareCommand);
      string   cmd;
      string   cmdResult;

      startTrace(funcId);

		checkDeviceNumber(funcId, deviceNumber);
      checkStringInput(funcId, "command", command);
      checkStringInput(funcId, "parameter", parameter);

      // check for two character as command
      cmd = command;
      if(cmd.GetLength() != m_firmwareCmdLength)
      {
         variable funcName;
         string errMsg;

         // "Wrong length of input parameter.\r\nParameter = '%s1' length (%s2).\r\nExpected lenght (%s3)."
         errMsg = StringTable::Load(IDE::wrongParameterLength);
         StrReplace(errMsg, "%s1", "command");
         StrReplace(errMsg, "%s2", IStr(cmd.GetLength()));
         StrReplace(errMsg, "%s3", IStr(m_firmwareCmdLength));

         funcName = StringTable::Load(funcId);

         Error::RaiseEx(IDE::wrongParameterLength, errMsg, GetFileName(), funcName, GetLineNumber());
      }

      funcRc = initHamHeaterShakerLib(funcId, deviceNumber, m_ON);
      if(0 < funcRc)
         return (funcRc);

      sendToProgressTrace(funcId, deviceNumber);

      if(isSimulate(funcId, deviceNumber, hslTrue))
         return (IDE::noError);

      // check for initialized and connect
      funcRc = getSendState(funcId, deviceNumber, hslTrue);
      if(0 < funcRc)
         return (funcRc);

     	// wait for temperature is reached
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      endTrace(funcId);
      return (cmdResult);
   }

   //====================================================================
	//
	// Application function SetUSBTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Set the parameter for plate shaking
   //  
   //....................................................................
   // Parameters:
   //  trace				:  Trace on / off. 0 = off, 1 = on
   // ...................................................................
   // return value:
   //  Raise            :  An exception is throw on wrong parameter or time out 
   //....................................................................
   // Remarks:
   //   
	//====================================================================
   function SetUSBTrace(variable trace) void
   {
      variable funcId(IDF::SetUSBTrace);

      startTrace(funcId);

      checkIntegerInputRange(funcId, "trace", trace, m_OFF, m_ON);

  		progressTrace(funcId, IDS::setTrace, IStr(trace));

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		m_usbTrace = hslFalse;
      // set trace flag
      if(trace == 1)
			m_usbTrace = hslTrue;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      endTrace(funcId);
      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }


	/****************************************************************************************
	*	
	* Internal helper function declaration
	*
	****************************************************************************************/


	// --------------------------------------------------------------------------------------
	// Library Initialization and data access functions
	// --------------------------------------------------------------------------------------
   static function initStringTable() void
   {
		// activate error handler
		onerror goto Unexpected;

		if(0 == m_hhsCriticalSection)
			m_hhsCriticalSection = SynInitializeCriticalSection();

      SynEnterCriticalSection(m_hhsCriticalSection);
      if(!m_isStringTableInitialized)
      {
			StringTable::Init("HSLHamHeaterShakerStringTable");
         m_isStringTableInitialized = hslTrue;
      }
      SynLeaveCriticalSection(m_hhsCriticalSection);

      return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }

	static function InitializeNode(variable funcId, variable deviceNumber)
	{
      variable funcRc(IDE::noError);
		variable node;
      variable nodeNameId(IDS::starNode);

      // check if the library set to simulate
      if(isSimulate(funcId, deviceNumber, hslFalse))
         return(funcRc);

      // init node if needed      
      if(!isHeaterInitialized(deviceNumber))
      {  
         string answString;
			variable hhsSettings(-1);

			// on usb check connection
			if(!isStarDevice(deviceNumber))
			{
            if(!isUsbConnected(funcId))
               return (IDE::retNotConnectErr);
				nodeNameId = IDS::usbNode;
			}

			// ask for settings
         setHHSSetting(funcId, deviceNumber, hhsSettings);
         if(0 < funcRc)
             return (funcRc);

			// check if shaking activated
			if((hhsSettings != m_shakingPropertyHeatAndShake) && (hhsSettings != m_shakingPropertyOnlyShake))
            return (funcRc);

         // init HHS on nodes if needed
			answString = sendMsg(deviceNumber, "QW", "", m_usbInitTimeout, hslTrue);

			if(isStarDevice(deviceNumber))
			{

            funcRc = isFirmwError(funcId, answString, hslTrue);
            if(0 < funcRc)
                return (funcRc);
			}

			node = getNodeFromDeviceNumber(deviceNumber);
     
         // check for timeout, if timeout, only node 0 is installed without any other CAN nodes
         // if CAN error, this node is not available
         if((answString.Find(m_fwTimeoutError) >= 0) || (answString.Find(m_fwCanError) >= 0))
         {
            // "%s1 '%s2' not available."
            string msg;
            string nodeName;
            variable funcName;
            msg = StringTable::Load(IDE::neededNodeNotAvailable);
            nodeName = StringTable::Load(nodeNameId);
            funcName = StringTable::Load(funcId);


            StrReplace(msg, "%s1", nodeName);
            StrReplace(msg, "%s2", IStr(node));
            errorCompleteTrace(funcId, msg);

            if(answString.Find(m_fwTimeoutError) >= 0)
               Error::RaiseEx(IDE::neededNodeNotAvailable, msg, GetFileName(), funcName, GetLineNumber());
            else
               Error::RaiseEx(IDE::canError, msg, GetFileName(), funcName, GetLineNumber());
         }

			traceFirmwareVersion(funcId, deviceNumber);
			
         if(answString.Find(m_fwIsInitialized) >= 0)
            setHeaterInitialized(deviceNumber);
         else
         {
// change of 2009/08/13
//            answString = sendMsg(deviceNumber, "SI", "", m_usbInitTimeout, hslTrue);
//            if(answString.Find(m_fwNoError) >= 0)
//            {
//	            answString = sendMsg(deviceNumber, "LI", "", m_usbInitTimeout, hslTrue);
//               if(answString.Find(m_fwNoError) >= 0)
//                  setHeaterInitialized(deviceNumber);
//            }
            answString = sendMsg(deviceNumber, "LI", "", m_usbInitTimeout, hslTrue);
            sendMsg(deviceNumber, "LP", "lp1", m_usbInitTimeout, hslTrue);

            if(answString.Find(m_fwNoError) >= 0)
            {
	            answString = sendMsg(deviceNumber, "SI", "", m_usbInitTimeout, hslTrue);

               if(answString.Find(m_fwNoError) >= 0)
                  setHeaterInitialized(deviceNumber);

               sendMsg(deviceNumber, "LP", "lp0", m_usbInitTimeout, hslTrue);
            }
// end change of 2009/08/13

            funcRc = isFirmwError(funcId, answString, hslTrue);
            if(0 < funcRc)
               return (funcRc);
         }
      }

      return (funcRc);
   }


	static function initHamHeaterShakerLib(variable funcId, variable deviceNumber, variable initShaker)
	{
      variable funcRc(IDE::noError);
      initStringTable();

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);

      if(!m_initializedLib)
      {
         variable nodeIndex(0);

			RegisterAbortHandler("HSLHamHeaterShaker::OnAbortHHSLibrary");

		   m_monitorDeviceNumber	= m_OFF;
		   m_monitorShakerMin		= m_OFF;
		   m_monitorShakerMax		= m_OFF;
		   m_monitorSampleInterval	= m_OFF;
		   m_monitorAction			= m_OFF;

         for( nodeIndex = 0; nodeIndex < m_maxHHS; nodeIndex++)
         {
            m_initializedHeater[nodeIndex] = hslFalse;
            m_shakingDirection[nodeIndex] = ShakingParam::directionDefault;
            m_shakingAccRamp[nodeIndex] = ShakingParam::rampDefault;
            m_shakingTimeOut[nodeIndex] = m_OFF;
            m_tempStartTimeOut[nodeIndex] = TemperateParam::startTimeOutDefault;
            m_tempToleranceRange[nodeIndex] = TemperateParam::tempToleranceDefault;
            m_tempSecurityRange[nodeIndex] = TemperateParam::tempSecurityDefault;
				m_userShakingSpeed[nodeIndex] = m_OFF;
				m_userTemperature[nodeIndex] = m_OFF;

				m_deviceName[nodeIndex] = "";
				m_isStarSimulate[nodeIndex] = hslFalse;
				m_nodeNumber[nodeIndex] = m_OFF;
				m_hhsSetting[nodeIndex] = m_OFF;

				m_monitorResult[nodeIndex] = -1;
         }

         m_initializedLib = hslTrue;

		}

      SynLeaveCriticalSection(m_hhsCriticalSection);

      // check for node initialize, this call must be outside of CriticalSection
      if(initShaker > m_OFF)
         funcRc = InitializeNode(funcId, deviceNumber);

      return (funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
	}

   static function isUsbConnected(variable funcId)
   {
      variable rc (hslFalse);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);

      if(!m_usbComObject.IsNull())
      {
         if(m_usbComObject.Connected)
            rc = hslTrue;
      }

      SynLeaveCriticalSection(m_hhsCriticalSection);

      if(!rc)
      {
         variable msg;
         msg = StringTable::Load(IDS::noUsbConnection);
         errorCompleteTrace(funcId, msg);
      }

      return (rc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
   }

 	static function isSimulate(variable funcId, variable deviceNumber, variable makeTrace)
	{
      variable retVal(hslFalse);
      variable starSimState(hslFalse);

		// activate error handler
		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		retVal = m_isSimulate;
      starSimState = m_isStarSimulate[deviceNumber-1];
      SynLeaveCriticalSection(m_hhsCriticalSection);

      // if m_isSimulate is set, both devices are simulate
      // if m_isSimulate is not set, check if useMlStar and m_isStarSimulate is set

      if(retVal)
      {
         // if simulate, trace the function end
         if(makeTrace)
     		   endTrace(funcId);
         return (retVal);
      }

      if(starSimState)
      {
         // if simulate, trace the function end
         if(makeTrace)
        		endTrace(funcId);
         return (hslTrue);
      }

      // simulation is not set
      return (retVal);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
         return (retVal);
      }
	}

   // uses node from 1 to 10
   static function isHeaterInitialized(variable deviceNumber)
   {
      variable retVal(hslFalse);

   	// activate error handler
   	onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      retVal = m_initializedHeater.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

      return (retVal);

   	Unexpected:
   	{
         SynLeaveCriticalSection(m_hhsCriticalSection);
         return (retVal);
      }
   }

   // uses node from 1 to 10
   static function setHeaterInitialized(variable deviceNumber)
   {
      variable retVal(hslFalse);

   	// activate error handler
   	onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      m_initializedHeater[deviceNumber-1] = hslTrue;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      return (retVal);

   	Unexpected:
   	{
         SynLeaveCriticalSection(m_hhsCriticalSection);
         return (retVal);
      }
   }

   static function isUsbTrace()
   {
      variable retVal(hslFalse);

   	// activate error handler
   	onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
      retVal = m_usbTrace;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      return (retVal);

   	Unexpected:
   	{
         SynLeaveCriticalSection(m_hhsCriticalSection);
         return (retVal);
      }
   }


 	// --------------------------------------------------------------------------------------
	// Communication functions
	// --------------------------------------------------------------------------------------
 
 	//====================================================================
	//
	// Internal function getSendState()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Check the connect and initialize state.
   //  Must be call from each interface function which will send a command to the shaker
	//====================================================================
   static function getSendState(variable funcId, variable deviceNumber, variable isShaker)
   {
      variable node;
      variable nodeTxt;

		node = getNodeFromDeviceNumber(deviceNumber);
      nodeTxt = StringTable::Load(IDS::starNode);


      if(!isStarDevice(deviceNumber))
      {
         if(!isUsbConnected(funcId))
            return (IDE::retNotConnectErr);
         nodeTxt = StringTable::Load(IDS::usbNode);
      }

      if(!isHeaterInitialized(deviceNumber) && isShaker)
      {
         // "%s1 '%s2' not initialized'."
         variable msg;
         msg = StringTable::Load(IDS::neededNodeNotInitialized);
         StrReplace(msg, "%s1", nodeTxt);
         StrReplace(msg, "%s2", IStr(node));

         errorCompleteTrace(funcId, msg);
         return (IDE::retNotInitErr);
      }

      return (IDE::noError);
   }


	//====================================================================
	//
	// Internal function sendMsg()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Sends a command dependent of device to a star or to the usb.
	//====================================================================
   static function sendMsg(variable deviceNumber, variable command, variable parameter, variable timeOut, variable makeTrace)
	{
      variable receMsg;
		
		if(isStarDevice(deviceNumber))
		{
			receMsg = sendToStar(deviceNumber, command, parameter, makeTrace);
		}
		else
		{
			receMsg = sendToUsb(deviceNumber, command, parameter, timeOut);
		}

		return (receMsg);

	}


	//====================================================================
	//
	// Internal function sendToUsb()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Sends a command to the corresponding device node via USB.
	//====================================================================
   static function sendToUsb(variable deviceNumber, variable command, variable parameter, variable timeOut)
   {
		variable node;
      variable sendMsg("T");
      variable receMsg;
      string cmd(command);

		node = getNodeFromDeviceNumber(deviceNumber);

      sendMsg = sendMsg + IStr(node-1); // USB has an 0 bsed adderss node 0..7
      sendMsg = sendMsg + command;
      sendMsg = sendMsg + parameter;

      if(isUsbTrace())
  			progressTrace(IDS::sendToUsb, IDS::sendMessageTitle, sendMsg);

      receMsg = m_usbComObject.Request(sendMsg, timeOut); 

      // on request of firmware version do not trace the answere.
      // Answere is traced as firmware version in function traceFirmwareVersion()
      if(isUsbTrace() && (cmd.Find("RF") < 0))
	  		progressTrace(IDS::sendToUsb, IDS::receiveMessageTitle, receMsg);

      return (receMsg);
   }


	//====================================================================
	//
	// Internal function sendToStar()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Sends a command to the corresponding device node via ML_STAR component.
	//====================================================================
   static function sendToStar(variable deviceNumber, variable cmd, variable param, variable makeTrace)
   {
		variable stepShowNameKey(-534118376);
		variable globalKey(-534183935);
		variable orderKey(-534183816);
		variable parameterKey(-534183815);
		variable resultDataKey(-534118396);
		variable resultDataPos(4);
		variable node;
		object	starObject;
	   object 	parsIn;
   	object 	parsOut;
      variable command("T");
      variable parameter(param);
		variable result4;
      variable receMsg;
      string   tempMsg;
      string   tempCmd(cmd);
      variable errPos;

      // device node must be 1 or 2 -->> node must not be updated
		node = getNodeFromDeviceNumber(deviceNumber);

		onerror goto objectError;
      SynEnterCriticalSection(m_hhsCriticalSection);
		starObject = m_starDeviceObj.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);
		onerror goto 0;

      command = command + IStr(node);
      command = command + cmd;

      if(isUsbTrace() && makeTrace)
      {
         string   sendMsg(command);
         sendMsg = sendMsg + param;
  			progressTrace(IDS::sendToStar, IDS::sendMessageTitle, sendMsg);
      }

      // set the command at first of the receMsg
      receMsg = command;

		// activate error handler
		onerror goto Unexpected;

		// create data pars for the firmwareCommand
	   parsIn.CreateObject("HXPARAMSLib.HxPars", hslFalse);
	   parsOut.CreateObject("HXPARAMSLib.HxPars", hslFalse);

	   parsIn.Add(2, "ParsCommandVersion");
	   parsIn.Add("FirmwareCommand", "StepName");
	   parsIn.Add(457, stepShowNameKey);
	   parsIn.Add(0, "NbrOfErrors");
	   parsIn.Add(command, globalKey, orderKey);
	   parsIn.Add(parameter, globalKey, parameterKey);


		// send command
		starObject.FirmwareCommand(parsIn, parsOut);

	   result4 = parsOut.Item(resultDataKey, resultDataPos);

		parsIn.ReleaseObject();
		parsOut.ReleaseObject();

      receMsg = receMsg + result4;
      tempMsg = receMsg;

      // remove the master error erXX/XX so that the result string is the same than on USB command erXX
      errPos = tempMsg.Find("er");
      if(errPos >= 0)
      {
         if(tempMsg.GetLength() > errPos + 4)
         {
            if(tempMsg.Mid(errPos+4, 1) == "/")
            {
               // the simulator returns er01/00 on a unknown command,
               // in this case, remove the slave error not the master error
               if(tempMsg.GetLength() >= errPos + 7)
               {
                  // check slave error
                  if(tempMsg.Mid(errPos+5, 2) == "00")
                  {
                     // use the master error, so that the return is not null
                     receMsg = tempMsg.Left(errPos+4);
                     receMsg = receMsg + tempMsg.Right(tempMsg.GetLength() - (errPos+7));
                  }
                  else
                  {
                     // use the slave error
                     receMsg = tempMsg.Left(errPos+2);
                     receMsg = receMsg + tempMsg.Right(tempMsg.GetLength() - (errPos+5));
                  }
               }
            }
         }
      }

      // on request of firmware version do not trace the answere.
      // Answere is traced as firmware version in function traceFirmwareVersion()
      if(isUsbTrace() && (tempCmd.Find("RF") < 0) && makeTrace)
	  		progressTrace(IDS::sendToStar, IDS::receiveMessageTitle, receMsg);

      return (receMsg);

		Unexpected:
		{
         variable errId( err.GetId( ) );

			parsIn.ReleaseObject();
			parsOut.ReleaseObject();

         // no connection
         if(errId == -1591212031 || errId == -1574764487)
         {
            receMsg = receMsg + "er0";
            receMsg = receMsg + IStr(IDE::retNotConnectErr);
         }
         else
            Error::RaiseLast();
      }

      // on request of firmware version do not trace the answere.
      // Answere is traced as firmware version in function traceFirmwareVersion()
      if(isUsbTrace() && (tempCmd.Find("RF") < 0))
	  		progressTrace(IDS::sendToStar, IDS::receiveMessageTitle, receMsg);

      return (receMsg);

		objectError:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
      return (receMsg);
	}

	//====================================================================
	//
	// Internal function startPlateLockCmd()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Lock / Unlock the plate
   //  Will make a short error handling on not init and step loss error
	//====================================================================
   static function startPlateLockCmd(variable funcId, variable deviceNumber, variable plateLock)
   {
		variable node;
      variable command("LP");
      variable parameter("lp");
      string   cmdResult;

		node = getNodeFromDeviceNumber(deviceNumber);
      parameter = parameter + IStr(plateLock);

      // lock / unlock plate
		cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      // check for init or staep lost error
      // On step lost, this drive is lost the init state and must be initialized again
      // The library internal initialization flag is set allready and must nod set again
      if((cmdResult.Find(m_fwPlNotInitError) >= 0) || (cmdResult.Find(m_fwPlStepLostError) >= 0))
      {
         string cmdResult2;

         // init drive again
			cmdResult2 = sendMsg(deviceNumber, "LI", "", m_usbMsgTimeout, hslTrue);

         // init has end success
         if(cmdResult2.Find(m_fwNoError) >= 0)
         {
            // lock / unlock plate
				cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);
         }
      }
      return (cmdResult);
   } 

	//====================================================================
	//
	// Internal function startShakingCmd()
	//
   //--------------------------------------------------------------------
   // Description:
   //  Start / Stop plate shaking
   //  Will make a short error handling on not init and step loss error
	//====================================================================
   static function startShakingCmd(
      variable funcId, variable deviceNumber,
      variable command, variable parameter, variable isStart)
   {
      string   cmdResult;

		// send command
		cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);

      // check for init or step lost error
      // On step lost, this drive is lost the init state and must be initialized again
      // The library internal initialization flag is set allready and must nod set again
      if((cmdResult.Find(m_fwShNotInitError) >= 0) || (cmdResult.Find(m_fwShStepLostError) >= 0))
      {
         string cmdResult2;

         // init drive again
         cmdResult2 = sendMsg(deviceNumber, "SI", "", m_usbMsgTimeout, hslTrue);

         // if not start, do not repeat the main command and return the really returned error
         if(isStart)
         {
            // init has end success
            if(cmdResult2.Find(m_fwNoError) >= 0)
            {
					cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, hslTrue);
            }
         }
      }
      return (cmdResult);
   } 

	//====================================================================
	//
	// Internal function setHHSSetting()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check the given deviceNumber from a interface function
	//====================================================================
	static function setHHSSetting(variable funcId, variable deviceNumber, variable& hhsSetting)
	{
      string   cmdResult;
      variable funcRc(IDE::noError);

		hhsSetting = 0;
      if(!isSimulate(0, deviceNumber, hslFalse))
		{
			variable startPos(-1);

			// read the HHS settings
			cmdResult = sendMsg(deviceNumber, "QU", "", m_usbMsgTimeout, hslTrue);
			funcRc = isFirmwError(funcId, cmdResult, hslTrue);
         if(0 < funcRc)
            return (funcRc);

      	startPos = cmdResult.Find("au");
	      if(startPos >= 0 && cmdResult.GetLength() >= 25)
	      {
				variable shaker;
				variable heater;
				// cmdResult auswerten
				// format "TxQUau0 0 0 0 0 0 0 0 0 0"
				shaker = cmdResult.Mid(startPos+2, 1);
				heater = cmdResult.Mid(startPos+4, 1);
				if(shaker == "1" && heater == "1")
					hhsSetting = m_shakingPropertyNothing;
				else
				if(shaker == "1")
					hhsSetting = m_shakingPropertyOnlyHeat;
				else
				if(heater == "1")
					hhsSetting = m_shakingPropertyOnlyShake;
			}
		}

		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		m_hhsSetting[deviceNumber-1] = hhsSetting;
      SynLeaveCriticalSection(m_hhsCriticalSection);

      return(funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }

		return (funcRc);
	}


	//====================================================================
	//
	// Internal function hasHeater()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check if the heater is activated on current HHS
	//====================================================================
	static function hasHeater(variable funcId, variable deviceNumber, variable throw)
	{
		variable hhsSettings(-1);
      variable funcRc(hslFalse);

		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		hhsSettings = m_hhsSetting.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

		if((hhsSettings == m_shakingPropertyHeatAndShake) || (hhsSettings == m_shakingPropertyOnlyHeat))
			funcRc = hslTrue;

		if(funcRc == hslFalse && throw == 1)
		{
			// "Current HHS module on %s1 '%s2' cannot used as heater"
	      variable nodeNameId(IDS::starNode);
	      variable node;
         string 	msg;
         string 	nodeName;
         variable funcName;

			node = getNodeFromDeviceNumber(deviceNumber);
			if(!isStarDevice(deviceNumber))
				nodeNameId = IDS::usbNode;

         msg = StringTable::Load(IDS::heatingNotActivated);
         nodeName = StringTable::Load(nodeNameId);
         funcName = StringTable::Load(funcId);

         StrReplace(msg, "%s1", nodeName);
         StrReplace(msg, "%s2", IStr(node));
         errorCompleteTrace(funcId, msg);

         Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

      return(funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }

		return (funcRc);
	}

	//====================================================================
	//
	// Internal function hasShaker()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check if the heater is activated on current HHS
	//====================================================================
	static function hasShaker(variable funcId, variable deviceNumber, variable throw)
	{
		variable hhsSettings(-1);
      variable funcRc(hslFalse);

		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		hhsSettings = m_hhsSetting.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

		if((hhsSettings == m_shakingPropertyHeatAndShake) || (hhsSettings == m_shakingPropertyOnlyShake))
			funcRc = hslTrue;

		if(funcRc == hslFalse && throw)
		{
			// "Current HHS module on %s1 '%s2' cannot used as shaker."
	      variable nodeNameId(IDS::starNode);
	      variable node;
         string 	msg;
         string 	nodeName;
         variable funcName;

			node = getNodeFromDeviceNumber(deviceNumber);
			if(!isStarDevice(deviceNumber))
				nodeNameId = IDS::usbNode;

         msg = StringTable::Load(IDS::shakingNotActivated);
         nodeName = StringTable::Load(nodeNameId);
         funcName = StringTable::Load(funcId);

         StrReplace(msg, "%s1", nodeName);
         StrReplace(msg, "%s2", IStr(node));
         errorCompleteTrace(funcId, msg);

         Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

      return(funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }

		return (funcRc);
	}

	// --------------------------------------------------------------------------------------
	// Library traces
	// --------------------------------------------------------------------------------------
	//====================================================================
	//
	// Internal function versionTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces the start of a exported function
	//====================================================================
   static function versionTrace() void
   {
		variable traceSource;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      FormatTrace(traceSource, "HSLHamHeaterShakerLib", TraceStatus::cmd_progress, HamHeaterShakerVersion);
   }

	//====================================================================
	//
	// Internal function startTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces the start of a exported function
	//====================================================================
   static function startTrace(variable funcName) void
   {
		variable traceSource;
      variable functionName;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_start);
   }

	//====================================================================
	//
	// Internal function progressTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces a msg during a exported function is working
	//====================================================================
   static function progressTrace(variable funcName, variable progMsgTitle, variable progMsg) void
   {
		variable traceSource;
      variable functionName;
      variable progressTitle;
      variable progressMsg;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      if(GetType(progMsgTitle) == "i")
         progressTitle = StringTable::Load(progMsgTitle);
      else
         progressTitle = progMsgTitle;

      if(GetType(progMsg) == "i")
         progressMsg = StringTable::Load(progMsg);
      else
         progressMsg = progMsg;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_progress, progressTitle, progressMsg);
   }

	//====================================================================
	//
	// Internal function errorTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces an error msg during a exported function is working
	//====================================================================
   static function errorTrace(variable funcName, variable errMsg) void
   {
		variable traceSource;
      variable functionName;
      variable errorMsg;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      if(GetType(errMsg) == "i")
         errorMsg = StringTable::Load(errMsg);
      else
         errorMsg = errMsg;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_error, errorMsg);
   }

	//====================================================================
	//
	// Internal function errorCompleteTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces an error msg on end of an exported function
	//====================================================================
   static function errorCompleteTrace(variable funcName, variable errMsg) void
   {
		variable traceSource;
      variable functionName;
      variable errorMsg;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      if(GetType(errMsg) == "i")
         errorMsg = StringTable::Load(errMsg);
      else
         errorMsg = errMsg;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_errComplete, errorMsg);
   }

	//====================================================================
	//
	// Internal function endTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces the end of an exported function
	//====================================================================
   static function endTrace(variable funcName) void
   {
		variable traceSource;
      variable functionName;

      initStringTable();

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      FormatTrace(traceSource, functionName, TraceStatus::cmd_complete);
   }

	//====================================================================
	//
	// Internal function traceFirmwareVersion()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces the firmware version of an used heater shaker
	//====================================================================
	// this function is used in InitializeLibrary() and uses index 0..10	
	static function traceFirmwareVersion(variable funcId, variable deviceNumber)
	{
      variable nodeNameId(IDS::starNode);
		string 	answString;
		variable startPos(0);
		
		// read the firmware version of current node
		answString = sendMsg(deviceNumber, "RF", "", m_usbInitTimeout, hslTrue);

		if(!isStarDevice(deviceNumber))
			nodeNameId = IDS::usbNode;

		startPos = answString.Find("rf");
		if(startPos >= 0)
		{
			string fwVers;
			string title;
			string nodeName;
			variable node;

			node = getNodeFromDeviceNumber(deviceNumber);

			fwVers = answString.Right(answString.GetLength()-(startPos+2));
			// Text: "%s1 '%s2' firmware version = "
			title = StringTable::Load(IDS::firmwareVersion);
			nodeName = StringTable::Load(nodeNameId);
			
			StrReplace(title, "%s1", nodeName);
			StrReplace(title, "%s2", IStr(node));


			progressTrace(funcId, title, fwVers);
		}
	}

	//====================================================================
	//
	// Internal function sendToProgressTrace()
	//
   //--------------------------------------------------------------------
   // Description:
   // Traces a msg during a exported function is working
	//====================================================================
   static function sendToProgressTrace(
      variable funcName,
      variable deviceNumber)
      void
   {
		variable traceSource;
      variable functionName;
      variable nodeNameId(IDS::starNode);
		string   nodeName;
      variable progressMsg;
      variable node;

      initStringTable();

		node = getNodeFromDeviceNumber(deviceNumber);

		if(!isStarDevice(deviceNumber))
         nodeNameId = IDS::usbNode;

      nodeName = StringTable::Load(nodeNameId);

      traceSource = StringTable::Load(IDS::traceSource);	// source for formated trace
      if(GetType(funcName) == "i")
         functionName = StringTable::Load(funcName);
      else
         functionName = funcName;

      // Text: "Start command to %s1(%s2)."
      progressMsg = StringTable::Load(IDS::progressSendTo);


      StrReplace(progressMsg, "%s1", nodeName);
      StrReplace(progressMsg, "%s2", IStr(node));


      FormatTrace(traceSource, functionName, TraceStatus::cmd_progress, progressMsg);
   }


	// --------------------------------------------------------------------------------------
	// Input parameter check function
	// --------------------------------------------------------------------------------------

	//====================================================================
	//
	// Internal function checkStringInput()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a string
	//====================================================================
   static function checkStringInput(variable funcId, variable parameterName, variable input)
   {
      if(GetType(input) != "s")
      {
         // Wrong type of parameter; '%s1(%s2)' must be a string.
         string msg;
         string param;
         variable funcName;
         msg = StringTable::Load(IDE::noStringValue);
         funcName = StringTable::Load(funcId);

         if(GetType(input) == "i")
            param = IStr(input);
         if(GetType(input) == "f")
            param = FStr(input, hslTrue);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", param);


         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::noStringValue, msg, GetFileName(), funcName, GetLineNumber());
      }
   }

	//====================================================================
	//
	// Internal function checkDoubleInput()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a double
	//====================================================================
   static function checkDoubleInput(
      variable funcId, variable parameterName, variable input)
   {
      if((GetType(input) != "f") && (GetType(input) != "i"))
      {
         // Wrong type of parameter; '%s1(%s2)' must be a number.
         string msg;
         string param("'%s'");
         variable funcName;
         msg = StringTable::Load(IDE::noDoubleValue);
         funcName = StringTable::Load(funcId);

         if(GetType(input) == "s")
            StrReplace(param, "%s", input);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", param);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::noDoubleValue, msg, GetFileName(), funcName, GetLineNumber());
      }
   }

	//====================================================================
	//
	// Internal function checkDoubleInputRange()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a double in a defined range
	//====================================================================
   static function checkDoubleInputRange(
      variable funcId, variable parameterName, variable input, variable min, variable max)
   {
      checkDoubleInput(funcId, parameterName, input);

      if((input < min) || (input > max))
      {
         // "Parameter out of range; '%s1(%s2)' must be between [%s3..%s4]."
         string msg;
         variable funcName;
         msg = StringTable::Load(IDS::parameterOutOfRange);
         funcName = StringTable::Load(funcId);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", FStr(input, hslTrue));
         StrReplace(msg, "%s3", FStr(min, hslTrue));
         StrReplace(msg, "%s4", FStr(max, hslTrue));

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::syntaxParRangeError, msg, GetFileName(), funcName, GetLineNumber());
      }
   }

	//====================================================================
	//
	// Internal function checkIntegerInput()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a integer
	//====================================================================
   static function checkIntegerInput(
      variable funcId, variable parameterName, variable input)
   {
      if(GetType(input) != "i")
      {
         // Wrong type of parameter; '%s1(%s2)' must be a number.
         string msg;
         string param;
         variable funcName;
         msg = StringTable::Load(IDE::noIntegerValue);
         funcName = StringTable::Load(funcId);

         if(GetType(input) == "s")
         {
            param = "'";
            param = param + input;
            param = param + "'";
         }
         if(GetType(input) == "f")
            param = FStr(input, hslTrue);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", param);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::noIntegerValue, msg, GetFileName(), funcName, GetLineNumber());
      }
   }

	//====================================================================
	//
	// Internal function checkIntegerInputRange()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check an input parameter which must be a integer in a defined range
	//====================================================================
   static function checkIntegerInputRange(
      variable funcId, variable parameterName, variable input, variable min, variable max)
   {
      checkIntegerInput(funcId, parameterName, input);

      if((input < min) || (input > max))
      {
         // "Parameter out of range; '%s1(%s2)' must be between [%s3..%s4]."
         string msg;
         variable funcName;
         msg = StringTable::Load(IDS::parameterOutOfRange);
         funcName = StringTable::Load(funcId);

         StrReplace(msg, "%s1", parameterName);
         StrReplace(msg, "%s2", IStr(input));
         StrReplace(msg, "%s3", IStr(min));
         StrReplace(msg, "%s4", IStr(max));

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::syntaxParRangeError, msg, GetFileName(), funcName, GetLineNumber());
      }
   }


	//====================================================================
	//
	// Internal function isStarDevice()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check if the used deviceNumber from a ML_STAR
	//====================================================================
	static function isStarDevice(variable deviceNumber)
	{
		variable funcRc(hslFalse);
		variable devName;

		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		devName = m_deviceName.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

		// check for usb name
		if(devName != m_hhsUsbObjectName)
		{
			funcRc = hslTrue;
		}

      return(funcRc);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
	}

	//====================================================================
	//
	// Internal function getNodeFromDeviceNumber()
	//
   //--------------------------------------------------------------------
   // Description:
   // Retunrs the saved node ID dependent of the deviceNumber
	//====================================================================
	static function getNodeFromDeviceNumber(variable deviceNumber)
	{
		variable usedNode;

		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		usedNode = m_nodeNumber.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

      return(usedNode);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
	}


	//====================================================================
	//
	// Internal function checkDeviceNumber()
	//
   //--------------------------------------------------------------------
   // Description:
   // Check the given deviceNumber from a interface function
	//====================================================================
	static function checkDeviceNumber(variable funcId, variable deviceNumber)
	{
		variable devName, nodeNr;

		if((deviceNumber < m_firstDeviceNumber) || (deviceNumber > m_lastDeviceNumber))
		{
         string msg;
         variable funcName;
			// "Parameter 'deviceNumber' contains an invalid value! \r\nMust be created with function CreateStarDevice() or CreateUsbDevice()"
         msg = StringTable::Load(IDS::invalidDeviceNumber);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);
		devName = 	m_deviceName.GetAt(deviceNumber-1);
		nodeNr = 	m_nodeNumber.GetAt(deviceNumber-1);
      SynLeaveCriticalSection(m_hhsCriticalSection);

		// check for usb name
		if((devName == "") || (nodeNr == 0))
		{
         string msg;
         variable funcName;
			// "Parameter 'deviceNumber' contains an invalid value! \r\nMust be created with function CreateStarDevice() or CreateUsbDevice()"
         msg = StringTable::Load(IDS::invalidDeviceNumber);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}

		return;

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
	}


	//====================================================================
	//
	// Internal function formatParam()
	//
   //--------------------------------------------------------------------
   // Description:
   // Formats an numeric input to a string with leading 0 to lenth of strWidth
	//====================================================================
	static function formatParam(
			variable param,											// i: the paramter to normalize (integer)
			variable strWidth)										// i: the width to be filled (integer)
	{
		string sParam; 
		sParam = IStr(param);
		StrFillLeft(sParam, "0", strWidth);
		return (sParam);
	}

	//====================================================================
	//
	// Internal function normalizeParam()
	//
   //--------------------------------------------------------------------
   // Description:
   // Formats an numeric (double)input to 1/10 values and format it
   //	to a string with leading 0 to lenth of strWidth
	//====================================================================
	static function normalizeParam(								// returns the given parameter normalized for firmware command as string
			variable param,											// i: the paramter to normalize as float or integer
			variable strWidth)										// i: the width to be filled (integer)
	{
		string sParam; 
		sParam = IStr(Floor(MthRound(param*10, 0)));
		StrFillLeft(sParam, "0", strWidth);
		return (sParam);
	}



	// --------------------------------------------------------------------------------------
	// Firmware error check function
	// --------------------------------------------------------------------------------------
	
	//====================================================================
	//
	// Internal function getFirmwErrorId()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Reads the firmware error number from cmdResult string and convert it to a number
	//====================================================================
   static function getFirmwErrorId(string cmdResult)
   {
      variable errNr(0);
      variable startPos(0);
      startPos = cmdResult.Find("er");

      if((startPos >= 0) && ((startPos+4) <= cmdResult.GetLength()))
      {
         variable errNo;
         errNo = cmdResult.Mid((startPos+2), 2);
         errNr = IVal(errNo);
      }
      return (errNr);
   }

	//====================================================================
	//
	// Internal function getErrIdFromFirmwareError()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Converts the firmware error number to function return error number
	//====================================================================
   static function getErrIdFromFirmwareError(string cmdResult)
   {
      variable firmwErrId(getFirmwErrorId(cmdResult));
      
      if(0 == firmwErrId)
         return (IDE::noError);
      else if(1 == firmwErrId)
         return (IDE::retErr);
      else if(2 == firmwErrId)
         return (IDE::retNotInitErr);
      else if(3 == firmwErrId)
         return (IDE::retNotConnectErr);
      else if (10 == firmwErrId)
         return (IDE::canError);
      else if (20 == firmwErrId)
         return (IDE::eepromError);
      else if (30 == firmwErrId)
         return (IDE::syntaxCmdError);
      else if (31 == firmwErrId)
         return (IDE::syntaxParUnkError);
      else if (32 == firmwErrId)
         return (IDE::syntaxParRangeError);
      else if (35 == firmwErrId)
         return (IDE::generalVoltError);
      else if (36 == firmwErrId)
         return (IDE::generalStopError);
      else if (37 == firmwErrId)
         return (IDE::generalAddrError);
      else if (40 == firmwErrId)
         return (IDE::parallelError);
      else if (41 == firmwErrId)
         return (IDE::parallelError);
      else if (42 == firmwErrId)
         return (IDE::parallelError);
      else if (50 == firmwErrId)
         return (IDE::shakerInitError);
      else if (51 == firmwErrId)
         return (IDE::shakerNotInitError);
      else if (52 == firmwErrId)
         return (IDE::shakerStepLossError);
      else if (53 == firmwErrId)
         return (IDE::shakerStartModeError);
      else if (55 == firmwErrId)
         return (IDE::plateLockInitError);
      else if (56 == firmwErrId)
         return (IDE::plateLockNotInitError);
      else if (57 == firmwErrId)
         return (IDE::plateLockStepLossError);
      else if (60 == firmwErrId)
         return (IDE::tempNotStartError);
      else if (61 == firmwErrId)
         return (IDE::tempTimeoutError);
      else if (62 == firmwErrId)
         return (IDE::tempSuperRangeError);
      else if (63 == firmwErrId)
         return (IDE::tempSecurRangeError);
      else if (64 == firmwErrId)
         return (IDE::tempSensorError);
      else if (98 == firmwErrId)
         return (IDE::commandSendTimeout);
      else
         return (IDE::unknowFwError);
   }

	//====================================================================
	//
	// Internal function isFirmwError()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Check if an error is set in cmdResult string
	//====================================================================
   static function isFirmwError(variable funcId, string cmdResult, variable makeTrace)
   {
      variable rc(IDE::noError);

      if(cmdResult.Find(m_fwNoError) == -1)
      {
         variable errId;
         variable errText;
         errId = getErrIdFromFirmwareError(cmdResult);
         // string erXX was not found (answere command)
         if(errId != IDE::noError)
			{
				rc = errId;

				errText = StringTable::Load(errId);

				// make an exception handling for errors which contains a %s part
				if(errId == IDE::unknowFwError)
					StrReplace(errText, "%s", IStr(getFirmwErrorId(cmdResult)));
				if(errId == IDE::commandSendTimeout)
					StrReplace(errText, "%s", cmdResult.Left(4));

				if(makeTrace)
  					errorCompleteTrace(funcId, errText);
  			}
      }

      return (rc);
   }


	//====================================================================
	//
	// Internal function saveAndCreateDeviceNumber()
	//
   //--------------------------------------------------------------------
   // Description:
   //	save the device parameter and create the deviceNumber which must 
	// be used for each interface function
	//====================================================================
	static function saveAndCreateDeviceNumber(
		variable funcId,
		variable deviceName,
		object& 	starObject,
		variable isStarSimulate,
		variable usedNode)
	{
		variable deviceNumber(0);
		variable index(0);

		onerror goto Unexpected;

      SynEnterCriticalSection(m_hhsCriticalSection);

		// USB set always the starObject parameter with a null object
	   if(starObject.IsNull() && m_usbComObject.IsNull())
	   {
	      // create the usb object without event 
	      m_usbComObject.ReleaseObject();
	      m_usbComObject.CreateObject(m_hhsUsbObjectName, hslFalse);


	      if(!m_usbComObject.IsNull())
	      {
	         // "{BD0DAB87-838B-44c5-A114-1CBA5BE0E45F}", bufferSize(4090), vendorId(2223), productId, mainSerialNumber);
	         m_usbComObject.InitObject (m_hhsUsbProductNum, m_hhsUsbSerieNum);

	      }
	      else
	      {
	         string msg;
	         variable funcName;

		      SynLeaveCriticalSection(m_hhsCriticalSection);

				// "Parameter 'starDevice' contains an invalid object."
	         msg = StringTable::Load(IDS::cannotCreateUsbPort);
	         funcName = StringTable::Load(funcId);

	         errorCompleteTrace(funcId, msg);

				Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
	      }
	   }

		// check if this node allready used
      for( index = 0; index < m_maxHHS; index++)
      {
			variable devN, nodeNum;
			devN = m_deviceName.GetAt(index);
			nodeNum = m_nodeNumber.GetAt(index);

			// if equal, node already exist
			if((devN == deviceName) && (nodeNum == usedNode))
				deviceNumber = index+1;
		}

		if(deviceNumber == 0)
		{
			// node is not used, set it on the first free position
	      for( index = 0; index < m_maxHHS; index++)
	      {
				variable devN;
				devN = m_deviceName.GetAt(index);
				// if empty
				if(devN == "")
				{
					m_deviceName[index] = deviceName;
					m_starDeviceObj[index] = starObject;
					m_isStarSimulate[index] = isStarSimulate;
					m_nodeNumber[index] = usedNode;
					deviceNumber = index+1;
					break;
				}
	      }
		}
		
      SynLeaveCriticalSection(m_hhsCriticalSection);

		if(deviceNumber == 0)
		{
         string msg;
         variable funcName;
			// "Parameter 'starDevice' contains an invalid object."
         msg = StringTable::Load(IDS::maxHHSReached);
         funcName = StringTable::Load(funcId);

         errorCompleteTrace(funcId, msg);
			Error::RaiseEx(IDE::retErr, msg, GetFileName(), funcName, GetLineNumber());
		}


      return(deviceNumber);

		Unexpected:
		{
         SynLeaveCriticalSection(m_hhsCriticalSection);
   		Error::RaiseLast();
      }
	}

	//====================================================================
	//
	// Internal function Wait()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Wait the given time
	//====================================================================
	static function wait(variable waitTime)
	{
		timer t;
		
      // Wait waitTime seconds
      t.SetTimer( waitTime );
      t.WaitTimer( hslFalse, hslFalse );
	}


	//====================================================================
	//
	// Internal function getCurrentShakerRPM()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Read the shaking speed of current HHS
	//====================================================================
	static function getCurrentShakerRPM(variable deviceNumber, variable makeTrace)
	{
		variable shakingSpeed(0);
      variable command("RR");
      string   parameter("");
      string   cmdResult;
		variable startPos(0);

     	// start request
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, makeTrace);
      // format: rr####
      startPos = cmdResult.Find("rr");
      if(startPos >= 0)
      {
			shakingSpeed = IVal(cmdResult.Mid((startPos+2), 4));
      }
		return (shakingSpeed);
	}


	//====================================================================
	//
	// Internal function getCurrentTemp()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Read the shaking speed of current HHS
	//====================================================================
	static function getCurrentTemp(variable deviceNumber, variable makeTrace)
	{
		variable temperature(0);
      variable command("RT");
      variable parameter("");
      string   cmdResult;
      variable startPos;
      variable firstVal;
      variable secVal;
      variable averageVal;

     	// wait for temperature is reached
      cmdResult = sendMsg(deviceNumber, command, parameter, m_usbMsgTimeout, makeTrace);

      // format: rt#### ####
      startPos = cmdResult.Find("rt");
      if((startPos >= 0) && ((cmdResult.GetLength()-startPos) >= TemperateParam::tempTempRequestLength))
      {
	      // read both temperature and calculate the average 
	      // format: rt#### ####
	      firstVal = FVal(cmdResult.Mid((startPos+2), 5));
	      secVal   = FVal(cmdResult.Mid((startPos+8), 5));

	      // calculate the average in 1/10 degrees
	      averageVal = ((firstVal + secVal) / 2) /10;
	      temperature = MthRound(averageVal, 1);
      }
		return (temperature);
	}



	//====================================================================
	//
	// Internal function MonitorHeaterShaker()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Monitors temperature and speed of a HHS module
	//====================================================================
   synchronized function monitorHeaterShaker()
   {
      variable monitorComplete( 0 );
		event		intervalEvent;
      variable currentStatus(-1);
		variable funcName;
		variable sTitle;
		variable hTitle;
		variable stateTitle;
		variable heatingUp(hslTrue);
      variable result;
      variable oldResult;
		variable notStopped(hslTrue); // action Stop not used

      // set the locals...
      variable devNumber(m_monitorDeviceNumber);
      variable hMin(m_monitorHeaterMin);
      variable hMax(m_monitorHeaterMax);
      variable sMin(m_monitorShakerMin);
      variable sMax(m_monitorShakerMax);
      variable interval(m_monitorSampleInterval);
      variable action(m_monitorAction);
      variable curRpm(sMin);		// if not available, the speed must be OK
      variable curTemp(hMin);		// if not available, the temperature must be OK
		variable node;
      variable nodeType;

	  	// reset globals
	   m_monitorDeviceNumber			= 0;
	   m_monitorShakerMin				= 0;
	   m_monitorShakerMax				= 0;
	   m_monitorSampleInterval			= 0;
	   m_monitorAction					= 0;
		m_monitorHeaterMin				= 0;
		m_monitorHeaterMax				= 0;
	   m_monitorResult[devNumber-1] 	= -1;

		// set min max temperature dependend of current heater settings
		// critical section is set in StartMonotoring() function
		intervalEvent = m_monitorEvent.GetAt(devNumber-1);

		// free start semaphore
		m_monitorStartEvent.SetEvent();

		initStringTable();

      if(isStarDevice(devNumber))
         nodeType = StringTable::Load(IDS::starNode);
      else
         nodeType = StringTable::Load(IDS::usbNode);
		nodeType = nodeType + " (";
		node = getNodeFromDeviceNumber(devNumber);
		nodeType = nodeType + IStr(node);
		nodeType = nodeType + " )";


		funcName = StringTable::Load(IDF::Monitoring);
		funcName = funcName + " ";
		funcName = funcName + nodeType;
		sTitle = StringTable::Load(IDS::monitoringShakingTitle);
		hTitle = StringTable::Load(IDS::monitoringTempTitle);
		stateTitle = StringTable::Load(IDS::monitoringStateTitle);


      while (monitorComplete == 0)
      {
         // WaitEvent returns 0 if still waiting or non-zero
         // if the event was triggered.
         monitorComplete = intervalEvent.WaitEvent( interval );

			if( monitorComplete == 0 && notStopped)
			{
				if(hasShaker(0, devNumber, 0))
				{
					variable title(sTitle);

					// read currect RPM
					curRpm = getCurrentShakerRPM(devNumber, hslFalse);

					progressTrace(funcName, title, IStr(curRpm));
				}

				if(hasHeater(0, devNumber, 0))
				{
					variable title(hTitle);

					if(heatingUp)
					{
				      string   cmdResult;
						variable partResult("qd1");

				      // ask if heater in state heating up
						cmdResult = sendMsg(devNumber, "QD", "", m_usbMsgTimeout, hslFalse);
						if(cmdResult.Find(partResult) < 0)
							heatingUp = hslFalse;
						if(heatingUp)
							title = StringTable::Load(IDS::monitoringTempHeatUpTitle);
					}

					// read current temperature
					curTemp = getCurrentTemp(devNumber, hslFalse);

					progressTrace(funcName, title, FStr(curTemp, hslTrue));
				}

		      SynEnterCriticalSection(m_hhsCriticalSection);
				result = m_monitorResult.GetAt(devNumber-1);
		      SynLeaveCriticalSection(m_hhsCriticalSection);

	         oldResult = result;

	         // Calculate the current state of the heater/shaker
	         if( (((curTemp < hMin) || (curTemp > hMax)) && !heatingUp) && ((curRpm < sMin) || (curRpm > sMax)))
	         {
	         	currentStatus = MonitorStatus::monitorErrHeatingAndShaking;
	         }
	         else if ( ((curTemp < hMin) || (curTemp > hMax)) && !heatingUp )
	         {
	            currentStatus = MonitorStatus::monitorErrHeating;
	         }
	         else if ( (curRpm < sMin) || (curRpm > sMax) )
	         {
	            currentStatus = MonitorStatus::monitorErrShaking;
	         }
				else
				{
					currentStatus = MonitorStatus::monitorOK;
				}

	         // If the monitor status has previously not been set, set it.
	         // Otherwise, use bitwise OR to merge the current result with the previous result
	         if (result == -1)
	            result = currentStatus;
	         else
	            result = currentStatus | result;
         
		      SynEnterCriticalSection(m_hhsCriticalSection);
				m_monitorResult[devNumber-1] = result;
		      SynLeaveCriticalSection(m_hhsCriticalSection);

				progressTrace(funcName, stateTitle, IStr(result));

	         if ( result != MonitorStatus::monitorOK )
	         {
	            if ( action == MonitorAction::monitorActionStop )
	            {
						// stop shaking and heating
						if(hasShaker(0, devNumber, 0))
							StopShaker(devNumber);

						if(hasHeater(0, devNumber, 0))
							StopTempCtrl(devNumber);

						// end monitoring but leave in the loop for a correct end of the automatic semapore intervalEvent
						notStopped = hslFalse;
	            }
					if(action == MonitorAction::monitorActionAbort)
					{
						errorTrace(funcName, IDS::monitoringAbort);
						abort;
					}
				}

			}

	   }  // end while

      return(0);
   }

	//====================================================================
	//
	// Internal function pollingForRunningShaker()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Polling until shaker has end shaked or time is elapsed
	//	Polling is neccessary that during a long wait time an Abort()
	// command can be execute.
	//====================================================================
	static function pollingForRunningShaker(
		variable deviceNumber, variable maxPollingTime)
	{
      string   cmdResult;
		variable maxPTime(maxPollingTime);
		variable intervalTime(5);
		variable partResult("rd1");

		if(maxPollingTime > 10)
		{
	      // ask if shaker is running
			cmdResult = sendMsg(deviceNumber, "RD", "", m_usbMsgTimeout, hslFalse);

			while(cmdResult.Find(partResult) > 0 && maxPTime > 0)
			{
				maxPTime = maxPTime - intervalTime;
				wait(intervalTime);
				cmdResult = sendMsg(deviceNumber, "RD", "", m_usbMsgTimeout, hslFalse);
			}
		}
	}

	//====================================================================
	//
	// Internal function pollingForRunningHeater()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Polling until heater is in temperature controlling mode
	//	Polling is neccessary that during a long wait time an Abort()
	// command can be execute.
	//====================================================================
	static function pollingForRunningHeater(
		variable deviceNumber, variable maxPollingTime)
	{
      string   cmdResult;
		variable maxPTime(maxPollingTime);
		variable intervalTime(10);
		variable partResult("qd1");

		if(maxPollingTime > 10)
		{
	      // ask if heater in state heating up
			cmdResult = sendMsg(deviceNumber, "QD", "", m_usbMsgTimeout, hslFalse);

			while(cmdResult.Find(partResult) > 0 && maxPTime > 0)
			{
				maxPTime = maxPTime - intervalTime;
				wait(intervalTime);
				cmdResult = sendMsg(deviceNumber, "QD", "", m_usbMsgTimeout, hslFalse);
			}
		}
	}

	//====================================================================
	//
	// Internal function OnAbortHHSLibrary()
	//
   //--------------------------------------------------------------------
   // Description:
   //	Stop heating and shaking for all HHS module
	//====================================================================
	static function OnAbortHHSLibrary()
	{
		variable deviceNumber;

      for( deviceNumber = 1; deviceNumber <= m_maxHHS; deviceNumber++)
      {
         if(isHeaterInitialized(deviceNumber))
         {
            // call StartShaker with 1 base node
				StopShaker(deviceNumber);
            StopTempCtrl(deviceNumber);
         }
      }

		Terminate();
		return;
	}


}

#endif
// $$author=TBenz$$valid=1$$time=2013-03-06 12:47$$checksum=fc24f279$$length=082$$